{
    "cells": [
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
       "cellView": "form",
       "id": "6mYSH1yDOwvw"
      },
      "outputs": [],
      "source": [
       "#@title { form-width: \"2%\" }\n",
       "#@markdown\n",
       "# v.3.8.4.5ba\n",
       "\n",
       "dev = False #@param {type:\"boolean\"}\n",
       "Save_To_Drive = True #@param {type:\"boolean\"}\n",
       "Save_To_FTP = False #@param {type:\"boolean\"}\n",
       "Remote_Downloads_Path = \"/Downloads\" #@param {type:\"string\"}\n",
       "Remote_Movie_Library_Path = \"/Movies\" #@param {type:\"string\"}\n",
       "Remote_TV_Library_Path = \"/TV\" #@param {type:\"string\"}\n",
       "Remote_Music_Library_Path = \"/Music\" #@param {type:\"string\"}\n",
       "Remote_Software_Path = \"/Downloads/Software\" #@param {type:\"string\"}\n",
       "Remote_Games_Path = \"/Downloads/Games\" #@param {type:\"string\"}\n",
       "\n",
       "import os, sys, platform, pytz, time, traceback, unicodedata, re, requests, random\n",
       "from bs4 import BeautifulSoup as Soup, element\n",
       "from datetime import date, datetime\n",
       "from threading import Thread\n",
       "from ipywidgets import Output\n",
       "pytz.timezone('Turkey')\n",
       "    \n",
       "# Platform in wich the app will run on, basic variables for envs \n",
       "\n",
       "td_id = \"TD1\"\n",
       "td_email = \"default@mail.com\"\n",
       "tz = pytz.timezone('Turkey')\n",
       "os.environ['TZ'] = 'Turkey'\n",
       "IS_ENV_COLAB = 'google.colab' in sys.modules \n",
       "if IS_ENV_COLAB:\n",
       "        time.tzset()\n",
       "\n",
       "nowstr = lambda separete = False: datetime.now(tz).strftime(\"%y-%m-%d-%H-%M-%S\") if separete else str(round(time.time()))\n",
       "rand = lambda: str(random.randint(10000000, 100000000))\n",
       "tb = lambda e: ''.join(traceback.format_tb(e.__traceback__))\n",
       "ex = traceback.format_exc\n",
       "hidden_output = Output()\n",
       "Tag = element.Tag\n",
       "\n",
       "# Platform\n",
       "WINDOWS = 'Windows'\n",
       "LINUX = 'Linux'\n",
       "INFO_EVENT = 0\n",
       "ENV_OS = platform.uname().system\n",
       "if ENV_OS == WINDOWS:\n",
       "    NULL_STREAM =  ' > NUL' \n",
       "elif ENV_OS == LINUX:\n",
       "    NULL_STREAM = ' > /dev/null 2>&1' \n",
       "\n",
       "LOCAL_BASE = '/content' if ENV_OS == LINUX else \"c:/td\"\n",
       "FTP_BASE = '/'\n",
       "DRIVE_BASE = \"/drive/MyDrive\"\n",
       "\n",
       "# GUI API\n",
       "BLUE_COLOR = '#085fb1'  \n",
       "ACCENT_COLOR = BLUE_COLOR\n",
       "SUCCESS_COLOR = '#039129'\n",
       "FONTFAMILY_GLOBAL = 'system-ui'\n",
       "MAINBOX_HEIGHT = '800px'\n",
       "UICLICKER_STOP = \"uiclicker\"\n",
       "UICLICKER_RUN = \"runuiclicker\"\n",
       "SIMULATECLICK_DESC = 'C' + nowstr()\n",
       "\n",
       "# Log\n",
       "LOG_FILENAME = f\"td-log-{nowstr()}\"\n",
       "LOG_DIR_LOCAL = '/content/tdlogs' if ENV_OS == 'Linux' else \"c:/td/logs\"\n",
       "LOG_FILE = f\"{LOG_DIR_LOCAL}/{LOG_FILENAME}.txt\"\n",
       "INFO_LOG = \"Info\"\n",
       "WARNING_LOG = \"Warning\"\n",
       "ERROR_LOG = \"Error\"\n",
       "MAIN = \"Main\"\n",
       "  \n",
       "class Logger: \n",
       "    _instance = None\n",
       "    @staticmethod\n",
       "    def getInstance():\n",
       "        if Logger._instance == None:\n",
       "            Logger()\n",
       "        return Logger._instance\n",
       "\n",
       "    def __init__(self):\n",
       "        if Logger._instance != None:\n",
       "            raise Exception(\"Logger is a singleton.\")\n",
       "        else:\n",
       "            Logger._instance = self\n",
       "            self.queue(f\"New logging Session Started {nowstr(True)}.\", INFO_LOG, MAIN)\n",
       "            os.makedirs(LOG_DIR_LOCAL, exist_ok= True)\n",
       "\n",
       "    logs = []\n",
       "    log_drv = \"\"\n",
       "\n",
       "    def makelog(self, text: str, log_type: str= 'Info', source: str= MAIN) -> str:\n",
       "        now = datetime.now(tz).strftime(\"%y:%m:%d:%H:%M:%S\")\n",
       "        start = \"{} {:^7} {}:\". format(now, log_type, source)\n",
       "        text = text.replace(\"\\n\", f\"\\n{len(start)*' '} \")\n",
       "        newlog = f\"{start} {text}\"\n",
       "        return newlog\n",
       "\n",
       "    def queue(self, text: str, log_type: str= INFO_LOG, source= MAIN):\n",
       "        self.logs.append(self.makelog(text, log_type= log_type, source= source))\n",
       "\n",
       "    def info(self, text: str= \"\", lines = None, v= False):\n",
       "        src = sys._getframe(1).f_code.co_name\n",
       "        if src == '<module>':\n",
       "            src = MAIN\n",
       "            if  v:\n",
       "                print(text)\n",
       "        if lines:\n",
       "            for line in lines:\n",
       "                self.queue(line, INFO_LOG, src)\n",
       "        if text:\n",
       "            self.queue(text, INFO_LOG, src)\n",
       "\n",
       "    def warning(self, text: str= \"\", lines= None, v= False):\n",
       "        src = sys._getframe(1).f_code.co_name\n",
       "        if src == '<module>':\n",
       "            src = MAIN\n",
       "\n",
       "        if lines:\n",
       "            for line in lines:\n",
       "              self.queue(line, WARNING_LOG, src)\n",
       "        if text:\n",
       "            self.queue(text, WARNING_LOG, src)  \n",
       "            if  v:\n",
       "                print(text)\n",
       "\n",
       "    def error(self, text: str= \"\", lines = None, v= False):\n",
       "        src = sys._getframe(1).f_code.co_name\n",
       "        if src == '<module>':\n",
       "            src = MAIN\n",
       "\n",
       "        if lines: \n",
       "            for line in lines:\n",
       "                self.queue(line, ERROR_LOG, src)\n",
       "        if text:\n",
       "            self.queue(text, ERROR_LOG, src)\n",
       "            if  v:\n",
       "                print(text)\n",
       "\n",
       "    def release(self):\n",
       "        if (self.logs):\n",
       "            if self.log(logs = self.logs):\n",
       "                self.logs.clear()\n",
       "            else:\n",
       "                print(\"Logger: An error happend while trying to write log. logs are preserved.\")\n",
       "\n",
       "    def log(self, text = '', log_type= INFO_LOG,  source = MAIN, logs = []): \n",
       "        if not logs and not text:\n",
       "            return True\n",
       "        res = False\n",
       "        if text:\n",
       "            logs.append(self.makelog(text, log_type, source))\n",
       "        res = self.append_lines_to_file(filename = LOG_FILE, lines = logs)\n",
       "\n",
       "        if res:\n",
       "            return True\n",
       "        else:\n",
       "            print(\"Logger: log: An error happened while trying to write log.\")\n",
       "            return False\n",
       "\n",
       "    def save_log(self):\n",
       "        if self.log_drv and os.path.exists(self.log_drv) and os.path.isfile(LOG_FILE):\n",
       "            !rsync -I \"$log_file\" \"$log_drv_file\"\n",
       "    \n",
       "    def append_lines_to_file(self, filename, lines: list[str] = None):\n",
       "        if lines:\n",
       "            try:\n",
       "                with open(filename, \"a+\") as file:\n",
       "                    file.seek(0)\n",
       "                    data = file.read(100)\n",
       "                    if len(data) > 0:\n",
       "                        file.write(\"\\n\")\n",
       "                    if lines:\n",
       "                        for ln in lines:\n",
       "                            ln = ln.rstrip()\n",
       "                            if not ln.endswith(\"\\n\"):\n",
       "                                ln += \"\\n\"\n",
       "                            file.write(ln)\n",
       "            except Exception as e:\n",
       "                return False\n",
       "            return True\n",
       "        return False \n",
       "\n",
       "logger = Logger.getInstance()   \n",
       "\n",
       "#### Setup\n",
       "\n",
       "class SystemConfig():\n",
       "    _instance = None\n",
       "    @staticmethod\n",
       "    def instance():\n",
       "        if SystemConfig._instance == None:\n",
       "            SystemConfig()\n",
       "        return SystemConfig._instance\n",
       "    def __init__(self):\n",
       "        if SystemConfig._instance != None:\n",
       "            raise Exception(\"SystemConfig is a singleton.\")            \n",
       "        else:\n",
       "            SystemConfig._instance = self\n",
       "\n",
       "    savetoftpconst = 1\n",
       "    savetogdriveconst = 2\n",
       "    savetoftp = False\n",
       "    driveenabled = False\n",
       "    ftpenabled = False\n",
       "    ltenabled = True\n",
       "    activedownloads = 5\n",
       "    spotifyenabled = False\n",
       "    gdriveenabled = False\n",
       "    backupenabled = False\n",
       "    ftpuser = None\n",
       "    ftppassword = None\n",
       "    ftphost = None\n",
       "    remotedownloadbase = None\n",
       "    general_path = None\n",
       "    music_path = None\n",
       "    movies_path = None\n",
       "    tv_path = None\n",
       "    software_path = None\n",
       "    games_path = None\n",
       "    moviesbackups = None\n",
       "    tvbackups = None\n",
       "    musicbackups = None\n",
       "    generalbackups = None\n",
       "    uncompleted_downloads = None\n",
       "    remote_uncompleted_path = None\n",
       "    setupthreads: set[Thread] = set()\n",
       "    installed_pkgs: set[str] = set()\n",
       "    international_titles_list = \"ls560608427\"\n",
       "    indian_titles_list= \"ls560456074\"\n",
       "    animation_titles_list = \"ls560333050\"\n",
       "    watch_list = \"ls021271524\" # original ls021271524 or https://www.imdb.com/user/ur84959930/watchlist\n",
       "    watched_movies_list_id =\"ls047519430\"\n",
       "    watched_series_list = \"ls047701980\"\n",
       "    watched_movies_list = []\n",
       "    movie_skip_list = \"\"\n",
       "\n",
       "if not 'config' in globals():\n",
       "    config = SystemConfig.instance()\n",
       "\n",
       "def get_installed_pip_pkgs():\n",
       "    with hidden_output:\n",
       "        cmd = !pip list\n",
       "        hidden_output.clear_output()\n",
       "        return cmd[2:]\n",
       "\n",
       "config.installed_pkgs = get_installed_pip_pkgs()\n",
       "\n",
       "def setup_gservices():\n",
       "    if IS_ENV_COLAB:\n",
       "        global output, drive, eval_js, unmount\n",
       "        from google.colab import output, drive\n",
       "        from google.colab.output import eval_js\n",
       "        unmount = drive.flush_and_unmount\n",
       "        if not os.path.exists(\"/content/drive\"):\n",
       "            with hidden_output:\n",
       "                drive.mount('/content/drive')    \n",
       "        if os.path.exists(\"/content/drive\"):\n",
       "            logger.info(\"Google drive is mounted.\")\n",
       "            config.driveenabled = True\n",
       "        else:\n",
       "            config.driveenabled = False\n",
       "\n",
       "def set_remote_storage_and_pathes():\n",
       "    setup_gservices()\n",
       "    if config.driveenabled or config.ftpenabled:\n",
       "        if config.driveenabled:\n",
       "            REMOTE_BASE = DRIVE_BASE\n",
       "            logger.info(f\"Remote saving to drive is enabled.\")\n",
       "        elif config.ftpenabled :\n",
       "            REMOTE_BASE = FTP_BASE\n",
       "            logger.info(f\"Remote saving to FTP is enabled.\")\n",
       "\n",
       "        config.general_path = LOCAL_BASE + REMOTE_BASE + Remote_Downloads_Path\n",
       "        config.movies_path = LOCAL_BASE + REMOTE_BASE + Remote_Movie_Library_Path\n",
       "        config.tv_path = LOCAL_BASE + REMOTE_BASE + Remote_TV_Library_Path\n",
       "        config.music_path = LOCAL_BASE + REMOTE_BASE + Remote_Music_Library_Path\n",
       "        config.software_path = LOCAL_BASE + REMOTE_BASE + Remote_Software_Path\n",
       "        config.games_path = LOCAL_BASE + REMOTE_BASE + Remote_Games_Path\n",
       "        \n",
       "    else:\n",
       "        config.general_path = f\"{LOCAL_BASE}/Downloads\"\n",
       "        config.movies_path = f\"{LOCAL_BASE}/Downloads/Movies\"\n",
       "        config.tv_path = f\"{LOCAL_BASE}/Downloads/TV Shows\"\n",
       "        config.music_path = f\"{LOCAL_BASE}/Downloads/Music\"\n",
       "        config.software_path = f\"{LOCAL_BASE}/Downloads/Software\"\n",
       "        config.games_path = f\"{LOCAL_BASE}/Downloads/Games\"\n",
       "        logger.info(f\"Remote saving isn't setup.\\nDownloads will be saved locally to: {LOCAL_BASE}/Downloads\")\n",
       "\n",
       "    config.remote_uncompleted_path = config.general_path + \"/\" + \".uncomplete\"\n",
       "\n",
       "    global size_limit, check_uncompleted_downloads, has_size\n",
       "    size_limit = 40000\n",
       "    def has_size(path, only_check = True):\n",
       "        size = 0\n",
       "        if not os.path.exists(path):\n",
       "            return 0\n",
       "        if os.path.isfile(path):\n",
       "            size = os.path.getsize(path)\n",
       "        else:  \n",
       "            for path, dirs, files in os.walk(path):\n",
       "                for file in files:\n",
       "                    filepath = os.path.join(path, file)\n",
       "                    size += os.path.getsize(filepath)\n",
       "                    if only_check and size >= size_limit:\n",
       "                        return True\n",
       "        if size >= size_limit:\n",
       "            return size\n",
       "        else:\n",
       "            return 0\n",
       "        \n",
       "    def check_uncompleted_downloads():\n",
       "        if config.uncompleted_downloads == None:\n",
       "            config.uncompleted_downloads = set()\n",
       "        if os.path.exists(config.remote_uncompleted_path):\n",
       "            logger.info(f\"Checking uncomplete downloads in: {config.remote_uncompleted_path}\")\n",
       "            check = next(os.walk(config.remote_uncompleted_path))\n",
       "            check_items = check[1] + check[2]\n",
       "            for item in check_items:\n",
       "                checkpath = os.path.join(config.remote_uncompleted_path, item)\n",
       "                if has_size(checkpath):\n",
       "                    config.uncompleted_downloads.add(checkpath)\n",
       "                    logger.info(f\"Added uncomplete download: {checkpath}\")\n",
       "        else:\n",
       "            logger.info(f\"Uncomplete download dir not found. {config.remote_uncompleted_path}\")\n",
       "    check_uncompleted_downloads() \n",
       "\n",
       "def normalizestring(input_str):\n",
       "    nfkd_form = unicodedata.normalize('NFKD', input_str)\n",
       "    return u\"\".join([c for c in nfkd_form if not unicodedata.combining(c)])\n",
       "\n",
       "def find_title(title_raw, year_raw):\n",
       "    year = yearstring_pt.search(year_raw)\n",
       "    year = year.group() if year else \"\"\n",
       "    title = \"{0} {1}\".format(title_raw, year)\n",
       "    table = title.maketrans(\"/\",\" \",\":'(,?)\")\n",
       "    title = title.translate(table)\n",
       "    return normalizestring(title.replace(\"&\", \"and\"))\n",
       "\n",
       "def scrape_watched_movies_list(startpage= 1, endpage = 1):\n",
       "    global watched_list_url, yearstring_pt\n",
       "    yearstring_pt = re.compile(r\"\\d{4}\")\n",
       "    watched_list_url = \"https://www.imdb.com/search/title/?title_type=feature&lists=ls047519430&view=simple&sort=alpha,asc&count=250&start=\"\n",
       "    logger.info(f\"Scrapping watched movies list from IMDB. URL:{watched_list_url}.\")\n",
       "    try:\n",
       "        for i in range(startpage-1, endpage):\n",
       "            currentpageurl = watched_list_url + str(i*251)\n",
       "            imdbresponse = requests.get(currentpageurl, headers = {\"Accept-Language\": \"en-US\"})\n",
       "            soup = Soup(imdbresponse.text,'html.parser')    \n",
       "            scrape = soup.find(\"div\", {\"class\":\"lister-list\"})\n",
       "            if not scrape :\n",
       "                return\n",
       "            all_items = scrape.findAll(class_=\"lister-item-header\")\n",
       "            for i in range(len(all_items)):\n",
       "                year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
       "                title_raw = all_items[i].a.text\n",
       "                title = find_title(title_raw, year_raw)      \n",
       "                config.watched_movies_list.append(title)\n",
       "        logger.info(f\"Scrapped watched movies: {len(config.watched_movies_list)} movie.\")\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "    \n",
       "def install_pip_pkgs(*pkgs):\n",
       "    to_install = set()\n",
       "    found = False\n",
       "    for pkg in pkgs:\n",
       "        found = False\n",
       "        for installed_pkg in config.installed_pkgs:\n",
       "            if installed_pkg.startswith(pkg):\n",
       "                logger.info(f\"Package '{installed_pkg}' is already installed.\")\n",
       "                found = True\n",
       "                break\n",
       "        if not found:\n",
       "            to_install.add(pkg)\n",
       "    for pkg in to_install:\n",
       "        logger.info(f\"Installing package '{pkg}'\")\n",
       "        try:\n",
       "            with hidden_output:\n",
       "                cmd = f\"pip install {pkg} {NULL_STREAM}\"\n",
       "                o = !$cmd \n",
       "                hidden_output.clear_output()\n",
       "                config.installed_pkgs.append(pkg)\n",
       "        except Exception as e:            \n",
       "                logger.error(f\"An error happened while installing '{pkg}'\")\n",
       "                logger.error(ex())\n",
       "                logger.release()\n",
       "    return True\n",
       "\n",
       "def install_pip_pkg(pkg):\n",
       "    if pkg in config.installed_pkgs:\n",
       "            logger.info(f\"Package '{pkg}' is already installed.\")\n",
       "            return\n",
       "    logger.info(f\"Installing package '{pkg}'\")\n",
       "    try:\n",
       "        with hidden_output:\n",
       "            cmd = f\"pip install {pkg} {NULL_STREAM}\"\n",
       "            o = !$cmd \n",
       "            hidden_output.clear_output()\n",
       "            config.installed_pkgs.append(pkg)\n",
       "            return True\n",
       "    except Exception as e:            \n",
       "            logger.error(f\"An error happened while installing '{pkg}'\")\n",
       "            logger.error(ex())\n",
       "            logger.release()\n",
       "            return False\n",
       "\n",
       "def uninstallpippkg(*pkgs):\n",
       "    with hidden_output:\n",
       "        for pkg in pkgs:\n",
       "            cmd = f\"pip uninstall {pkg} -y {NULL_STREAM}\"\n",
       "            o = !$cmd\n",
       "    hidden_output.clear_output()\n",
       "    return True\n",
       "\n",
       "def setup_lt_session():\n",
       "    if  not 'ses' in globals():\n",
       "        global ses\n",
       "        ses = lt.session()\n",
       "        User_Agent = '\"Utorrent\"/3.5.5' \n",
       "        sett = {'allow_multiple_connections_per_ip': True,\n",
       "                'active_downloads': config.activedownloads,\n",
       "                'active_seeds':1, 'active_checking': 3,\n",
       "                'active_limit':10, 'announce_to_all_tiers': True,\n",
       "                'announce_to_all_trackers':True,\n",
       "                'allow_multiple_connections_per_ip':True,\n",
       "                'auto_sequential':True, 'auto_manage_interval': 30,\n",
       "                'connections_limit':2330, 'connection_speed': 80,\n",
       "                'connections_slack':50, 'close_redundant_connections':True,\n",
       "                'file_pool_size':20, 'local_service_announce_interval':200,\n",
       "                'max_rejects':8, 'max_peerlist_size': 5000,\n",
       "                'max_paused_peerlist_size': 2000, 'max_failcount':3,\n",
       "                'min_announce_interval':30, 'min_reconnect_time': 20, \n",
       "                'peer_timeout':20, 'request_timeout':10, \n",
       "                'half_open_limit': 100, 'send_buffer_watermark':5*1024*1024, \n",
       "                'strict_end_game_mode':True, 'seed_time_limit': 60, \n",
       "                'tracker_completion_timeout':30, 'upload_rate_limit':0} \n",
       "        #'user_agent': User_Agent,'inactivity_timeout':20, 'ban_web_seeds':False,\n",
       "        ses.apply_settings(sett)\n",
       "        logger.info(f\"LT Client session started.\\nListening ports: 6881, 6891. User agent: {User_Agent}, Active downloads: {config.activedownloads}.\")\n",
       "\n",
       "def setup_lt():\n",
       "    install_pip_pkg('libtorrent')\n",
       "    if not 'lt' in globals():  \n",
       "            global  lt\n",
       "            import libtorrent as lt\n",
       "            logger.info(\"Package 'libtorrent' was installed and in imported to environment.\")\n",
       "            setup_lt_session()\n",
       "    else:\n",
       "        logger.info(\"'lt' is already enabled.'\")\n",
       "    logger.release()\n",
       "\n",
       "def side_setup():\n",
       "    global pn, CheckboxEditor, HTMLTemplateFormatter, widgets, command_error, ERROR_EVENT, LIGHTBLUE_COLOR, LIGHTGREY_COLOR, DARKGERYCOLOR, ORANGE_500, FAIL_COLOR, LOADING_COLOR, WARNING_COLOR, MESSAGE_CONTAINER_HEIGHT, MESSAGE_CONTAINER_PADDING\n",
       "    install_pip_pkg('jupyter_bokeh') # 'jupyter_bokeh' is separated todo: check install bug\n",
       "    import panel as pn\n",
       "    from bokeh.models.widgets.tables import CheckboxEditor, HTMLTemplateFormatter\n",
       "    with hidden_output:\n",
       "        pn.extension('tabulator')\n",
       "    import ipywidgets as widgets\n",
       "    \n",
       "    command_error = lambda cmd, output: f\"A problem happened while executing command:\\n{cmd}Command output:\\n\" + \"\\n\".join(output)\n",
       "    ERROR_EVENT = 10\n",
       "    LIGHTBLUE_COLOR = '#469dff'\n",
       "    LIGHTGREY_COLOR = '#c2c2c2'\n",
       "    DARKGERYCOLOR = '#474747'\n",
       "    ORANGE_500 = '#FF9800'\n",
       "    FAIL_COLOR = '#9c0909'\n",
       "    LOADING_COLOR = '#d96d1a'\n",
       "    WARNING_COLOR = ORANGE_500\n",
       "    MESSAGE_CONTAINER_HEIGHT = '250px'\n",
       "    MESSAGE_CONTAINER_PADDING = '15% 0 0 0' \n",
       "\n",
       "    global downloads_dict, active, completed, uncompleted, checkpoint, htmlformatter, searchresultstableformatters, imdbresultstableformatters, addresultlayout, addresultrowlayout, addrestitlefont, addrestitlestyle, addrestitlestyle, addresultlabelfontsize, addresultvaluefontsize, addreslabelstyle, fileselectionlayout, fileselectiontitlestyle, fileselectionbuttonlayout, filerowfontsize, filetableformatters, filetableeditors, filetablecolumnwidths, monitoractivedownload_views, monitorcompleted_views\n",
       "    \n",
       "    downloads_dict = {}\n",
       "    active = []\n",
       "    completed = [] \n",
       "    uncompleted = []\n",
       "    monitoractivedownload_views = []\n",
       "    monitorcompleted_views = []\n",
       "    checkpoint = '.ipynb_checkpoints'\n",
       "\n",
       "    htmlformatter = HTMLTemplateFormatter()\n",
       "    searchresultstableformatters = {'Name': htmlformatter, 'Uploader': htmlformatter}\n",
       "    imdbresultstableformatters = {\"Title\": htmlformatter,  \"Director\": htmlformatter, \"Stars\": htmlformatter}\n",
       "\n",
       "    addresultlayout =  {'height': '330px', 'width': '100%'}\n",
       "    addresultrowlayout = {}\n",
       "    addrestitlefont = '22px'\n",
       "    addrestitlestyle = ' display: inline-block; margin: 0 0 10px 40px'\n",
       "    addresultlabelfontsize = '18px'\n",
       "    addresultvaluefontsize = '16px'\n",
       "    addreslabelstyle = 'width:180px; display: inline-block; text-align: end; margin: 0 40px 0 0'\n",
       "\n",
       "    fileselectionlayout =  {'height': '470px', 'width': '100%'}\n",
       "    fileselectiontitlestyle = ' display: inline-block; margin: 0 20px 10px 40px'\n",
       "    fileselectionbuttonlayout = {'width': '100px', 'height': '30px'}\n",
       "    filerowfontsize = '16px'\n",
       "    filetableformatters = {'Download': {'type': 'tickCross'},}\n",
       "    filetableeditors = {'No': None, 'Download': CheckboxEditor(), 'Size': None,'Name': None, }\n",
       "    filetablecolumnwidths = {'No': '8%', 'Download': '15%', 'Size': '12%', 'Name': '65%'}\n",
       "\n",
       "    global userinput_layout, userinputbtn_layout, versioninputbtn_layout, userinputtitle_layout, userinputrow1_layout, userinputrow2_layout, userinputrow4_layout, userinputrow3_layout, viewtoprow_layout, userinputtext_layout, userinputtextbtn_layout, userinputview_layout\n",
       "    userinput_layout = {'width':'800px', 'height':'350px', 'align_items': 'center', 'justify_content': 'flex-start', 'padding': '40px 20px 0 20px', 'border': f'2px solid {LIGHTGREY_COLOR}'}\n",
       "    userinputbtn_layout = {'min_width': '100px', 'height':'50px'}\n",
       "    versioninputbtn_layout = {'max_width': '80px', 'max_height':'30px', 'margin': '0 15px 0 0'}\n",
       "    \n",
       "    userinputtitle_layout = {'width':'99%', 'height':'auto', 'padding':'30px', 'margin': '0 0 0 50px'}\n",
       "    userinputrow1_layout = {'width':'99%', 'height':'auto', 'padding':'0 30px', 'margin':'0 0 20px 0'}\n",
       "    userinputrow2_layout = {'justify_content':'center','padding':'0 50px', 'margin':'10px', 'width':'100%', 'align_items': 'center'}\n",
       "    userinputrow3_layout = {'display':'none','justify_content':'flex-start','padding':'0 60px','margin': '12px 0 10px 0', 'width':'100%', 'align_items': 'flex-start'}\n",
       "    userinputrow4_layout = {'display':'none','justify_content':'flex-start','padding':'0 50px', 'margin':'0', 'width':'100%', 'align_items': 'flex-start'}\n",
       "    userinputtext_layout = {'width':'350px '}\n",
       "    userinputtextbtn_layout = {'max_height':'28px', 'width':'90px', 'margin':'2px 0 0 15px'}\n",
       "    userinputview_layout = {'width':'100%', 'height':'100%','align_items': 'center', 'padding':'60px 0 0 0'}\n",
       "    viewtoprow_layout = {\"height\": \"45px\", \"width\": \"100%\", \"align_items\": \"center\", 'padding': '0 0 0 40px'}\n",
       "\n",
       "    global ceil, pd, Immutable, ImmutableString, ImmutableBytes, _mark_immutable, title, string, urllib, Iterable, SMALL, PUNCT, anydigit_pt, SMALL_WORDS, SMALL_FIRST, SMALL_LAST, SUBPHRASE, MAC_MC, MR_MRS_MS_DR, INLINE_PERIOD, UC_ELSEWHERE, CAPFIRST, APOS_SECOND, UC_INITIALS\n",
       "    from math import ceil\n",
       "    import pandas as pd\n",
       "    import string, urllib\n",
       "    import __main__ as main\n",
       "    from collections.abc import Iterable\n",
       "    main.__file__ = \"main_file\"\n",
       "\n",
       "    SMALL = r'a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v\\.?|via|vs\\.?'\n",
       "    PUNCT = r\"\"\"!\"“#$%&'‘()*+,\\-–‒—―./:;?@[\\\\\\]_`{|}~\"\"\"\n",
       "\n",
       "    anydigit_pt = re.compile(r\"\\d\")\n",
       "    SMALL_WORDS = re.compile(r'^(%s)$' % SMALL, re.I)\n",
       "    SMALL_FIRST = re.compile(r'^([%s]*)(%s)\\b' % (PUNCT, SMALL), re.I)\n",
       "    SMALL_LAST = re.compile(r'\\b(%s)[%s]?$' % (SMALL, PUNCT), re.I)\n",
       "    SUBPHRASE = re.compile(r'([:.;?!\\-–‒—―][ ])(%s)' % SMALL)\n",
       "    MAC_MC = re.compile(r\"^([Mm]c|MC)(\\w.+)\")\n",
       "    MR_MRS_MS_DR = re.compile(r\"^((m((rs?)|s))|Dr)$\", re.I)\n",
       "    INLINE_PERIOD = re.compile(r'[\\w][.][\\w]', re.I)\n",
       "    UC_ELSEWHERE = re.compile(r'[%s]*?[a-zA-Z]+[A-Z]+?' % PUNCT)\n",
       "    CAPFIRST = re.compile(r\"^[%s]*?([\\w])\" % PUNCT)\n",
       "    APOS_SECOND = re.compile(r\"^[dol]['‘][\\w]+(?:['s]{2})?$\", re.I)\n",
       "    UC_INITIALS = re.compile(r\"^(?:[A-Z]\\.|[A-Z]\\.[A-Z])+$\")\n",
       "\n",
       "    class Immutable(object):\n",
       "        pass\n",
       "    class ImmutableString(str, Immutable):\n",
       "        pass\n",
       "    class ImmutableBytes(bytes, Immutable):\n",
       "        pass\n",
       "\n",
       "    def _mark_immutable(text):\n",
       "        if isinstance(text, bytes):\n",
       "            return ImmutableBytes(text)\n",
       "        return ImmutableString(text)\n",
       "\n",
       "    def title(text, callback=None, small_first_last=True):\n",
       "        \"\"\"\n",
       "        text: Titlecases input text\n",
       "        callback: Callback function that returns the title-case version of a specific word\n",
       "        small_first_last: Capitalize small words (e.g. 'A') at the beginning; disabled when recursing\n",
       "\n",
       "        Changes all words to Title Caps, and attempts to be clever about capitalizing SMALL words like a/an/the in the input.\n",
       "        The list of \"SMALL words\" which are not capped comes from the New York Times Manual of Style, plus 'vs' and 'v'.\n",
       "        \"\"\"\n",
       "        lines = re.split('[\\r\\n]+', text)\n",
       "        processed = []\n",
       "        for line in lines:\n",
       "            all_caps = line.upper() == line\n",
       "            words = re.split('[\\t ]', line)\n",
       "            tc_line = []\n",
       "            for word in words:\n",
       "                if callback:\n",
       "                    new_word = callback(word, all_caps=all_caps)\n",
       "                    if new_word:\n",
       "                        # Address #22: If a callback has done something\n",
       "                        # specific, leave this string alone from now on\n",
       "                        tc_line.append(_mark_immutable(new_word))\n",
       "                        continue\n",
       "\n",
       "                if all_caps:\n",
       "                    if UC_INITIALS.match(word):\n",
       "                        tc_line.append(word)\n",
       "                        continue\n",
       "\n",
       "                if APOS_SECOND.match(word):\n",
       "                    if len(word[0]) == 1 and word[0] not in 'aeiouAEIOU':\n",
       "                        word = word[0].lower() + word[1] + word[2].upper() + word[3:]\n",
       "                    else:\n",
       "                        word = word[0].upper() + word[1] + word[2].upper() + word[3:]\n",
       "                    tc_line.append(word)\n",
       "                    continue\n",
       "\n",
       "                match = MAC_MC.match(word)\n",
       "                if match:\n",
       "                    tc_line.append(\"%s%s\" % (match.group(1).capitalize(), title(match.group(2), callback, True)))\n",
       "                    continue\n",
       "\n",
       "                match = MR_MRS_MS_DR.match(word)\n",
       "                if match:\n",
       "                    word = word[0].upper() + word[1:]\n",
       "                    tc_line.append(word)\n",
       "                    continue\n",
       "\n",
       "                if INLINE_PERIOD.search(word) or (not all_caps and UC_ELSEWHERE.match(word)):\n",
       "                    tc_line.append(word)\n",
       "                    continue\n",
       "                if SMALL_WORDS.match(word):\n",
       "                    tc_line.append(word.lower())\n",
       "                    continue\n",
       "\n",
       "                if \"/\" in word and \"//\" not in word:\n",
       "                    slashed = map(lambda t: title(t,callback,False), word.split('/'))\n",
       "                    tc_line.append(\"/\".join(slashed))\n",
       "                    continue\n",
       "\n",
       "                if '-' in word:\n",
       "                    hyphenated = map(lambda stringpart: title(stringpart, callback, False), word.split('-'))\n",
       "                    tc_line.append(\"-\".join(hyphenated))\n",
       "                    continue\n",
       "\n",
       "                if all_caps:\n",
       "                    word = word.lower()\n",
       "\n",
       "                # A term with all consonants should be considered an acronym.   \n",
       "                CONSONANTS = ''.join(set(string.ascii_lowercase)\n",
       "                                    - {'a', 'e', 'i', 'o', 'u', 'y'})\n",
       "                is_all_consonants = re.search('\\A[' + CONSONANTS + ']+\\Z', word,\n",
       "                                                flags= re.IGNORECASE)\n",
       "                if is_all_consonants or anydigit_pt.search(word):\n",
       "                    tc_line.append(word.upper())\n",
       "                    continue\n",
       "\n",
       "                # Just a normal word that needs to be capitalized\n",
       "                tc_line.append(CAPFIRST.sub(lambda m: m.group(0).upper(), word))\n",
       "\n",
       "            if small_first_last and tc_line:\n",
       "                if not isinstance(tc_line[0], Immutable):\n",
       "                    tc_line[0] = SMALL_FIRST.sub(lambda m: '%s%s' % (m.group(1), m.group(2).capitalize()), tc_line[0])\n",
       "\n",
       "                if not isinstance(tc_line[-1], Immutable):\n",
       "                    tc_line[-1] = SMALL_LAST.sub(lambda m: m.group(0).capitalize(), tc_line[-1])\n",
       "\n",
       "            result = \" \".join(tc_line)\n",
       "            result = SUBPHRASE.sub(lambda m: '%s%s' % (m.group(1), m.group(2).capitalize()), result)\n",
       "            processed.append(result)\n",
       "        result = \"\\n\".join(processed).strip()\n",
       "        return result\n",
       "    \n",
       "    #### API / Pathes\n",
       "\n",
       "    global done_path, temp_save, added_path, get_movie_path, get_tvshow_path, get_season_path, get_episode_path, joinpath, skip_list, video_file_extensions, subtitlefile_extensions, today, thisyear, general_tracker_servers, add_trackers, download_types\n",
       "    done_path = \"/content/done\"\n",
       "    temp_save =\"/content/d-0\" \n",
       "    added_path = \"/content/added\"\n",
       "\n",
       "    if IS_ENV_COLAB:\n",
       "        os.makedirs(done_path, exist_ok= True)\n",
       "        os.makedirs(added_path, exist_ok= True) \n",
       "        os.makedirs(temp_save, exist_ok= True)\n",
       "\n",
       "    get_movie_path = lambda mv: config.movies_path + \"/\" + mv\n",
       "    get_tvshow_path = lambda tvshow: config.tv_path + \"/\" + tvshow\n",
       "    get_season_path = lambda tvshow, season: config.tv_path + \"/\" + tvshow + \"/\" + season\n",
       "    get_episode_path = lambda tvshow, season, eps: config.tv_path + \"/\" + tvshow + \"/\" + season + \"/\" + eps\n",
       "    joinpath = lambda start, dir: start + \"/\" + dir \n",
       "    os.path.join\n",
       "    #### API / Consts\n",
       "\n",
       "    skip_list = ['.txt','.inf','.info','.nfo','www.yts','rarbg_do_not', 'WWW.YIFY']\n",
       "    video_file_extensions = {\".mp4\", \".mkv\", \".ts\", \".mov\", \".webm\", '.avi', '.mts', '.wmv', '.m4v', '.3gp', '.flv'}\n",
       "    subtitlefile_extensions = {\".srt\", \".vtt\", \".sbv\", \".ssa\", \".dfxp\", \".ttml\", \".sup\", \".idx\"}\n",
       "\n",
       "    today = date.today()\n",
       "    thisyear = str(today.year)\n",
       "\n",
       "    general_tracker_servers = [\"udp://tracker.opentrackr.org:1337/announce\", \"udp://tracker.internetwarriors.net:1337/announce\", \"udp://exodus.desync.com:6969/announce\", \"udp://tracker.cyberia.is:6969/announce\", \"udp://3rt.tace.ru:60889/announce\", \"http://5rt.tace.ru:60889/announce\", \"udp://explodie.org:6969/announce\", \"udp://47.ip-51-68-199.eu:6969/announce\", \"udp://opentracker.i2p.rocks:6969/announce\", \"http://open.acgnxtracker.com:80/announce\", \"udp://www.torrent.eu.org:451/announce\", \"udp://tracker.torrent.eu.org:451/announce\", \"udp://tracker.tiny-vps.com:6969/announce\", \"udp://tracker.ds.is:6969/announce\", \"udp://retracker.lanta-net.ru:2710/announce\", \"udp://open.stealth.si:80/announce\", \"udp://tracker.moeking.me:6969/announce\", \"udp://ipv4.tracker.harry.lu:80/announce\", \"http://tracker.dler.org:6969/announce\", \"http://rt.tace.ru:80/announce\", \"udp://93.158.213.92:1337/announce\", \"udp://138.255.103.83:1337/announce\", \"udp://208.83.20.20:6969/announce\", \"udp://193.218.118.220:6969/announce\", \"udp://79.111.118.59:60889/announce\", \"http://93.157.234.32:60889/announce\", \"udp://184.105.151.164:6969/announce\", \"udp://51.68.199.47:6969/announce\", \"udp://51.81.46.170:6969/announce\", \"udp://91.216.110.52:451/announce\", \"udp://89.234.156.205:451/announce\", \"udp://5.206.60.196:6969/announce\", \"udp://5.226.148.20:6969/announce\", \"udp://37.235.174.46:2710/announce\", \"udp://185.181.60.67:80/announce\", \"udp://138.201.150.56:6969/announce\", \"udp://51.15.40.114:80/announce\", \"http://168.119.237.9:6969/announce\", \"http://195.201.31.194:80/announce\", \"https://trakx.herokuapp.com:443/announce\", \"https://w.wwwww.wtf:443/announce\", \"https://tracker.tamersunion.org:443/announce\", \"https://tracker.sloppyta.co:443/announce\", \"https://tracker.renfei.net:443/announce\", \"https://tracker.nitrix.me:443/announce\",\n",
       "                \"https://tracker.nanoha.org:443/announce\", \"https://tracker.lelux.fi:443/announce\", \"https://tracker.imgoingto.icu:443/announce\", \"https://tracker.hama3.net:443/announce\", \"https://tracker.foreverpirates.co:443/announce\", \"http://tracker2.wasabii.com.tw:6969/announce\", \"udp://tracker.sktorrent.net:6969/announce\", \"http://www.wareztorrent.com:80/announce\", \"udp://bt.xxx-tracker.com:2710/announce\", \"udp://tracker.eddie4.nl:6969/announce\", \"udp://tracker.grepler.com:6969/announce\", \"udp://tracker.mg64.net:2710/announce\", \"udp://wambo.club:1337/announce\", \"udp://tracker.dutchtracking.com:6969/announce\", \"udp://tc.animereactor.ru:8082/announce\", \"udp://tracker.justseed.it:1337/announce\", \"udp://tracker.leechers-paradise.org:6969/announce\", \"https://open.kickasstracker.com:443/announce\", \"udp://tracker.coppersurfer.tk:6969/announce\", \"http://87.253.152.137/announce\", \"http://91.216.110.47/announce\", \"http://91.217.91.21:3218/announce\", \"http://91.218.230.81:6969/announce\", \"http://93.92.64.5/announce\", \"http://atrack.pow7.com/announce\", \"http://bt.henbt.com:2710/announce\", \"http://bt.pusacg.org:8080/announce\", \"https://tracker.bt-hash.com:443/announce\", \"udp://tracker.leechers-paradise.org:6969\", \"https://182.176.139.129:6969/announce\", \"udp://zephir.monocul.us:6969/announce\", \"https://tracker.dutchtracking.com:80/announce\", \"https://grifon.info:80/announce\", \"udp://tracker.kicks-ass.net:80/announce\", \"udp://p4p.arenabg.com:1337/announce\", \"udp://tracker.aletorrenty.pl:2710/announce\", \"https://tracker.parrotsec.org:443/announce\", \"https://tracker.moxing.party:6969/announce\", \"https://tracker.ipv6tracker.ru:80/announce\", \"https://tracker.fastdownload.xyz:443/announce\", \"https://gwp2-v19.rinet.ru:80/announce\", \"https://tr.kxmp.cf:80/announce\", \"https://explodie.org:6969/announce\"]\n",
       "    \n",
       "    def add_trackers(handle):\n",
       "        for x in range(len(general_tracker_servers)):\n",
       "            annouce_entry = {'url': general_tracker_servers[x], 'tier': 2}\n",
       "            handle.add_tracker(annouce_entry) \n",
       "\n",
       "    global SUCCUSS, FAIL, X1337XPROXEY_BASE, X1337XPROXEY_BASE2, X1337X_BASE, X1337X_TV, X1337X_MOVIES, X1337X_APPS, X1337X_GAMES, X1337X_SEEDERS, X1337X_SIZE_ASC, X1337X_SIZE_DESC, X1337X_TIME_ASC, X1337X_TIME_DESC, IMDB_BASE, IMDB_MOVIE_TITLE, IMDB_TV_TITLE, IMDB_ANY_TITLE, IMDB_EXCULDE_MARK, REPLACE_DOWNLOAD, MERGE_DOWNLOAD, CANCEL_DOWNLOAD, RENAME_DOWNLOAD\n",
       "    SUCCUSS = 200\n",
       "    FAIL = 300\n",
       "\n",
       "    ## 1337x\n",
       "\n",
       "    X1337XPROXEY_BASE = 'https://www.1377x.to'\n",
       "    X1337XPROXEY_BASE2 = 'https://1337x.unblockit.esq'\n",
       "    X1337X_BASE = 'https://1337x.to'\n",
       "    X1337X_TV = \"TV\"\n",
       "    X1337X_MOVIES = \"Movies\"\n",
       "    X1337X_APPS = \"Apps\"\n",
       "    X1337X_GAMES = \"Games\"\n",
       "    X1337X_SEEDERS = \"seeders/desc\"\n",
       "    X1337X_SIZE_ASC = \"size/asc\"\n",
       "    X1337X_SIZE_DESC = \"size/desc\"\n",
       "    X1337X_TIME_ASC = \"time/asc\"\n",
       "    X1337X_TIME_DESC = \"time/desc\"\n",
       "\n",
       "    ## IMDB\n",
       "\n",
       "    IMDB_BASE = \"https://www.imdb.com\"\n",
       "    IMDB_MOVIE_TITLE = \"feature\"\n",
       "    IMDB_TV_TITLE = \"tv_series\"\n",
       "    IMDB_ANY_TITLE = \"\"\n",
       "    IMDB_EXCULDE_MARK=\"%21\"\n",
       "\n",
       "    #### API / abstraction \n",
       "\n",
       "    REPLACE_DOWNLOAD = 'REPLACE'\n",
       "    CANCEL_DOWNLOAD = 'CANCEL'\n",
       "    RENAME_DOWNLOAD = 'RENAME'\n",
       "\n",
       "    global parentheses_pt, trailing_punt_pt, title_pt, release_year_pt, video_version_pt, fileext_pt, class_pt, featurettes_pt, mf_pt, eps_pt, check_sn_pt, yearsuff_pt, langs_pt, digitssuff_pt, season_pt0, season_pt1, season_number_pt, sd_pt, imdbcount_pt, l337xpages_pt, stars_pt, director_pt, split_musictitle_pt\n",
       "    #url_pt = re.compile(r\"^((http[s]?):\\/\\/)?([^:\\/\\s]+)((\\/\\w+\\/)*\\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?\")\n",
       "    #sm_pt = re.compile(r\"(?<=Shareddrives\\/)[A-Z]*(?=\\/)\")\n",
       "    #sn2num_pt = re.compile(r\"[1-9][0-9]?(?=[Xx]\\d{1,2}\\b)\")\n",
       "    #eps2num_pt = re.compile(r\"(?<=\\d{1}[Xx])\\d{1,2}\\b\")\n",
       "    #skip_re = re.compile(r\"(.txt)|(.i?nfo?)|(www.yts)|(RARBG_DO_NOT|rarbg_do_not)\")\n",
       "    recent_decades_str = f\"\\(?19[0-9][0-9]\\)?|\\(?20[0-{int(thisyear[-2])-1}][0-9]\\)?|\\(?20[0-{thisyear[2]}][0-{thisyear[3]}]\\)?\"\n",
       "    parentheses_pt = re.compile(r\"[\\(\\){}]\")\n",
       "    trailing_punt_pt = re.compile(r\"^[.\\s)]+|[.\\s(]+$\")\n",
       "    title_pt = re.compile(fr\"^[0-9a-zA-Z\\s\\.:]+[\\s\\.]({recent_decades_str}).*$\")\n",
       "    release_year_pt = re.compile(fr\"(?<=[0-9a-zA\\(\\)][\\.\\s])({recent_decades_str})\")\n",
       "    video_version_pt = re.compile(r\"4[kK]|480[pP]|720[pP]|1080[pP]|2160[pP]|3[dD]\")\n",
       "    fileext_pt = re.compile(r\"\\.\\d?[a-zA-Z]{1,4}\\d?$\")\n",
       "    class_pt = re.compile(r\"(?<=<class ')([^']+)\")\n",
       "    featurettes_pt = re.compile(r\"([Ff]eaturettes?|[Ee]xtras?|[Dd]eleted)[0-9A-Za-z\\.\\s:]*\")\n",
       "    mf_pt = re.compile(r\"((?<=\\b[S,s])|(?<=[S,s]eason)|(?<=[S,s]eason[\\s,\\.]))([1-9][0-9]?|0?[1-9])\")\n",
       "    eps_pt = re.compile(r\"\\b([Ss]\\d{1,2}[Ee]\\d{1,2}|\\d{1,2}[xX]\\d{1,2}|[Ss]n?\\d{1,2}\\s?[Ee](ps?)?\\d{1,2})(?=[\\s\\.])\")\n",
       "    check_sn_pt = re.compile(r\"[\\s,\\.]([S,s]\\d{1,2}|[Ss][Ee][Aa][Ss][Oo][Nn]([\\s,\\.]?)\\d{1,2})(?=[\\s,\\.]|e\\d{1,2}-\\d{1,2})(?!\\sto)\")\n",
       "    yearsuff_pt = re.compile(r\"\\d{4}$\")\n",
       "    langs_pt = re.compile(r\"(?<=\\_|-|\\.|\\s)([Aa]rabic|ar|[Ee]nglish|en|[Ff]rench|fr|[Gg]erman|de|[Ff]innish|fi|[Dd]utch|nl|[Dd]anish|da|[Gg]reek|el|[Hh]indi|hi|[Ii]ndonesian|id|[Ii]talian|it|[Jj]apanese|ja|Korean|ko|Norwegian|no|Persian|fa|Polish|pl|Portuguese|pt|Russian|ru|Swedish|sv|Thai|th|Ukrainian|uk|Urdu|ur|Vietnamese|vi|spanish|es|Romanian|ro|Hungarian|hu)\", flags= re.IGNORECASE)\n",
       "    digitssuff_pt = re.compile(r\"\\s\\d{1,2}$\")\n",
       "    season_pt0 = re.compile(r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\")\n",
       "    season_pt1 = re.compile(r\"\\b([S,s]|[S,s]eason([\\s,\\.]?))\\d{1,2}\")\n",
       "    season_number_pt = re.compile(r\"([1-9][0-9]?)\")\n",
       "    sd_pt = re.compile(r\"(\\/content\\/drive\\/Shareddrives\\/)[A-Za-z0-9]+(?=\\/)\")\n",
       "    imdbcount_pt = re.compile(r\"\\d+(?=\\stitles?)\")\n",
       "    l337xpages_pt = re.compile(r\"(?<=/)\\d+(?=/)\")\n",
       "    stars_pt = re.compile(r\"(?<=Stars:)<a href.*</a>\")\n",
       "    director_pt = re.compile(r\"(((?<=Director:)<a href.*</a>)|((?<=Directors:)<a href.*</a>))(?=<span)\")\n",
       "    split_musictitle_pt = re.compile(r\"[\\[\\]\\(]\")\n",
       "\n",
       "    global gethtmltext, getcssblinkanimation, getloadingview, getattrstr, dump, list_lines, pathsize, compare_files_with_size, is_hidden, filter_checks, print_files, data_str, speed_str, RoundTo1, is_empty, startswith\n",
       "\n",
       "    def gethtmltext(text, tag= \"span\", elid=\"\", elclass= \"\", fontsize= \"18px\", style= \"\", color= ACCENT_COLOR, animated= False):\n",
       "        if not elid:\n",
       "            elid = 'el' + rand()\n",
       "        colorstyle = f\"color: {color};\" if color != ACCENT_COLOR else '' # TODO support dark mode\n",
       "        animation = getcssblinkanimation(color= color, elementid= elid) if animated else ''\n",
       "        return f'<{tag} id=\"{elid}\" class=\"{elclass}\" style=\"font-size: {fontsize}; {style}\">{text}</{tag}>{animation}'\n",
       "\n",
       "    def getcssblinkanimation(color, elementid = \"\", elementclass = \"\"):\n",
       "        if not elementclass and not elementid:\n",
       "            return None\n",
       "        shadecolor = color[:-2] + '2c' if len(color) == 9 else color + '2c'\n",
       "        styletag = '<style>'\n",
       "        idpart = f'#{elementid}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementid else \"\"\n",
       "        animationpart = f' @keyframes color-change {{ 0% {{ color: {color}; }} 50% {{ color: {shadecolor}; }} 100% {{ color: {color} ; }} }}</style>'\n",
       "        classpart = f'.{elementclass}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementclass else \"\"\n",
       "        return styletag + idpart + classpart + animationpart\n",
       "\n",
       "    def getloadingview(text):\n",
       "        elid= 'el-' + rand()\n",
       "        t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
       "        spinnerhtml = \"<div class=loadingio-spinner-spinner-m4dbaxm5cdf><div class=ldio-orkmsj9nbq><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><style>@keyframes ldio-orkmsj9nbq{0%{opacity:1}100%{opacity:0}}.ldio-orkmsj9nbq div{left:47px;top:16px;position:absolute;animation:ldio-orkmsj9nbq linear 1.1111111111111112s infinite;background:#184cad;width:6px;height:12px;border-radius:2.16px;transform-origin:3px 34px}.ldio-orkmsj9nbq div:first-child{transform:rotate(0);animation-delay:-1.0185185185185184s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(2){transform:rotate(30deg);animation-delay:-.9259259259259258s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(3){transform:rotate(60deg);animation-delay:-.8333333333333333s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(4){transform:rotate(90deg);animation-delay:-.7407407407407407s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(5){transform:rotate(120deg);animation-delay:-.6481481481481481s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(6){transform:rotate(150deg);animation-delay:-.5555555555555555s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(7){transform:rotate(180deg);animation-delay:-.4629629629629629s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(8){transform:rotate(210deg);animation-delay:-370.3703703703703ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(9){transform:rotate(240deg);animation-delay:-277.7777777777777ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(10){transform:rotate(270deg);animation-delay:-.18518518518518517s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(11){transform:rotate(300deg);animation-delay:-92.59259259259258ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(12){transform:rotate(330deg);animation-delay:0s;background:#184cad}.loadingio-spinner-spinner-m4dbaxm5cdf{width:100px;height:100px;display:inline-block;overflow:hidden;background:0 0}.ldio-orkmsj9nbq{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-orkmsj9nbq div{box-sizing:content-box}</style>\"\n",
       "        loading_container = f'<div style=\"height:{MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text + \" \", elid= elid, style= t1style, fontsize= \"32px\")} {spinnerhtml}</div>' + getcssblinkanimation(color= ACCENT_COLOR, elementid=elid)\n",
       "        loadingview = HTML(loading_container)\n",
       "        loadingview.name = \"Loading\"\n",
       "        return loadingview\n",
       "\n",
       "    ## Init / utils\n",
       "\n",
       "    def getattrstr(obj, filter = True, filter_empty = False, add_line = False):\n",
       "        attrstr = ''\n",
       "        pre = '\\n' if add_line else ', '\n",
       "        i = True\n",
       "        for attrs in dir(obj):\n",
       "            if filter and attrs.startswith(\"__\"):\n",
       "                continue\n",
       "            val = getattr(obj, attrs)\n",
       "            if filter_empty and not val:\n",
       "                continue\n",
       "            if i :\n",
       "                attrstr += \"%s =  %r\" % (attrs, val)\n",
       "                i = False\n",
       "            else:\n",
       "                attrstr += \"%s%s =  %r\" % (pre, attrs, getattr(obj, attrs))\n",
       "        return attrstr\n",
       "\n",
       "    def dump(obj, filterprefixed = True, getvalues= True, gettypes= False, types= set(), filtertypes= set()):\n",
       "        output = ''\n",
       "        i = 0\n",
       "        if isinstance(obj, dict):\n",
       "            iterables = dict()\n",
       "            for key in obj.keys():\n",
       "                val = obj[key]\n",
       "                if (not type(val) == str) and isinstance(val, Iterable):\n",
       "                    iterables[key] = val \n",
       "                    continue\n",
       "                val = str(val)\n",
       "                output += f\"{key:>25}:    {val:<50}\\n\"\n",
       "                i += 1\n",
       "            if iterables:\n",
       "                output += f\"\\n   {(' ' * 25).join(iterables)}\\n\"\n",
       "                check = True\n",
       "                while check:\n",
       "                    output = ''\n",
       "                    check = False\n",
       "                    for key in iterables:\n",
       "                        iter = iterables[key]\n",
       "                        if i < len(iter):\n",
       "                            check = True\n",
       "                            val = f\"{i:>3}  {iter[i]}\"\n",
       "                        else:\n",
       "                            val = ''\n",
       "                        output += f\"{val:<35}\"\n",
       "                    i += 1  \n",
       "\n",
       "        elif isinstance(obj, Iterable):\n",
       "            for item in obj:\n",
       "                val = str(item)\n",
       "                output += f\"{i:>3}  {val:<35}\\n\"\n",
       "                i += 1\n",
       "\n",
       "        elif isinstance(obj, object):\n",
       "            attrs = dir(obj)\n",
       "            attrs.sort()\n",
       "            for attrname in attrs:\n",
       "                try:\n",
       "                    attrval = getattr(obj, attrname)\n",
       "                    type1 = type(attrval)\n",
       "                    typestr = class_pt.search(str(type1)).group()\n",
       "                    if (filterprefixed and attrname.startswith(\"_\")) or (types and not type1 in types) or (filtertypes and (type1 in filtertypes)):\n",
       "                        continue\n",
       "                except:\n",
       "                    attrval = \"couldn't get value.\"\n",
       "                if getvalues:\n",
       "                    val = str(attrval)\n",
       "                    val = f\"   {val:<45}\"\n",
       "                else:\n",
       "                    val = ''\n",
       "                typestr = f'   {typestr:<30}' if gettypes else ''\n",
       "                name = f\"{attrname:>25}\"\n",
       "                out = name + typestr + val + '\\n'\n",
       "                output += out\n",
       "                i += 1\n",
       "        print(output)\n",
       "\n",
       "    def list_lines(lines, str = False):\n",
       "        if lines:\n",
       "            if str:\n",
       "                rtn = ''\n",
       "                for r in lines:\n",
       "                    if r:\n",
       "                        rtn += (r +'\\n')\n",
       "                return rtn\n",
       "            if not str:  \n",
       "                for line in lines:\n",
       "                    print(line)\n",
       "\n",
       "    def pathsize(path, string = False):\n",
       "        size = 0\n",
       "        if not os.path.exists(path):\n",
       "            return 0\n",
       "        if os.path.isfile(path):\n",
       "            size = os.path.getsize(path)\n",
       "        else:  \n",
       "            for path, dirs, files in os.walk(path):\n",
       "                for f in files:\n",
       "                    fp = os.path.join(path, f)\n",
       "                    size += os.path.getsize(fp)\n",
       "        if string:\n",
       "            return data_str(size)\n",
       "        else:\n",
       "            return size\n",
       "\n",
       "    def compare_files_with_size(file1, file2):\n",
       "        if not (os.path.isfile(file1) and os.path.isfile(file2)):\n",
       "            return False\n",
       "        return os.path.getsize(file1) == os.path.getsize(file2)\n",
       "\n",
       "    def is_hidden(path):\n",
       "        return True if path[0] == '.' else False\n",
       "\n",
       "    def filter_checks(dirs):\n",
       "        for dir in dirs:\n",
       "            if dir.endswith('ipynb_checkpoints'):\n",
       "                dirs.remove(dir)\n",
       "        return dirs\n",
       "\n",
       "    def print_files(drs, range_start , range_end):\n",
       "        for i in range(range_start, range_end):\n",
       "            print(\"   {0}-  {1}\".format(i+1, drs[i])) \n",
       "\n",
       "    def data_str(byte_val):\n",
       "        size = ByteToGB(byte_val)\n",
       "        if (size >= 1):\n",
       "            return \"{:.1f} GB\".format(size)\n",
       "        size = ByteToMB(byte_val)\n",
       "        if (size >= 1):\n",
       "            return \"{:.1f} MB\".format(size)\n",
       "        size = ByteToKB(byte_val)\n",
       "        if (size >= 1):\n",
       "            return \"{:.1f} KB\".format(size)\n",
       "        return \"{:.1f} B\".format(size)\n",
       "\n",
       "    def speed_str(byte_val):\n",
       "        size_mb = ByteToMB(byte_val)\n",
       "        if (size_mb >= 1):\n",
       "            return \"{:.1f} MB\".format(size_mb)\n",
       "        else:\n",
       "            return \"{:.1f} KB\".format(ByteToKB(byte_val))\n",
       "        \n",
       "    def RoundTo1(n) :\n",
       "        if n < 1 and (n - 0.9765625) >= 0 :\n",
       "            return 1\n",
       "        else: \n",
       "            return n\n",
       "\n",
       "    def is_empty(path):  \n",
       "        if os.path.isdir(path):\n",
       "            dircontent = os.listdir(path)\n",
       "            if len(dircontent) == 0 or (len(dircontent) == 1 and contains(checkpoint, dircontent[0])):\n",
       "                return True      \n",
       "        return False\n",
       "\n",
       "    def startswith(a: str, b: str):\n",
       "        a = a.strip()\n",
       "        b = b.strip()\n",
       "        if len(a) >= len(b):\n",
       "            a1 = a\n",
       "            b1 = b\n",
       "        else:\n",
       "            a1 = b\n",
       "            b1 = a\n",
       "        if a1.startswith(b1):\n",
       "            return True\n",
       "        return b1.startswith(a1) \n",
       "\n",
       "    global contains, time_str, ByteToGB, ByteToMB, ByteToKB, getresultpagekey, resetapp, restart, list_trackers, load_download, edit_torrent_settings, clear_temp_pathes\n",
       "\n",
       "    contains = lambda string, search: search.lower() in string.lower()\n",
       "    time_str = lambda sec: time.strftime('%H:%M:%S', time.gmtime(sec))\n",
       "    ByteToGB = lambda n: RoundTo1(n / 1073741824)\n",
       "    ByteToMB = lambda n: RoundTo1(n / 1048576)\n",
       "    ByteToKB = lambda n: RoundTo1(n / 1024)\n",
       "    getresultpagekey = lambda sort, order, page: f\"{sort}|{order}|{page}\"\n",
       "\n",
       "    ## Utils\n",
       "\n",
       "    def resetapp(delfiles= False):\n",
       "        if active:\n",
       "            for i in range(len(active)): \n",
       "                ses.remove_torrent(active[i])\n",
       "            active.clear()\n",
       "        if downloads_dict:\n",
       "            downloads_dict.clear()\n",
       "        if completed:\n",
       "            completed.clear()\n",
       "        monitoractivedownload_views.clear()\n",
       "        monitordownloadscontainer_vbox.children = ()\n",
       "        appstate.total_downloads = 0\n",
       "        appstate.completed = 0\n",
       "        appstate.deads = 0\n",
       "        appstate.total_progress = 0\n",
       "        appstate.total_wanted = 0\n",
       "        appstate.running = False\n",
       "        update_download_stats_labels()\n",
       "        if delfiles:\n",
       "            !rm -r '/content/d-0/'*\n",
       "\n",
       "    def restart():\n",
       "        if IS_ENV_COLAB:\n",
       "            unmount()\n",
       "            get_ipython: None\n",
       "            get_ipython().kernel.do_shutdown(True)\n",
       "\n",
       "    def list_trackers():\n",
       "        handle = active[-1]\n",
       "        trackers = handle.trackers()\n",
       "        print(\"Trackers count \", len(trackers))\n",
       "        for x in trackers:\n",
       "            #print(x)\n",
       "            print(x['url'], x['tier'])\n",
       "\n",
       "    def load_download(Load_From):\n",
       "        Local = False   \n",
       "        Type = MOVIE  \n",
       "        Category = MOVIESCATEGORY_TD  \n",
       "        Sort = \"By Seeders\"   \n",
       "        Order = \"Descending\"  \n",
       "        Backup = True  \n",
       "        sort = TIMESORT\n",
       "        if Sort == TIMESORT:\n",
       "            if Order == \"Descending\":\n",
       "                sort = X1337X_TIME_DESC\n",
       "            else:\n",
       "                sort = X1337X_TIME_ASC\n",
       "        elif Sort == \"By Size\":\n",
       "            if Order == \"Descending\":\n",
       "                sort = X1337X_SIZE_DESC\n",
       "            else:\n",
       "                sort = X1337X_SIZE_ASC\n",
       "        try:\n",
       "            if Load_From:\n",
       "                load_uncompleted(Load_From, type_ = MOVIE)\n",
       "            elif Local:\n",
       "                load_uncompleted(temp_save, type_ = MOVIE, local = True) \n",
       "            logger.release()\n",
       "        except KeyboardInterrupt as k:\n",
       "            k\n",
       "\n",
       "    def edit_torrent_settings():\n",
       "        Announce_To_All_Tiers = True \n",
       "        Announce_To_All_Trackers = True \n",
       "        Active_Limit = 5  \n",
       "        config.activedownloads = 3  \n",
       "        Active_Seeds = 1 \n",
       "        Active_Checking = 3  \n",
       "        Connections_Limit = 2330 \n",
       "        Connection_Speed = 80 \n",
       "        Connections_Slack = 50 \n",
       "        File_Pool_Size = 20 \n",
       "        Half_Open_Limit = 100 \n",
       "        Max_Rejects = 8 \n",
       "        Max_Peerlist_Size = 5000 \n",
       "        Max_Paused_Peerlist_Size = 2000 \n",
       "        Max_Failcount = 3 \n",
       "        Min_Announce_Interval = 30 \n",
       "        Min_Reconnect_Time = 20 \n",
       "        Request_Timeout = 10 \n",
       "        Smooth_Connects = False \n",
       "        Send_Buffer_Watermark_MB = 5  \n",
       "        Seed_Time_Limit = 60 \n",
       "        Tracker_Completion_Timeout = 30 \n",
       "        Upload_Rate_Limit_KB = 0  \n",
       "        User_Agent = '\"Utorrent\"/3.5.5' \n",
       "\n",
       "        sett = {\n",
       "            'allow_multiple_connections_per_ip': True,\n",
       "            'active_downloads': config.activedownloads,\n",
       "            'active_seeds':Active_Seeds,\n",
       "            'active_checking': Active_Checking,\n",
       "            'active_limit':Active_Limit,\n",
       "            'active_seeds':Active_Seeds,    \n",
       "            'announce_to_all_tiers': Announce_To_All_Tiers,\n",
       "            'announce_to_all_trackers':Announce_To_All_Trackers,\n",
       "            'allow_multiple_connections_per_ip':True,\n",
       "            'auto_sequential':True,\n",
       "            'auto_manage_interval': 30,\n",
       "            'connections_limit':Connections_Limit,\n",
       "            'connection_speed': Connection_Speed,\n",
       "            'connections_slack':Connections_Slack,\n",
       "            'close_redundant_connections':True,\n",
       "            'file_pool_size':File_Pool_Size,\n",
       "            'local_service_announce_interval':200,\n",
       "            'max_rejects':Max_Rejects,\n",
       "            'max_peerlist_size': Max_Peerlist_Size,\n",
       "            'max_paused_peerlist_size': Max_Paused_Peerlist_Size,\n",
       "            'max_failcount':Max_Failcount,\n",
       "            'min_announce_interval':Min_Announce_Interval,\n",
       "            'min_reconnect_time': Min_Reconnect_Time,\n",
       "            'peer_timeout':20,\n",
       "            'request_timeout':Request_Timeout,\n",
       "            'half_open_limit': Half_Open_Limit,\n",
       "            'send_buffer_watermark':Send_Buffer_Watermark_MB*1024*1024,\n",
       "            'smooth_connects':Smooth_Connects,\n",
       "            'strict_end_game_mode':True,\n",
       "            'seed_time_limit': Seed_Time_Limit,\n",
       "            'tracker_completion_timeout':Tracker_Completion_Timeout,\n",
       "            'upload_rate_limit':Upload_Rate_Limit_KB*1024,\n",
       "            'user_agent': User_Agent,\n",
       "            #'inactivity_timeout':20,  \n",
       "            #'ban_web_seeds':False   \n",
       "            }\n",
       "        ses.apply_settings(sett)    \n",
       "        settings = ses.get_settings()\n",
       "        setn =[]\n",
       "        for x in settings:\n",
       "            setn.append(str(x))\n",
       "        setn.sort() \n",
       "\n",
       "    def clear_temp_pathes():\n",
       "        Delete_torrent_files = True \n",
       "        Clear_done_folder = True  \n",
       "        Clear_temp_folder = False  \n",
       "        if Delete_torrent_files:\n",
       "            !find . -maxdepth 1 -name \"*.torrent\" -type f -delete \n",
       "        if Clear_done_folder:  \n",
       "            !rm -r \"$done_path/\"* \n",
       "        if Clear_temp_folder:\n",
       "            !rm -r \"$temp_save/\"* \n",
       "        logger.release()   \n",
       "\n",
       "    global transstring, transtitle, get_release_year, get_season, strip, transform_dotted_name, remove_ext, is_title_name, is_extras_dir, name_movie, name_show, name_episode, movie_exists, show_exists, season_exists, episode_exists, check_download, get_movie_file_path\n",
       "    \n",
       "    ## API / Download library management\n",
       "                \n",
       "    def transstring(name): \n",
       "        if not name:\n",
       "            logger.error('String is empty.')\n",
       "            raise Exception('String is empty.')\n",
       "        table = name.maketrans(\"\",\"\",\" ,.;:!?'&#$%`!@^*_-/\\\\|'\\\"<>())[]{}\")\n",
       "        return name.translate(table).lower()\n",
       "\n",
       "    def transtitle(name): \n",
       "        if not name:\n",
       "            logger.error('Name is empty.')\n",
       "            raise Exception('Trans title,name is empty.')\n",
       "        name = name.replace(\"&\",\"and\")\n",
       "        table = name.maketrans(\"\",\"\",\" '(#$%-,.;:!?)\")\n",
       "        return name.translate(table).lower()       # if not show else name.translate(table).lower()\n",
       "\n",
       "    def get_release_year(name): \n",
       "        releaseyear_search = release_year_pt.findall(name)\n",
       "        if releaseyear_search:\n",
       "            return parentheses_pt.sub(\"\", releaseyear_search[-1])\n",
       "        return \"\"\n",
       "\n",
       "    def get_season(name, allow_year = True):\n",
       "        logger.info(f'Retrieving season from: {name}')\n",
       "        lookup = mf_pt.search(name)\n",
       "        if lookup:\n",
       "            season_str = f'S{int(lookup.group()):02}'\n",
       "            logger.info(f'Found season: {season_str}')\n",
       "            return season_str\n",
       "\n",
       "        lookup = featurettes_pt.search(name)\n",
       "        if lookup:\n",
       "            extras = lookup.group()\n",
       "            logger.info(f'Extra folder: {extras}')\n",
       "            return \"Extras\"\n",
       "\n",
       "        year = get_release_year(name)\n",
       "        if allow_year and year:  \n",
       "            logger.info(f'Season retrieved as a year: {year}')\n",
       "            return year\n",
       "        else:\n",
       "            logger.info(f'No season was retrieved.')\n",
       "            return ''\n",
       "\n",
       "    def strip(string):\n",
       "        return trailing_punt_pt.sub(\"\", string)\n",
       "\n",
       "    def transform_dotted_name(name):\n",
       "        table = name.maketrans({\".\": \" \"})\n",
       "        return name.translate(table).strip()\n",
       "    \n",
       "    remove_ext = lambda string: fileext_pt.sub(\"\", string)\n",
       "\n",
       "    def name_movie(name, include_quality= False):\n",
       "        qualities = video_version_pt.findall(name)\n",
       "        name = video_version_pt.split(name)[0]\n",
       "        transformed_name = transform_dotted_name(name)\n",
       "        qualities_str = \" \" + \" \".join(qualities) if qualities and include_quality else \"\"\n",
       "        releaseyear_search = release_year_pt.findall(transformed_name)\n",
       "        if releaseyear_search:\n",
       "            res = f\"{strip(transformed_name.split(releaseyear_search[-1])[0])} {get_release_year(transformed_name)}{qualities_str}\"\n",
       "        else:\n",
       "            res = strip(transformed_name) + qualities_str\n",
       "        return title(res)\n",
       "\n",
       "    def name_show(name): \n",
       "        name = video_version_pt.split(name)[0]  \n",
       "        transformed_name = transform_dotted_name(name)\n",
       "        releaseyear_search = release_year_pt.findall(transformed_name)\n",
       "        if releaseyear_search: \n",
       "            newname = f\"{strip(transformed_name.split(releaseyear_search[-1])[0])} {get_release_year(transformed_name)}\"\n",
       "        else:\n",
       "            season_search = season_pt1.search(transformed_name)\n",
       "            if season_search: \n",
       "                newname = strip(transformed_name.split(season_search.group())[0])\n",
       "            else: \n",
       "                newname = strip(transformed_name)\n",
       "        return title(newname)\n",
       "\n",
       "    def name_episode(name):\n",
       "        name = video_version_pt.split(name)[0]  \n",
       "        transformed_name = transform_dotted_name(name)     # Don't split by year, because episode file name includes season and episode numbers, and possibly episode title.\n",
       "        releaseyear_search = release_year_pt.findall(transformed_name)\n",
       "        if releaseyear_search:\n",
       "            year = get_release_year(transformed_name)\n",
       "            transformed_name = strip(transformed_name.replace(releaseyear_search[-1], year))\n",
       "        return title(transformed_name)\n",
       "\n",
       "    def is_title_name(string):\n",
       "        return True if title_pt.search(string) else False\n",
       "    \n",
       "    def is_extras_dir(string):\n",
       "        return True if featurettes_pt.search(string) else False\n",
       "        \n",
       "    def movie_exists(name):\n",
       "        if not name.strip():\n",
       "            logger.error('Movie name is empty')\n",
       "            raise(\"Given movie name is empty.\")           \n",
       "        logger.info(f\"Checking if the movie {name} is downloaded.\")\n",
       "        try:\n",
       "            movies_raw = filter_checks(next(os.walk(config.movies_path))[1])\n",
       "        except:\n",
       "            return False\n",
       "        translated_title_check = transtitle(name)\n",
       "        result = {'type': 'movie', \"foundname\": \"\", \"foundpath\": \"\", \"foundshow\": \"\", 'foundfile': \"\", \"founddir\": \"\"}\n",
       "        for i in range(len(movies_raw)):\n",
       "            targetname = movies_raw[i]\n",
       "            targetpath = get_movie_path(movies_raw[i])\n",
       "            translated_current_title = transtitle(movies_raw[i])\n",
       "            if contains(translated_title_check, translated_current_title):\n",
       "                foundfile = get_movie_file_path(targetpath, targetname)\n",
       "                if foundfile:\n",
       "                    logger.info(f\"Found {name} as {targetname}\")\n",
       "                    result[\"foundname\"] = targetname\n",
       "                    result[\"foundpath\"] = targetpath\n",
       "                    result[\"foundshow\"] = \"\"\n",
       "                    result[\"foundfile\"] = foundfile\n",
       "                    result[\"founddir\"] = config.movies_path\n",
       "                    break\n",
       "        if not result[\"foundpath\"]:\n",
       "            logger.info(f\"{name} is not found\")\n",
       "        return result\n",
       "\n",
       "    def show_exists(searchshow: str):\n",
       "        if not searchshow.strip():\n",
       "            logger.error('Show name is empty')\n",
       "            return\n",
       "        logger.info(f\"Checking if the show {searchshow} is downloaded\")\n",
       "        try:\n",
       "            shows_raw = filter_checks(next(os.walk(config.tv_path))[1])\n",
       "        except:\n",
       "            return False\n",
       "        name_trans = transtitle(searchshow)\n",
       "        result = {'type': 'TV show', \"foundname\": \"\", \"foundpath\": \"\", \"foundshow\": \"\", 'foundfile': \"\", \"founddir\": \"\"}\n",
       "        for i in range(len(shows_raw)):\n",
       "            targetpath = get_tvshow_path(shows_raw[i])\n",
       "            targetname = shows_raw[i]\n",
       "            trans1 = transtitle(shows_raw[i])\n",
       "            if startswith(trans1, name_trans) and not is_empty(targetpath):\n",
       "                logger.info(f\"{searchshow} is downloaded as {targetname}\")\n",
       "                result[\"foundname\"] = targetname\n",
       "                result[\"foundpath\"] = targetpath\n",
       "                result[\"foundshow\"] = targetname\n",
       "                result[\"foundfile\"] = ''\n",
       "                result[\"founddir\"] = config.tv_path\n",
       "                break\n",
       "        if not result[\"foundpath\"]:\n",
       "            logger.info(f\"{searchshow} is not found.\")\n",
       "        return result\n",
       "\n",
       "    def season_exists(foundshow, searchseason):\n",
       "        if not searchseason.strip():\n",
       "            logger.error('Season name is empty')\n",
       "            return\n",
       "        if not foundshow.strip():\n",
       "            logger.error('Show name is empty')\n",
       "            return\n",
       "        logger.info(f\"Checking if the season {searchseason} of {foundshow} is downloaded\")\n",
       "        showsearch = show_exists(foundshow)\n",
       "        targetpath = \"\"\n",
       "        result = {'type': 'TV season', \"foundname\": \"\", \"foundpath\": \"\", \"foundshow\": \"\", 'foundfile': \"\", \"founddir\": \"\"}\n",
       "        if showsearch['foundpath']:\n",
       "            foundshow = showsearch['foundname']\n",
       "            result[\"foundshow\"] = foundshow\n",
       "            showpath = get_tvshow_path(foundshow)\n",
       "            targetpath = get_season_path(foundshow, searchseason)\n",
       "            if os.path.exists(targetpath) and not is_empty(targetpath):\n",
       "                logger.info(f\"Season {searchseason} of {foundshow} is downloaded\")\n",
       "                result[\"foundname\"] = searchseason\n",
       "                result[\"foundpath\"] = targetpath\n",
       "                result[\"foundfile\"] = targetpath\n",
       "                result[\"founddir\"] = showpath\n",
       "            else:\n",
       "                logger.info(f\"Season {searchseason} of {foundshow} is not downloaded\")\n",
       "        return result\n",
       "\n",
       "    def episode_exists(foundshow, season, searchepisode): \n",
       "        logger.info(f\"Checking if the episode: {searchepisode} is downloaded\")\n",
       "        showsearch = show_exists(foundshow)\n",
       "        targetepisode = \"\"\n",
       "        targetpath= \"\"\n",
       "        result = {'type': 'TV episode', \"foundname\": \"\", \"foundpath\": \"\", \"foundshow\": \"\", 'foundfile': \"\", \"founddir\": \"\"}\n",
       "        if showsearch['foundpath']:\n",
       "            foundshow = showsearch['foundname']\n",
       "            result[\"foundshow\"] = foundshow\n",
       "            seasonpath = get_season_path(foundshow, season)\n",
       "            if os.path.exists(seasonpath) and not is_empty(seasonpath):\n",
       "                check = eps_pt.search(searchepisode)                    #rerite search algorithm\n",
       "                eps = check.group() if check else searchepisode\n",
       "                epses = next(os.walk(seasonpath))[2]\n",
       "                for targetepisode in epses:\n",
       "                    splt = os.path.splitext(targetepisode)\n",
       "                    if splt[1] in video_file_extensions: \n",
       "                        if contains(splt[0], eps):\n",
       "                            targetpath = get_episode_path(foundshow, season, targetepisode)\n",
       "                            logger.info(f\"Episode: {searchepisode} is downloaded as {targetpath}\")\n",
       "                            result[\"foundname\"] = targetepisode\n",
       "                            result[\"foundpath\"] = targetpath\n",
       "                            result[\"foundfile\"] = targetpath\n",
       "                            result[\"founddir\"] = seasonpath\n",
       "                            break\n",
       "        if not result[\"foundpath\"]:\n",
       "            logger.info(f\"Episode: {searchepisode} is not downloaded.\")\n",
       "        return result\n",
       "\n",
       "    def check_download(type_, name):\n",
       "        if type_ == MOVIE:\n",
       "            name = name_movie(name)\n",
       "            return movie_exists(name)\n",
       "        if type_ == SHOW:\n",
       "            name = name_show(name)\n",
       "            return show_exists(name)\n",
       "\n",
       "    def get_movie_file_path(path, name):\n",
       "        if path and os.path.exists(path):\n",
       "            files = next(os.walk(path))[2]\n",
       "            for file in files:\n",
       "                splt = os.path.splitext(file)\n",
       "                ext = splt[1]\n",
       "                title: str = splt[0].lower()\n",
       "                if (ext in video_file_extensions) and name.lower().startswith(title):\n",
       "                    return path + \"/\" + file\n",
       "        return \"\"\n",
       "\n",
       "    global replace_download, get_tv_type, music_title, get_season_backup_pathes, get_episode_backup_pathes, after_shave_movie, clean_download, shave_download, clean_movie, clean_tvshows, clean_tvshow, clean_season, process_external_link\n",
       "\n",
       "    def replace_download(path):\n",
       "        if path and os.path.exists(path):\n",
       "            parent = os.path.dirname(path)\n",
       "            rp = parent + \"/\" + \".replace\"\n",
       "            os.makedirs(rp, exist_ok=True)\n",
       "            !mv \"$path\" \"$rp\"\n",
       "\n",
       "    def get_tv_type(attrs):\n",
       "        search = eps_pt.search(attrs.name)\n",
       "        if search:\n",
       "            return EPISODE\n",
       "        search = check_sn_pt.search(attrs.name)\n",
       "        if search:\n",
       "            return SEASON  \n",
       "        \n",
       "    def music_title(name: str):\n",
       "        search = split_musictitle_pt.search(name)\n",
       "        if search:\n",
       "            name = name.split(search.group())[0]\n",
       "        splt = name.split(\"-\")\n",
       "        if splt:\n",
       "            artist = splt[0].strip() \n",
       "            name = splt[1].strip()\n",
       "            title = f\"{artist} - {name}\"\n",
       "        else:\n",
       "            artist = \"\"\n",
       "            name = title = name.strip()\n",
       "        return (artist, name, title)\n",
       "\n",
       "    # backup\n",
       "\n",
       "    def get_season_backup_pathes(show):\n",
       "        backuppathes = set()\n",
       "        for item in config.tvbackups:\n",
       "            pt1 = joinpath(item, show)\n",
       "            backuppathes.add(pt1)\n",
       "            os.makedirs(pt1, exist_ok=True)\n",
       "        return backuppathes\n",
       "\n",
       "    def get_episode_backup_pathes(show, season):\n",
       "        itemdir = f\"{show}/{season}\"\n",
       "        backuppathes = set()\n",
       "        for item in config.tvbackups:\n",
       "            pt1 = joinpath(item, itemdir)\n",
       "            backuppathes.add(pt1)\n",
       "            os.makedirs(pt1, exist_ok=True) \n",
       "        return backuppathes\n",
       "\n",
       "    ## API / After Download Operations \n",
       "\n",
       "    def shave_download(handle, path, maindir):\n",
       "        '''Deletes all files unselected by the user, or by the filtered download files and empty dirs'''\n",
       "        tf = handle.torrent_file()\n",
       "        files = tf.files()\n",
       "        priorities = handle.get_file_priorities()\n",
       "        cmd = ''\n",
       "        for i in range(files.num_files()):              # Delete files if they are not selected\n",
       "            file_path = path + \"/\" + files.file_path(i)\n",
       "            if os.path.isfile(file_path) and priorities[i] == 0:\n",
       "                cmd = f'rm \"{file_path}\"'\n",
       "                !$cmd\n",
       "                dirpath = os.path.dirname(file_path)\n",
       "                if is_empty(dirpath):\n",
       "                    cmd = f'rm -r \"{dirpath}\"'\n",
       "                    !$cmd                               # Delete empty dirs\n",
       "        if os.path.isdir(maindir):\n",
       "            dircontent = next(os.walk(maindir))[1]\n",
       "            for path in dircontent:                     \n",
       "                if is_empty(path):\n",
       "                    cmd = f'rm -r \"{path}\"'\n",
       "                    !$cmd\n",
       "\n",
       "    def clean_download(attrs, localsavingpath):\n",
       "        '''Scans downloaded files and rename them based on download type.'''\n",
       "        logger.info(f\"Cleaning type: {download_types[attrs.type_]} name: {attrs.name}\")\n",
       "        attrs.downloaded_diritems = []\n",
       "        if attrs.type_ == MOVIE:\n",
       "            after_shave_movie(localsavingpath, attrs.save_name, renamed_title= attrs.renamed_file,\n",
       "                                selectedfilenames= attrs.selectedfilenames, downloaded_diritems= attrs.downloaded_diritems)\n",
       "        elif attrs.type_ == SHOW:\n",
       "            clean_tvshow(localsavingpath, diritems= attrs.downloaded_diritems)\n",
       "        elif attrs.type_ == SEASON or attrs.type_ == EPISODE:\n",
       "            diritem =  ('', clean_season(localsavingpath))\n",
       "            attrs.downloaded_diritems.append(diritem)\n",
       "        return True\n",
       "\n",
       "    def after_shave_movie(localsavingpath, newname, renamed_title= \"\", selectedfilenames= [], downloaded_diritems = []):\n",
       "        if not renamed_title: renamed_title = newname\n",
       "        if not os.path.isdir(localsavingpath):\n",
       "            raise(Exception(f\"Path isn't a dir: {localsavingpath}\\nExists: {os.path.exists(localsavingpath)}\"))\n",
       "        maindircontent = next(os.walk(localsavingpath))                                 \n",
       "        originaldiritems = [('', maindircontent[2], MOVIE)]\n",
       "        for dirname in maindircontent[1]:\n",
       "            foundpath = f\"{localsavingpath}/{dirname}\"\n",
       "            logger.info(f\"Checking dir at {foundpath}\")\n",
       "            if is_title_name(dirname):\n",
       "                logger.info(f\"Directory type: Movie title.\")\n",
       "                newdirname = name_movie(dirname)\n",
       "                newdirpath = f\"{localsavingpath}/{newdirname}\"\n",
       "                file_command(\"mv\", foundpath, newdirpath, log_message= f\"Renaming dir to a movie title: {dirname} to {newdirname}.\")\n",
       "                dirname = newdirname\n",
       "                foundpath = newdirpath\n",
       "                dirtype = MOVIE\n",
       "            elif dirname.lower().startswith(\"sub\"):\n",
       "                logger.info(f\"Directory type: Subtitle dir.\")\n",
       "                dirtype = SUBTITLE\n",
       "            else:\n",
       "                logger.info(f\"Skipping directory.\")\n",
       "                continue\n",
       "            originaldiritems.append((dirname, next(os.walk(foundpath))[2], dirtype))\n",
       "        try:\n",
       "            for diritem in originaldiritems:\n",
       "                dirpath = f\"{localsavingpath}/{diritem[0]}/\" if diritem[0] else f'{localsavingpath}/'\n",
       "                originaldirfiles = diritem[1].copy()\n",
       "                diritem[1].clear()\n",
       "                for filename in originaldirfiles:\n",
       "                    if filename in selectedfilenames or not selectedfilenames:\n",
       "                        suffix = ''\n",
       "                        langsuffix = ''\n",
       "                        suffixfilecount = 0\n",
       "                        filename_split = os.path.splitext(filename)\n",
       "                        filenamewithoutextension = filename_split[0]\n",
       "                        fileextension = filename_split[1].lower()\n",
       "                        originalfilepath = dirpath + filename\n",
       "                        videofile = fileextension in video_file_extensions\n",
       "                        subfile = fileextension in subtitlefile_extensions\n",
       "                        size = os.path.getsize(originalfilepath)\n",
       "                        titlefile = videofile and size > 500000000 and is_title_name(filenamewithoutextension)\n",
       "                        maintitlefile = diritem[0] == \"\" and titlefile # fix\n",
       "                        filetype = \"other\" if not (videofile or subfile) else (\"video\" if videofile else \"subtitle\")\n",
       "                        logger.info(f\"Processing file: {originalfilepath}\\n(Type: {filetype}  Size: {data_str(size)}  Extension:{fileextension} TitleFile: {titlefile} MainTitleFile: {maintitlefile})\")\n",
       "                        if any(contains(filename, check) for check in skip_list):\n",
       "                            file_command(\"rm\", originalfilepath)\n",
       "                        elif videofile or subfile:\n",
       "                            if filenamewithoutextension != renamed_title and (subfile or titlefile):\n",
       "                                if subfile: \n",
       "                                    langsearch = langs_pt.findall(filenamewithoutextension)\n",
       "                                    if langsearch:  \n",
       "                                        langsuffix = f\".{title(langsearch[-1])}\"\n",
       "                                titlename = renamed_title if maintitlefile or subfile else name_movie(filenamewithoutextension, include_quality= True)\n",
       "                                filenewname = titlename + langsuffix + fileextension \n",
       "                                renamedfilepath = dirpath + filenewname\n",
       "                                while os.path.exists(renamedfilepath):\n",
       "                                    suffixfilecount += 1\n",
       "                                    suffix = f\".{suffixfilecount}{langsuffix}\"\n",
       "                                    filenewname = renamed_title + suffix + fileextension\n",
       "                                    renamedfilepath = dirpath + filenewname\n",
       "                                file_command(\"mv\", originalfilepath, renamedfilepath, log_message= \"Renaming file:\")\n",
       "                                filename = filenewname\n",
       "                            diritem[1].append(filename)\n",
       "                downloaded_diritems.append(diritem)\n",
       "            logger.release()\n",
       "            return True\n",
       "        except:\n",
       "            logger.error(ex())\n",
       "            logger.release()\n",
       "            return False\n",
       "\n",
       "    ## After Download\n",
       "\n",
       "    def clean_movie(path, newname):\n",
       "        search = yearsuff_pt.search(newname)\n",
       "        if not search:\n",
       "            newname = name_movie(newname)\n",
       "            p1 = path\n",
       "            p2 = f\"{config.movies_path}/{newname}\"\n",
       "            cmd = f'mv \"{p1}\" \"{p2}\"'\n",
       "            !$cmd\n",
       "            path = p2\n",
       "            print(newname)\n",
       "        after_shave_movie(path, newname)\n",
       "        return True\n",
       "\n",
       "    def clean_tvshows(path = \"\"):\n",
       "        if not path:\n",
       "            path = config.tv_path\n",
       "        shows = next(os.walk(path))[1]\n",
       "        for show in shows:\n",
       "            print(show)\n",
       "            path = path + \"/\" + show\n",
       "            clean_tvshow(path)\n",
       "\n",
       "    def clean_tvshow(path, diritems = []):\n",
       "        dircontent = next(os.walk(path))[1]\n",
       "        if len(dircontent) != 0:\n",
       "            for dir in dircontent:\n",
       "                p0 = f\"{path}/{dir}\"\n",
       "                if not has_size(p0, True):\n",
       "                    cmd = f'rm -r \"{p0}\"'\n",
       "                    !$cmd\n",
       "                    continue\n",
       "                newname = get_season(dir, False)\n",
       "                if newname:\n",
       "                    if newname != dir:\n",
       "                        p0 =  f\"{path}/{dir}\"\n",
       "                        p1 = f\"{path}/{newname}\"\n",
       "                        cmd = f'mv \"{p0}\" \"{p1}\"'\n",
       "                        !$cmd\n",
       "                        dir = newname\n",
       "                seasonpath = f\"{path}/{dir}\"\n",
       "                files = clean_season(seasonpath)\n",
       "                item = (dir, files)\n",
       "                diritems.append(item)\n",
       "        else:\n",
       "            files = clean_season(path)\n",
       "            item = ('', files)\n",
       "            diritems.append(item)\n",
       "        return True\n",
       "\n",
       "    def clean_season(path):\n",
       "        clean = []\n",
       "        logger.info(f'Cleaning show season in path: {path}')\n",
       "        if not os.path.exists(path):\n",
       "            raise(Exception(\"The given season path doesn't exist.\"))\n",
       "        files = next(os.walk(path))[2]\n",
       "        for file in files:\n",
       "            splitted = os.path.splitext(file)\n",
       "            eps = splitted[0]\n",
       "            ext = splitted[1]\n",
       "            p1 = f\"{path}/{file}\"\n",
       "            if ext in video_file_extensions:\n",
       "                newname = name_episode(eps) + ext\n",
       "                if newname != file:\n",
       "                    p2 = f\"{path}/{newname}\"\n",
       "                    cmd = f'mv \"{p1}\" \"{p2}\"'\n",
       "                    !$cmd\n",
       "                clean.append(newname)\n",
       "            elif any(contains(file.lower(), check) for check in skip_list):\n",
       "                cmd = f'rm \"{p1}\"'\n",
       "                !$cmd\n",
       "        logger.info(f'Cleaned files: {len(clean)}')   \n",
       "        return clean\n",
       "\n",
       "    def process_external_link(title, suff_text= \"\", base= \"\"):\n",
       "        if title:\n",
       "            title = str(title)\n",
       "            if suff_text:\n",
       "                title = title.replace(\"</a>\", f\" {suff_text}</a>\")\n",
       "            title = title.replace('<a href=\"', f'<a {linkhtmlstr} href=\"{base}') \n",
       "            return title\n",
       "        return ''\n",
       "    \n",
       "    ##\n",
       "\n",
       "    global searchsortdropdowns_style, searchsortbtn_layout, searchdownloadbtn_layout, pagebtn_layout, downloadbtn, searchresultstablecolumnwidths, searchresultstablecolumnalignments, resultstablebuttons, imdbresultstablesorters, imdbresultstablecolumnwidths, imdbresultstablecolumnalignments, icon_css, download_css, wordwrap_css, linkhtmlstr\n",
       "    \n",
       "    searchsortdropdowns_style = {\"description_width\": \"40px\"}\n",
       "    searchsortbtn_layout = {\"width\": \"80px\", \"margin\": \"0 10px\"}\n",
       "    searchdownloadbtn_layout = {\"width\": \"180px\"}\n",
       "    pagebtn_layout= {'width':'29px', 'height':'29px', 'padding': '2px', 'margin': '0 6px 0 0'}\n",
       "    downloadbtn = '<i class=\"ico ico-download\"></i>'\n",
       "    searchresultstablecolumnwidths={'Name': '52%', 'Date': '9%', 'Size': '8%', 'Seeders': '8%', 'Leechers': '8%', 'Uploader': '10%', \" \": \"5%\"}\n",
       "    searchresultstablecolumnalignments={'Name': 'left', 'Date': 'center', 'Size': 'center', 'Seeders': 'center', 'Leechers': 'center', 'Uploader': 'center', \" \": \"center\"}\n",
       "    resultstablebuttons = {\"Download\": downloadbtn}\n",
       "    imdbresultstablesorters = [{'field': 'Downloaded', 'dir': 'desc'},]\n",
       "    imdbresultstablecolumnwidths ={\"Title\":'21%',  \"Director\": '10%', \"Stars\": '20%',\"Genres\": '13%', \"Rating\": '5%', \"Votes\": '5%', \"Runtime\": '5%', \"Downloaded\": '7%', \"Watched\": '6%', \" \": '3%'}\n",
       "    imdbresultstablecolumnalignments ={'Title': 'left', 'Director': 'left', 'Stars': 'left', 'Genres': 'left', 'Rating': 'center', 'Votes': 'center', \"Runtime\": 'center', \"Downloaded\": 'center', \"Watched\": 'center', \" \": \"center\"}\n",
       "\n",
       "    icon_css = \"\"\"background: url( \"data:image/svg+xml,%3Csvg%20id%3D%22download-svg%22%20width%3D%2225px%22%20height%3D%2225px%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20opacity%3D%220.5%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M3%2014.25C3.41421%2014.25%203.75%2014.5858%203.75%2015C3.75%2016.4354%203.75159%2017.4365%203.85315%2018.1919C3.9518%2018.9257%204.13225%2019.3142%204.40901%2019.591C4.68577%2019.8678%205.07435%2020.0482%205.80812%2020.1469C6.56347%2020.2484%207.56459%2020.25%209%2020.25H15C16.4354%2020.25%2017.4365%2020.2484%2018.1919%2020.1469C18.9257%2020.0482%2019.3142%2019.8678%2019.591%2019.591C19.8678%2019.3142%2020.0482%2018.9257%2020.1469%2018.1919C20.2484%2017.4365%2020.25%2016.4354%2020.25%2015C20.25%2014.5858%2020.5858%2014.25%2021%2014.25C21.4142%2014.25%2021.75%2014.5858%2021.75%2015V15.0549C21.75%2016.4225%2021.75%2017.5248%2021.6335%2018.3918C21.5125%2019.2919%2021.2536%2020.0497%2020.6517%2020.6516C20.0497%2021.2536%2019.2919%2021.5125%2018.3918%2021.6335C17.5248%2021.75%2016.4225%2021.75%2015.0549%2021.75H8.94513C7.57754%2021.75%206.47522%2021.75%205.60825%2021.6335C4.70814%2021.5125%203.95027%2021.2536%203.34835%2020.6517C2.74643%2020.0497%202.48754%2019.2919%202.36652%2018.3918C2.24996%2017.5248%202.24998%2016.4225%202.25%2015.0549C2.25%2015.0366%202.25%2015.0183%202.25%2015C2.25%2014.5858%202.58579%2014.25%203%2014.25Z%22%20fill%3D%22%231C274C%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M12%2016.75C12.2106%2016.75%2012.4114%2016.6615%2012.5535%2016.5061L16.5535%2012.1311C16.833%2011.8254%2016.8118%2011.351%2016.5061%2011.0715C16.2004%2010.792%2015.726%2010.8132%2015.4465%2011.1189L12.75%2014.0682V3C12.75%202.58579%2012.4142%202.25%2012%202.25C11.5858%202.25%2011.25%202.58579%2011.25%203V14.0682L8.55353%2011.1189C8.27403%2010.8132%207.79963%2010.792%207.49393%2011.0715C7.18823%2011.351%207.16698%2011.8254%207.44648%2012.1311L11.4465%2016.5061C11.5886%2016.6615%2011.7894%2016.75%2012%2016.75Z%22%20fill%3D%22%231C274C%22%2F%3E%3C%2Fsvg%3E\" );\"\"\"\n",
       "    download_css = \"\"\"  font-size: 20px;\n",
       "                        font-weight: 500;\n",
       "                        padding: 1px 0;\n",
       "                        transition: .4s; \n",
       "                        color: #001dd5;\n",
       "                    \"\"\"\n",
       "    wordwrap_css = \"white-space: pre-wrap;\"\n",
       "    linkhtmlstr = 'target=\"_blank\" style= \"color: rgb(1, 74, 118); text-decoration: none;\"'\n",
       "\n",
       "SETUP_LT = \"setup lt\"\n",
       "SETUP_DISPLAY = \"setup display\"\n",
       "SETUP_STORAGE_AND_PATHES = \"remote storage\"\n",
       "SCRAPE_WATCHED_LIST = \"scrape watched list\"\n",
       "\n",
       "if IS_ENV_COLAB:\n",
       "    setup_lt_task = Thread(target= setup_lt)\n",
       "    setup_lt_task.name = SETUP_LT\n",
       "    config.setupthreads.add(setup_lt_task)\n",
       "    setup_lt_task.start()\n",
       "\n",
       "    side_setups_task = Thread(target= side_setup)\n",
       "    side_setups_task.name = SETUP_DISPLAY\n",
       "    config.setupthreads.add(side_setups_task)\n",
       "    side_setups_task.start()\n",
       "\n",
       "    if not config.watched_movies_list:\n",
       "        scrape_watchedmovielist_task = Thread(target= scrape_watched_movies_list, args=(1,2))\n",
       "        scrape_watchedmovielist_task.name = SCRAPE_WATCHED_LIST\n",
       "        config.setupthreads.add(scrape_watchedmovielist_task)\n",
       "        scrape_watchedmovielist_task.start()\n",
       "\n",
       "def arethreadsworking(threadset: set[Thread], v= False):\n",
       "    alivethreads = set()\n",
       "    for thread in threadset:\n",
       "        if thread.is_alive():\n",
       "            alivethreads.add(thread.name)\n",
       "            if v:  print(f'Alive: {thread.name}')\n",
       "    return alivethreads if alivethreads else False\n",
       "\n",
       "from ipywidgets import VBox, HBox, Box, HTML, Text, FloatProgress, Button, Label, Dropdown, DatePicker, Checkbox, Layout, BoundedFloatText, BoundedIntText, FileUpload, Password, Tab\n",
       "from IPython.display import Javascript\n",
       "\n",
       "set_remote_storage_and_pathes()\n",
       "\n",
       "# UI CONSTS\n",
       "\n",
       "nav = {}\n",
       "\n",
       "CONFIG_TAB = 'configuration'\n",
       "SEARCH_TAB = 'search'\n",
       "IMDB_TAB = 'IMDB search'\n",
       "ADD_TAB = 'adding'\n",
       "MONITOR_TAB = 'monitor'\n",
       "\n",
       "# API CONSTS\n",
       "\n",
       "MERGE_DOWNLOAD = 'MERGE'\n",
       "\n",
       "GENERAL = \"General\" \n",
       "SOFTWARE = \"Software\"\n",
       "GAMES = \"Games\"\n",
       "SUBTITLE = \"Subtitle\"\n",
       "FEATURETTES = \"Featurettes\"\n",
       "OTHER = \"Other\"\n",
       "MOVIE = \"Movie\"\n",
       "TV = \"TV\"\n",
       "SHOW = \"TV Show\"\n",
       "SEASON = \"Season\"\n",
       "EPISODE = \"Episode\"\n",
       "MUSIC = \"Music\"\n",
       "ALBUM = \"Album\"\n",
       "TRACK = \"Track\"\n",
       "X1337X = '1337x'\n",
       "IMDB = 'IMDB'\n",
       "RARBG = 'rarbg'\n",
       "\n",
       "ALLCATEGORIES_TD = ''\n",
       "MOVIESCATEGORY_TD = \"movies\"\n",
       "TVCATEGORY_TD = \"tv\"\n",
       "APPSCATEGORY_TD = \"apps\"\n",
       "GAMESCATEGORY_TD = \"games\"\n",
       "\n",
       "SEEDERSSORT = \"td-seeders\"\n",
       "TIMESORT = \"td-time\"\n",
       "SIZESORT = \"td-size\"\n",
       "ASCORDER = \"td-asc\"\n",
       "DESCORDER = \"td-desc\"\n",
       "\n",
       "HASH_ADDSOURCE = \"download hash\"\n",
       "LOCALFILE_ADDSOURCE = \"local file\"\n",
       "UPLOADFILE_ADDSOURCE = \"uploaded file\"\n",
       "MAGNET_ADDSOURCE = \"magnet\"\n",
       "URL_ADDSOURCE = \"file url\"\n",
       "\n",
       "site_categories = {MOVIE: MOVIESCATEGORY_TD ,\n",
       "                 TV: TVCATEGORY_TD,\n",
       "                 SHOW: TVCATEGORY_TD,\n",
       "                 SEASON: TVCATEGORY_TD,\n",
       "                 EPISODE: TVCATEGORY_TD,\n",
       "                 SOFTWARE :APPSCATEGORY_TD,\n",
       "                 GAMES :GAMESCATEGORY_TD, \n",
       "                 GENERAL: ALLCATEGORIES_TD}\n",
       "\n",
       "download_types = {GENERAL:  \"General\",\n",
       "        SOFTWARE:  \"Software\",\n",
       "        GAMES:  \"Games\",\n",
       "        MOVIE:  \"Movie\",\n",
       "        SHOW:  \"Show\",\n",
       "        SEASON:  \"Season\",\n",
       "        EPISODE:  \"Episode\",\n",
       "        MUSIC : \"Music\",\n",
       "        ALBUM : \"Album\",\n",
       "        TRACK : \"Track\"}\n",
       "\n",
       "IMDB_DATE_SORT = \"release_date\"\n",
       "IMDB_RATING_SORT = \"user_rating\"\n",
       "IMDB_ALPHABETICAL_SORT = \"alpha\"\n",
       "IMDB_TOP_250 =\"top_250\"\n",
       "IMDB_TOP_1000 = \"top_1000\"\n",
       "IMDB_OSCAR_WINNER = \"oscar_winner\"\n",
       "IMDB_BEST_PICTURE_WINNER = \"best_picture_winner\"\n",
       "IMDB_BEST_DIRECTOR_WINNER = \"best_director_winner\"\n",
       "\n",
       "## ADD API\n",
       "\n",
       "ADDSUCCUSS = 100\n",
       "ADDERROR = 101\n",
       "ADDPENDING = 102\n",
       "ALREADYADDED = 103\n",
       "\n",
       "#\n",
       "\n",
       "class AppState:\n",
       "    @staticmethod\n",
       "    def instance():\n",
       "        if not AppState._state:\n",
       "            AppState._state = AppState()\n",
       "        return AppState._state\n",
       "    def __init__(self):\n",
       "        if AppState._state:\n",
       "            raise('AppState is singlton.')\n",
       "        AppState._state = self\n",
       "    _state = None\n",
       "    running = False\n",
       "    watchedlistready = False\n",
       "    driveready = False\n",
       "    ftpready = False\n",
       "    currentviewcontainer = None\n",
       "    monitorthread: Thread = None\n",
       "    monitoralive= False\n",
       "    transferthread: Thread = None\n",
       "    transferalive= False\n",
       "    addthread: Thread = None\n",
       "    addalive = False\n",
       "    metacheckerthread: Thread = False\n",
       "    metacheckeralive= False\n",
       "    total_wanted = total_up = total_progress = active_down = active_up = completed_up = completed_down = 0\n",
       "    total_downloads= downloadings = deads = transferings = completed = 0\n",
       "    addresults = []\n",
       "    bulksearch = None\n",
       "    searchresults = []\n",
       "    backthreads = {}\n",
       "    clicktasks = []\n",
       "    clicktaskstates = {}\n",
       "    navactions = []\n",
       "    tab_indices = {}\n",
       "\n",
       "appstate = AppState.instance()\n",
       "\n",
       "class DownloadAttrs:\n",
       "    def __init__(self, type_ = GENERAL, existing_mode = False, backup = False, save_name = \"\", sequential= False, \n",
       "        uncomplete_source = \"\", imdb_name = \"\", imdb_rating = \"\", imdb_votes = \"\", partial = False, name= '', torfile= ''):\n",
       "        self.type_ = type_ \n",
       "        self.existing_mode =  existing_mode\n",
       "        self.backup =  backup\n",
       "        self.save_name =  save_name\n",
       "        self.sequential = sequential \n",
       "        self.uncomplete_source  =  uncomplete_source\n",
       "        self.imdb_name =  imdb_name\n",
       "        self.imdb_rating =  imdb_rating\n",
       "        self.imdb_votes =  imdb_votes\n",
       "        self.partial = partial\n",
       "        self.name = name\n",
       "        self.torfile = torfile\n",
       "    torfile = \"\"\n",
       "    artist = \"\"\n",
       "    album = \"\"\n",
       "    track = \"\"\n",
       "    partial = False\n",
       "    backup = False\n",
       "    completed = False\n",
       "    existing_mode = MERGE_DOWNLOAD\n",
       "    readytodownload = False\n",
       "    name = \"\"\n",
       "    hash = ''\n",
       "    save_name = \"\"\n",
       "    save_path = \"\"\n",
       "    renamed_file = \"\"\n",
       "    saving_dir_path = \"\"\n",
       "    imdb_name = \"\"\n",
       "    type_ = GENERAL\n",
       "    save_type = 0\n",
       "    sequential = False\n",
       "    full_size = 0\n",
       "    download_size = 0\n",
       "    allfiles = 0\n",
       "    selectedfilescount = 0\n",
       "    files = None\n",
       "    uncomplete_source = \"\"\n",
       "    show = \"\"\n",
       "    season = \"\"\n",
       "    existing_savingdir = \"\"\n",
       "    existing_path = \"\"\n",
       "    baksv = None\n",
       "    year = 0\n",
       "    imdb_rating = \"\"\n",
       "    imdb_votes = \"\"\n",
       "    quality = \"1080\"\n",
       "    site_source = \"\"\n",
       "    uploader = \"\"\n",
       "    format = \"\"\n",
       "    duration = \"\"\n",
       "    video_width = \"\"\n",
       "    video_height = \"\"\n",
       "    frame_rate = \"\"\n",
       "    bit_rate = \"\"\n",
       "    color_bit_depth = \"\"\n",
       "    video_bit_rate = \"\"\n",
       "    magnet = \"\"\n",
       "    add_source = ''\n",
       "    audio_tracks = None\n",
       "    downloaded_diritems = None\n",
       "    selectedfilenames = None\n",
       "    total_downloaded = 0\n",
       "    verify_download = None\n",
       "    old_files_dirs = None\n",
       "    hasmetadata = False\n",
       "    addmethod = None\n",
       "    \n",
       "    def copy(self):\n",
       "        return DownloadAttrs(type_= self.type_,\n",
       "                    existing_mode= self.existing_mode,\n",
       "                    backup= self.backup,\n",
       "                    sequential= self.sequential,\n",
       "                    uncomplete_source= self.uncomplete_source,\n",
       "                    imdb_name= self.imdb_name,\n",
       "                    imdb_rating= self.imdb_rating,\n",
       "                    imdb_votes= self.imdb_votes)\n",
       "\n",
       "class DownloadFile():\n",
       "    def __init__(self, index, name, size, selected = True):\n",
       "        self.index = index\n",
       "        self.name = name\n",
       "        self.size = size\n",
       "    index = 0\n",
       "    name = \"\"\n",
       "    size = 0\n",
       "    selected = True\n",
       "\n",
       "class SearchParams: #NOT USED\n",
       "    def __init__(self, sites= None, search= \"\", category= None, sort= \"\", order= \"\", attrs= None) -> None:\n",
       "        self.sites = sites\n",
       "        self.search = search\n",
       "        self.attrs = attrs\n",
       "        self.category = category\n",
       "        self.sort = sort\n",
       "        self.order = order\n",
       "    sites = None\n",
       "    search = \"\"\n",
       "    category = None\n",
       "    sort = \"\"\n",
       "    order = \"\"\n",
       "    attrs = None\n",
       "\n",
       "class IMDBParams:\n",
       "    def __init__(self, keyword= \"\" , titletype= \"\", startdate= \"\", enddate= \"\", minrating= 0, maxrating= 0, minvotes= 0, maxvotes= 0,\n",
       "                 minruntime= 0, maxruntime= 0, inlists= \"\", notinlists= \"\", imdbsort= \"\", imdborder= \"\", filterwatched= False,\n",
       "                filterdownloaded= False, top250= False, top1000= False, oscarwinner= False, bestpicturewinner= False,\n",
       "                bestdirectorwinner= False, englishonly= False, animationtitles= False, internationaltitles= False, indianmovies= False,\n",
       "                sites= None, sitecategory= \"\", siteparameters= \"\", attrs= None):\n",
       "        self.keyword = keyword\n",
       "        self.titletype = titletype\n",
       "        self.startdate = startdate\n",
       "        self.enddate = enddate\n",
       "        self.minrating = minrating\n",
       "        self.maxrating = maxrating\n",
       "        self.minvotes = minvotes\n",
       "        self.maxvotes = maxvotes\n",
       "        self.minruntime = minruntime\n",
       "        self.maxruntime = maxruntime\n",
       "        self.inlists = inlists\n",
       "        self.notinlists = notinlists\n",
       "        self.imdbsort = imdbsort\n",
       "        self.imdborder = imdborder\n",
       "        self.filterwatched = filterwatched\n",
       "        self.filterdownloaded = filterdownloaded\n",
       "        self.top250 = top250\n",
       "        self.top1000 = top1000\n",
       "        self.oscarwinner = oscarwinner\n",
       "        self.bestpicturewinner = bestpicturewinner\n",
       "        self.bestdirectorwinner = bestdirectorwinner\n",
       "        self.englishonly = englishonly\n",
       "        self.animationtitles = animationtitles\n",
       "        self.internationaltitles = internationaltitles\n",
       "        self.indiantitles = indianmovies\n",
       "        self.sites = sites\n",
       "        self.sitecategory = sitecategory\n",
       "        self.siteparameters = siteparameters \n",
       "        self.attrs = attrs\n",
       "    keyword = \"\"\n",
       "    titletype = \"\"\n",
       "    startdate = \"\"\n",
       "    enddate = \"\"\n",
       "    minrating = \"\"\n",
       "    maxrating = \"\"\n",
       "    minvotes = \"\"\n",
       "    maxvotes = \"\"\n",
       "    minruntime = \"\"\n",
       "    maxruntime = \"\"\n",
       "    inlists = \"\"\n",
       "    notinlists = \"\"\n",
       "    imdbsort = \"\"\n",
       "    imdborder = \"\"\n",
       "    filterwatched = False\n",
       "    filterdownloaded = False\n",
       "    top250 = False\n",
       "    top1000 = False\n",
       "    oscarwinner = False\n",
       "    bestpicturewinner = False\n",
       "    bestdirectorwinner = False\n",
       "    englishonly = False\n",
       "    animationtitles = False\n",
       "    internationaltitles = False\n",
       "    indiantitles = False\n",
       "    sites = None\n",
       "    sitecategory = None\n",
       "    siteparameters = None \n",
       "    attrs = None\n",
       "    rarbgauto = False\n",
       "    labels = \"\"\n",
       "\n",
       "class IMDBTitle:\n",
       "    def __init__(self, title_text, title_link= '', runtime= '', rating= '', votes= '', genres= \"\", directors= \"\", stars= \"\"):\n",
       "        self.title_text = title_text\n",
       "        self.title_link = title_link\n",
       "        self.runtime = runtime\n",
       "        self.rating = rating\n",
       "        self.votes = votes\n",
       "        self.director = directors\n",
       "        self.stars = stars\n",
       "        self.genres = genres\n",
       "\n",
       "    title_text = None\n",
       "    title_link = None\n",
       "    runtime = None\n",
       "    rating = None\n",
       "    votes = None\n",
       "    director = None\n",
       "    stars = None\n",
       "    genres = None\n",
       "    downloaded = False\n",
       "    watched = False\n",
       "\n",
       "class DownloadResult: \n",
       "    def __init__(self, resulturl= \"\", size = 0, date = \"\", seeders = \"\", leechers = \"\", uploader = \"\", href = \"\", downloaded= False, watched= False, attrs= None):\n",
       "        self.resulturl = resulturl\n",
       "        self.size = size\n",
       "        self.date = date \n",
       "        self.seeders = seeders\n",
       "        self.leechers = leechers\n",
       "        self.uploader = uploader\n",
       "        self.href = href\n",
       "        self.downloaded = downloaded\n",
       "        self.watched = watched\n",
       "        self.attrs = attrs\n",
       "\n",
       "    resulturl: str\n",
       "    size = 0\n",
       "    magnet = date = seeders = leechers = uploader = href = \"\"\n",
       "    downloaded = watched = False\n",
       "    attrs: DownloadAttrs = None\n",
       "\n",
       "class WebResult:\n",
       "    def __init__(self, search=\"\", category= None, results= None, attrs= None, sort= None, order= None, url= None, resultcount= 0, page= None,\n",
       "                 pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None: \n",
       "        self.search = search\n",
       "        self.category = category\n",
       "        self.results = results\n",
       "        self.attrs = attrs\n",
       "        self.sort = sort\n",
       "        self.order = order\n",
       "        self.url = url\n",
       "        self.resultcount = resultcount\n",
       "        self.page = page\n",
       "        self.pageresultcount = pageresultcount\n",
       "        self.totalpages = totalpages\n",
       "        self.nextpage = nextpage\n",
       "        self.previouspage = previouspage\n",
       "        self.resultpages = dict()\n",
       "        \n",
       "    attrs: DownloadAttrs \n",
       "    sort = None\n",
       "    order = DESCORDER\n",
       "    results: list[DownloadResult|IMDBTitle] = None\n",
       "    url = None\n",
       "    currentpageurl = None\n",
       "    result = None\n",
       "    request = None\n",
       "    status = None\n",
       "    error = None\n",
       "    search = \"\"\n",
       "    category = None\n",
       "    resultcount = 0\n",
       "    totalpages = 0\n",
       "    page = 0\n",
       "    nextpage = -1\n",
       "    previouspage = -1\n",
       "    pageresultcount = 0\n",
       "    table = None\n",
       "    tableoutput: Output = None\n",
       "    pagination_container: HBox = None\n",
       "    resultscount = 0\n",
       "    site = ''\n",
       "    tab = None\n",
       "    resultpages = None\n",
       "\n",
       "    def pagination_handler(self, btn): \n",
       "        page = int(btn.description)\n",
       "        updatesearchresults(self, page= page)\n",
       "\n",
       "    def actionhandler(self, e):\n",
       "        pass\n",
       "\n",
       "    def getdataframe(self):\n",
       "        pass\n",
       "\n",
       "    def getresultcontrols(self):\n",
       "        pass\n",
       "\n",
       "    def getresultstable(self):\n",
       "        pass\n",
       "\n",
       "    def applytablestyle(self):\n",
       "        pass\n",
       "\n",
       "    def getresultcontrols(self):\n",
       "        pass\n",
       "\n",
       "    def updateresults(self, page, sort= None, order= None):\n",
       "        pass\n",
       "\n",
       "class IMDBResult(WebResult): #obj values used in class attribute definitions should be defined before, in function/methods it shouldn't be.\n",
       "    def __init__(self, imdbparams= None, search=\"\", category= None, results= None, attrs= None, sort= \"\", order= None, url= \"\", resultcount= 0,\n",
       "                 page= None, pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None:\n",
       "        super().__init__(search, category, results, attrs, sort, order, url, resultcount, page, pageresultcount, totalpages, nextpage, previouspage)\n",
       "        self.imdbparams = imdbparams\n",
       "        self.tab = nav[IMDB_TAB]\n",
       "        self.site = IMDB\n",
       "        self.downloadedtitlespages = dict()\n",
       "        self.watchedtitlespages = dict()\n",
       "\n",
       "    results: list[IMDBTitle] = None\n",
       "    imdbparams: IMDBParams \n",
       "    downloadedcount = 0\n",
       "    watchedcount = 0\n",
       "    downloadedtitles: list[IMDBTitle] = None\n",
       "    watchedtitles: list[IMDBTitle] = None\n",
       "    sort = IMDB_DATE_SORT\n",
       "    order = ASCORDER\n",
       "\n",
       "    def actionhandler(self, e):\n",
       "        params = self.imdbparams\n",
       "        if e.column == ' ':\n",
       "            result: IMDBTitle = self.results[e.row]\n",
       "            logger.info(f'Searching download {result.title_link} from IMDB search.')\n",
       "            search = f\"{result.title_text} {self.imdbparams.siteparameters}\"\n",
       "            switchview(nav[SEARCH_TAB], getloadingview( f'Search for {download_types[self.attrs.type_]} \"{result.title_link}\" site: {params.sites[0]} page: 1.'), temp= True)\n",
       "            maintabs.selected_index = appstate.tab_indices[SEARCH_TAB]\n",
       "            search_process(site= params.sites[0], search= search, attrs= self.attrs, category= params.sitecategory, sort= SEEDERSSORT, order= DESCORDER, page= 1, source= IMDB_TAB)\n",
       "\n",
       "    def getdataframe(self):\n",
       "        resulttablesource = {\"Title\":[],  \"Director\": [], \"Stars\": [],\"Genres\": [], \"Rating\": [], \"Votes\": [], \"Runtime\": [], \"Downloaded\": [], \"Watched\": [],\" \": []}\n",
       "        for result in self.results:\n",
       "            resulttablesource['Title'].append(result.title_link)\n",
       "            resulttablesource['Director'].append(result.director)\n",
       "            resulttablesource['Stars'].append(result.stars)\n",
       "            resulttablesource['Genres'].append(result.genres)\n",
       "            resulttablesource['Rating'].append(result.rating)\n",
       "            resulttablesource['Votes'].append(result.votes)\n",
       "            resulttablesource['Runtime'].append(result.runtime)\n",
       "            resulttablesource['Downloaded'].append(\"Downloaded\" if result.downloaded else \"\")\n",
       "            resulttablesource['Watched'].append(\"Watched\" if result.watched else \"\")\n",
       "            resulttablesource[' '].append(' ⤓ ')\n",
       "        return pd.DataFrame(resulttablesource)\n",
       "\n",
       "    def getresultstable(self):\n",
       "        dataframe = self.getdataframe()\n",
       "        self.table = pn.widgets.Tabulator(dataframe,\n",
       "                                                disabled= True,\n",
       "                                                sizing_mode= 'stretch_width',\n",
       "                                                widths= imdbresultstablecolumnwidths,\n",
       "                                                header_align='center',\n",
       "                                                text_align= imdbresultstablecolumnalignments,\n",
       "                                                show_index= False, \n",
       "                                                pagination= None,\n",
       "                                                formatters= imdbresultstableformatters,\n",
       "                                                sorters= imdbresultstablesorters,\n",
       "                                                selectable='checkbox', \n",
       "                                                theme= 'bootstrap4', #or: semantic-ui\n",
       "                                                configuration= {\n",
       "                                                'rowHeight': 60,\n",
       "                                                'columnDefaults': {'headerSort': False,}})\n",
       "        self.applytablestyle()\n",
       "        self.table.on_click(self.actionhandler)  \n",
       "        return self.table  \n",
       "\n",
       "    def applytablestyle(self):\n",
       "        self.table.style.apply(lambda s: [download_css for i in range(len(s))], subset=[' '])\n",
       "        self.table.style.apply(lambda s: [wordwrap_css for i in range(len(s))])\n",
       "\n",
       "    def getresultcontrols(self):\n",
       "        sort_dropdown = Dropdown(description= \"Sort\", value= self.sort ,options= [(\"By User Rating\", IMDB_RATING_SORT), (\"By Date\", IMDB_DATE_SORT), (\"Alphabetically\", IMDB_ALPHABETICAL_SORT)], layout= {}, style= searchsortdropdowns_style)\n",
       "        order_dropdown = Dropdown(description= \"Order\", value= self.order, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= {}, style= searchsortdropdowns_style)\n",
       "        sort_btn = Button(description= \"Sort\", layout= searchsortbtn_layout)\n",
       "        sort_btn.on_click(lambda btn: updatesearchresults(self, 1, sort= sort_dropdown.value, order= order_dropdown.value))\n",
       "        download_btn = Button(description= \"Download Selected\", layout= searchdownloadbtn_layout)\n",
       "        download_btn.on_click(self.handlebulkdownload)\n",
       "        return (sort_dropdown, order_dropdown, sort_btn, download_btn)\n",
       "    \n",
       "    def handlebulkdownload(self, btn):\n",
       "        appstate.bulksearch = [self.results[index].title_text for index in self.table.selection]\n",
       "        \n",
       "        # call bulk download handle func\n",
       "        # handler pops next downloaditem, displays site decision view (temp) with handler\n",
       "        # on input handler searches in the site\n",
       "        # on download, adds donwloadload, pops next download item and shows site decesion view ()\n",
       "        # display result\n",
       "\n",
       "    def updateresults(self, page, sort= None, order= None):\n",
       "        if not sort:\n",
       "            sort= self.sort\n",
       "        if not order:\n",
       "            order= self.order\n",
       "        pagekey = getresultpagekey(sort, order, page)\n",
       "        if pagekey in self.resultpages:\n",
       "            self.results = self.resultpages[pagekey]\n",
       "            self.downloadedtitles = self.downloadedtitlespages[page]\n",
       "            self.watchedtitles = self.watchedtitlespages[page]\n",
       "            self.page = page\n",
       "            self.sort = sort\n",
       "            self.order = order\n",
       "            self.pageresultcount = len(self.results)\n",
       "            self.previouspage = page - 1\n",
       "            self.nextpage = page + 1 if page + 1 <= self.totalpages else 0\n",
       "        else:\n",
       "            self.imdbparams.imdbsort = sort\n",
       "            self.imdbparams.imdborder = order\n",
       "            searchIMDB(self.imdbparams, page= page, result= self)\n",
       "\n",
       "class SearchResult(WebResult):\n",
       "    def __init__(self, site= X1337X, search=\"\", category= ALLCATEGORIES_TD, results= None, attrs= None, sort= \"\", order= None, url= \"\",\n",
       "                 resultcount= 0, page= None, pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None:\n",
       "        super().__init__(search, category, results, attrs, sort, order, url, resultcount, page, pageresultcount,\n",
       "                         totalpages, nextpage, previouspage)\n",
       "        self.site = site\n",
       "        self.sorters = []\n",
       "        self.tab = nav[SEARCH_TAB]\n",
       "\n",
       "    sort = SEEDERSSORT\n",
       "    def actionhandler(self, e):\n",
       "        if e.column == ' ':\n",
       "            res: DownloadResult = self.results[e.row]\n",
       "            download1337x(res, self.attrs.copy())\n",
       "\n",
       "    def getdataframe(self):\n",
       "        resulttablesource = {\"Name\":[],  \"Date\": [], \"Size\": [],\"Seeders\": [], \"Leechers\": [], \"Uploader\": [], \" \": []}\n",
       "        for result in self.results:\n",
       "            resulttablesource['Name'].append(result.resulturl)\n",
       "            resulttablesource['Size'].append(result.size)\n",
       "            resulttablesource['Date'].append(result.date)\n",
       "            resulttablesource['Seeders'].append(result.seeders)\n",
       "            resulttablesource['Leechers'].append(result.leechers)\n",
       "            resulttablesource['Uploader'].append(result.uploader)\n",
       "            resulttablesource[' '].append(' ⤓ ')\n",
       "        return pd.DataFrame(resulttablesource)\n",
       "    \n",
       "    def getresultstable(self):\n",
       "        dataframe = self.getdataframe()\n",
       "        self.table = pn.widgets.Tabulator(dataframe,\n",
       "                                                disabled= True,\n",
       "                                                sizing_mode= 'stretch_width',\n",
       "                                                widths= searchresultstablecolumnwidths,\n",
       "                                                header_align='center',\n",
       "                                                text_align= searchresultstablecolumnalignments,\n",
       "                                                show_index= False, \n",
       "                                                pagination= None,\n",
       "                                                formatters= searchresultstableformatters,\n",
       "                                                theme = \"bootstrap4\",\n",
       "                                                configuration= {\n",
       "                                                'rowHeight': 30,\n",
       "                                                'columnDefaults': {'headerSort': False,}})\n",
       "        self.applytablestyle()\n",
       "        self.table.on_click(self.actionhandler)\n",
       "        return self.table\n",
       "       \n",
       "    def applytablestyle(self):\n",
       "        self.table.style.apply(lambda s: [\"color: #03ba00\" for i in range(len(s))], subset=['Seeders'])\n",
       "        self.table.style.apply(lambda s: [\"color: #d40404\" for i in range(len(s))], subset=[\"Leechers\"])\n",
       "        self.table.style.apply(lambda s: [download_css for i in range(len(s))], subset=[' '])\n",
       "\n",
       "    def getresultcontrols(self):\n",
       "        sort_dropdown =  Dropdown(description= \"Sort\", value= self.sort, options = [('By Seeders', SEEDERSSORT), ('By Time', TIMESORT), ('By Size', SIZESORT)], layout= {}, style= searchsortdropdowns_style)\n",
       "        order_dropdown = Dropdown(description= \"Order\", value= self.order, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= {}, style= searchsortdropdowns_style)\n",
       "        sort_btn = Button(description= \"Sort\", layout= searchsortbtn_layout)\n",
       "        sort_btn.on_click(lambda btn: updatesearchresults(self, 1, sort= sort_dropdown.value, order= order_dropdown.value))\n",
       "        return (sort_dropdown, order_dropdown, sort_btn)\n",
       "    \n",
       "    def updateresults(self, page, sort= None, order= None):\n",
       "        if not sort:\n",
       "            sort = self.sort\n",
       "        if not order:\n",
       "            order = self.order\n",
       "        pagekey = getresultpagekey(sort, order, page)\n",
       "        if pagekey in self.resultpages:\n",
       "            self.results = self.resultpages[pagekey]\n",
       "            self.pageresultcount = len(self.results)\n",
       "            self.page = page\n",
       "            self.sort = sort\n",
       "            self.order = order\n",
       "            self.previouspage = page - 1\n",
       "            self.nextpage = page + 1 if page + 1 <= self.totalpages else 0\n",
       "        else:\n",
       "            search1337x(self.search, sort= sort, order= order, category= self.category, page= page, attrs= self.attrs, result= self)\n",
       "\n",
       "class AlreadyDownloadedDecision:\n",
       "    def __init__(self, action, newname = ''):\n",
       "        self.action = action\n",
       "        self.newname = newname\n",
       "    action = None\n",
       "    newname = None\n",
       "##\n",
       "\n",
       "def prepare_download(attrs: DownloadAttrs):\n",
       "    ''' - Checks for duplicate downloads.\n",
       "        - Rename the downloads properly based on download type.\n",
       "        - Sets up the saving pathes for the download.'''\n",
       "    logger.info(f\"Preparing {download_types[attrs.type_]} download info for: {attrs.name}\")\n",
       "    Type = attrs.type_\n",
       "    res= Prepare_Result(attrs)\n",
       "    searchresult = None\n",
       "    if Type == MOVIE:\n",
       "        save_name = name_movie(attrs.name)\n",
       "        save_path = config.movies_path\n",
       "        searchresult = movie_exists(save_name)\n",
       "        if (searchresult[\"foundname\"]):\n",
       "            save_name = searchresult[\"foundname\"]\n",
       "    elif Type == SHOW:\n",
       "        save_name = name_show(attrs.name)\n",
       "        searchresult = show_exists(save_name)\n",
       "        save_path = config.tv_path\n",
       "        if searchresult['foundname']:\n",
       "            attrs.show = searchresult['foundname']\n",
       "            save_name = searchresult['foundname']\n",
       "        else:\n",
       "            attrs.show = save_name \n",
       "    elif Type == SEASON:\n",
       "        save_name = get_season(attrs.name)\n",
       "        show = name_show(attrs.name)\n",
       "        searchresult = season_exists(show, save_name) \n",
       "        if searchresult['foundshow']:\n",
       "            show = searchresult['foundshow']           \n",
       "        save_path = get_tvshow_path(show)\n",
       "        attrs.show = show\n",
       "        attrs.season = save_name\n",
       "    elif Type == EPISODE:\n",
       "        save_name = name_episode(attrs.name)\n",
       "        show = name_show(attrs.name)\n",
       "        season = get_season(attrs.name)\n",
       "        searchresult = episode_exists(show, season, save_name)        \n",
       "        if searchresult['foundshow']:\n",
       "            show = searchresult['foundshow']\n",
       "        save_path = get_season_path(show, season)\n",
       "        attrs.show = show\n",
       "        attrs.season = season\n",
       "        attrs.save_path = get_season_path(show, season)\n",
       "    else:\n",
       "        save_name = remove_ext(attrs.name)\n",
       "        if Type == SOFTWARE:\n",
       "            save_path = config.software_path\n",
       "        elif Type == GAMES:\n",
       "            save_path = config.games_path\n",
       "        else:\n",
       "            save_path = config.general_path\n",
       "        \n",
       "    if searchresult and searchresult['foundpath']:\n",
       "        res.exists = True\n",
       "        res.typestr = searchresult['type']\n",
       "        res.foundname = searchresult['foundname']\n",
       "        res.foundpath = searchresult['foundpath']\n",
       "        res.foundfile = searchresult['foundfile']\n",
       "        res.founddir = searchresult['founddir']\n",
       "        res.foundshow = searchresult['foundshow']\n",
       "        foundpath = searchresult['foundpath']\n",
       "        attrs.existing_savingdir = searchresult['founddir']\n",
       "        attrs.existing_path = foundpath\n",
       "\n",
       "    # includes renaming with attr.renamed_file \n",
       "    attrs.save_name = save_name\n",
       "    attrs.save_path = save_path\n",
       "    attrs.saving_dir_path =  attrs.save_path if Type == EPISODE else f'{attrs.save_path}/{attrs.save_name}'\n",
       "    if not(save_name and save_path and attrs.saving_dir_path):\n",
       "        raise(Exception(f\"Required values to add the download are missing.\\nsave_name: {save_name}\\nsave_path: {save_path}\\saving_dir_path: {attrs.saving_dir_path}\"))\n",
       "    attrs.readytodownload = True\n",
       "    logger.info(f\"Finished preparing download successfully.\\nDownload attributes: {getattrstr(attrs, filter_empty= True, add_line= True)}\")\n",
       "    return res\n",
       "\n",
       "## API / Add and manage download\n",
       "\n",
       "class AddResult():\n",
       "    attrs = None\n",
       "    handle = None\n",
       "    status = ADDSUCCUSS\n",
       "    awaiting_decision = False\n",
       "    errormessage = \"\"\n",
       "    succussmessage = \"\"\n",
       "    name = \"\"\n",
       "    savename = \"\"\n",
       "    size = 0\n",
       "    backuppath = \"\"\n",
       "    savepath = \"\"\n",
       "    hash = \"\"\n",
       "    selectedfiles_count = \"\"\n",
       "    files: list[DownloadFile] = None\n",
       "    filetable = None\n",
       "    filetableoutput: Output = None\n",
       "    selectintervals_button = None\n",
       "    selectall_button = None\n",
       "    sizehtml: HTML = None\n",
       "    selectedfileshtml: HTML = None\n",
       "    hasmetadata = False\n",
       "\n",
       "class Prepare_Result:\n",
       "    def __init__(self, attrs, exists= False, type_= 'general', foundname= '', foundpath= '', foundshow= '', foundfile= '', founddir= ''):\n",
       "        self.attrs = attrs\n",
       "        self.exists = exists\n",
       "        self.typestr     = type_ \n",
       "        self.foundname = foundname \n",
       "        self.foundpath = foundpath \n",
       "        self.foundshow = foundshow \n",
       "        self.foundfile = foundfile \n",
       "        self.founddir  = founddir  \n",
       "    attrs = None\n",
       "    exists = False\n",
       "    typestr = 'general'\n",
       "    foundname = ''\n",
       "    foundpath = ''\n",
       "    foundshow = ''\n",
       "    foundfile = ''\n",
       "    founddir  = ''\n",
       "\n",
       "def get_magnet_name(magnet):\n",
       "    return urllib.parse.unquote(magnet.split(\"dn=\")[1].split(\"&tr=\")[0], encoding='utf-8', errors='replace').replace('+',\".\")\n",
       "\n",
       "def add_local_files(path= '.', files = set(), attrs: DownloadAttrs = None):\n",
       "    if not attrs:\n",
       "      attrs = DownloadAttrs()\n",
       "    result = AddResult()\n",
       "    pathinvalid =  path != \".\" and not os.path.isdir(path) and not files\n",
       "    if os.path.isfile(path):\n",
       "        files= {path}\n",
       "    elif pathinvalid:\n",
       "        result.status = ADDERROR\n",
       "        result.errormessage = f\"Path {path} isn't a directory or a file.\"\n",
       "        logger.error(result.errormessage)\n",
       "        return result\n",
       "    files = files if files else next(os.walk(path))[2]\n",
       "    for file in files:\n",
       "        attrs = attrs.copy()\n",
       "        attrs.torfile = file\n",
       "        attrs.add_source = LOCALFILE_ADDSOURCE\n",
       "        splited = os.path.splitext(file)\n",
       "        if splited[1] == \".torrent\":\n",
       "            logger.info(f\"Found a file to download: {file}\")\n",
       "            return add_download(attrs) # add multi file isn't correct\n",
       "\n",
       "def get_adddownload_error(result: AddResult, message):\n",
       "    logger.error(message)\n",
       "    result.status = ADDERROR\n",
       "    result.errormessage = message\n",
       "    return result\n",
       "\n",
       "def add_download(attrs: DownloadAttrs): \n",
       "    if not (attrs.add_source == LOCALFILE_ADDSOURCE or attrs.add_source == MAGNET_ADDSOURCE):\n",
       "        raise(\"add_source should be LOCALFILE_ADDSOURCE or MAGNET_ADDSOURCE\")\n",
       "    result = AddResult() \n",
       "    result.attrs = attrs\n",
       "    appstate.addresults.append(result)  \n",
       "    if attrs.add_source == MAGNET_ADDSOURCE and not attrs.magnet:\n",
       "        return get_adddownload_error(result, f\"Download magnet is empty. {attrs.name}\")\n",
       "    if attrs.add_source == LOCALFILE_ADDSOURCE and (not attrs.torfile or not os.path.isfile(attrs.torfile)):\n",
       "        return get_adddownload_error(result, f\"Tor file path is empty, or file doesn't exists {attrs.name}\")\n",
       "    try:\n",
       "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
       "            # RuntimeError: expected value (list, dict, int or string) in bencoded string [bdecode:4]. Happens with invalid tor files.\n",
       "            ti = lt.torrent_info(attrs.torfile)\n",
       "            infohash_sha1 = ti.info_hash()\n",
       "            attrs.name = ti.name()\n",
       "            if not ti.is_valid():\n",
       "                return get_adddownload_error(result, f\"Invalid torrent: {attrs.name}\")\n",
       "            result.selectedfiles_count = ti.num_files()\n",
       "            params = {\"save_path\": temp_save, \"ti\": ti}\n",
       "        else:\n",
       "            attrs.name = get_magnet_name(attrs.magnet)\n",
       "            params = lt.parse_magnet_uri(attrs.magnet)\n",
       "            params.save_path = temp_save\n",
       "            infohash_sha1 = params.info_hash\n",
       "        logger.info(f\"Adding download: {attrs.name} with {attrs.add_source}.\")\n",
       "        if not attrs.readytodownload: \n",
       "            prep: Prepare_Result = prepare_download(attrs)\n",
       "            if prep.exists:\n",
       "                result.awaiting_decision = True\n",
       "                result.status = ADDPENDING\n",
       "                already_downloaded_decision_controls(prep)\n",
       "                return result\n",
       "        sha1keystr = str(infohash_sha1)\n",
       "        result.name = attrs.name\n",
       "        result.files = [] \n",
       "        logger.info(f\"Download info: {attrs.name}\\nHash: {sha1keystr}\")\n",
       "        if sha1keystr in downloads_dict:\n",
       "            return get_adddownload_error(result, f\"{attrs.name} is already added.\")\n",
       "        handlecheck = ses.find_torrent(infohash_sha1)\n",
       "        if handlecheck.is_valid():\n",
       "            ses.remove_torrent(handlecheck)\n",
       "        handle: lt.torrent_handle = ses.add_torrent(params)\n",
       "        handle.name = attrs.name\n",
       "        if not handle.is_valid():\n",
       "            return get_adddownload_error(result, f\"Invalid torrent {attrs.name}\")\n",
       "        result.handle = handle\n",
       "        result.hash = sha1keystr\n",
       "        result.savepath = attrs.save_path\n",
       "        result.savename = attrs.save_name\n",
       "        attrs.hash = sha1keystr\n",
       "        handle.attrs = attrs\n",
       "        handle.progress = 0.0\n",
       "        downloads_dict[sha1keystr] = handle\n",
       "        add_trackers(handle)\n",
       "        torrentfile = handle.torrent_file()\n",
       "        if torrentfile:\n",
       "            handle.name = attrs.name = torrentfile.name()\n",
       "            set_download_filtered_files(result)\n",
       "            handle.attrs.hasmetadata = True\n",
       "            result.hasmetadata = True\n",
       "        else:\n",
       "            handle.attrs.hasmetadata = False\n",
       "            result.hasmetadata = False\n",
       "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
       "            cmd = f'mv \"{attrs.torfile}\" \"{added_path}\"'\n",
       "            !$cmd\n",
       "        result.status = ADDSUCCUSS\n",
       "        result.succussmessage = \"Added Successfully \" + attrs.name\n",
       "        logger.info(f\"{attrs.name} is added succussfully. Save name: {attrs.save_name}\")\n",
       "        return result\n",
       "    \n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "        updatestatushtml('An error happend while adding download.', ERROR_EVENT)\n",
       "        return get_adddownload_error(result, f\"Download wasn't added {attrs.name}\")\n",
       "\n",
       "def add_hash_download(hash, attrs: DownloadAttrs):\n",
       "    download_link = f\"https://itorrents.org/torrent/{hash}.torrent\"\n",
       "    return add_tor_url(download_link, attrs)\n",
       "\n",
       "def add_tor_url(url, attrs: DownloadAttrs):\n",
       "    filename = f\"/content/f{nowstr()}\"\n",
       "    cmd = f'wget \"{url}\" -O \"{filename}\" {NULL_STREAM}'\n",
       "    !$cmd\n",
       "    attrs.torfile = filename\n",
       "    attrs.add_source = LOCALFILE_ADDSOURCE\n",
       "    return add_download(attrs)\n",
       "\n",
       "def set_download_filtered_files(result: AddResult): \n",
       "    handle = result.handle\n",
       "    status = handle.status()\n",
       "    files = result.files\n",
       "    handle.attrs.full_size = status.total_wanted\n",
       "    handle.full_size = status.total_wanted\n",
       "    handle.selectedfilenames = []\n",
       "    logger.info(f\"Filtering download files for: {handle.name}.\")\n",
       "    totalfiles = selectedfilescount = total_download = 0\n",
       "    tor_file = handle.torrent_file()\n",
       "    if tor_file:\n",
       "        handle.attrs.hasmetadata = True\n",
       "        allfiles = tor_file.files()\n",
       "        total_download = 0\n",
       "        totalfiles = allfiles.num_files()\n",
       "        selectedfilescount = 0\n",
       "        mediatype = result.attrs.type_ == MOVIE or result.attrs.type_ == TV or result.attrs.type_ == SEASON or result.attrs.type_ == EPISODE\n",
       "        for i in range(totalfiles):\n",
       "            file = DownloadFile(i, allfiles.file_name(i), allfiles.file_size(i))\n",
       "            if mediatype and any(contains(file.name, check) for check in skip_list):\n",
       "                logger.info(f\"{allfiles.file_name(i)} is filtered.\")\n",
       "                handle.file_priority(i,0)\n",
       "                file.selected = False\n",
       "            else:\n",
       "                selectedfilescount += 1\n",
       "                handle.file_priority(i,6)\n",
       "                total_download += file.size\n",
       "                file.selected = True\n",
       "                handle.selectedfilenames.append(file.name)\n",
       "            files.append(file)\n",
       "    else:\n",
       "        logger.info(handle.name + \" has no metadata.\")\n",
       "        handle.attrs.hasmetadata = False\n",
       "    result.size = total_download\n",
       "    result.selectedfiles_count = selectedfilescount\n",
       "    handle.selected_files_count = selectedfilescount\n",
       "    handle.attrs.download_size = total_download\n",
       "    handle.attrs.allfiles = totalfiles\n",
       "    handle.attrs.selectedfilescount = selectedfilescount\n",
       "    handle.attrs.selectedfilenames = handle.selectedfilenames\n",
       "    handle.attrs.files = files\n",
       "\n",
       "def selectdownloadfiles(handle, files):\n",
       "    if not handle:\n",
       "        return\n",
       "    totaldownload = 0\n",
       "    select_files_count = 0\n",
       "    handle.selectedfilenames.clear()\n",
       "    for file in files:\n",
       "        if file.selected:\n",
       "            handle.file_priority(file.index, 6)\n",
       "            handle.selectedfilenames.append(file.name)\n",
       "            totaldownload += file.size\n",
       "            select_files_count += 1\n",
       "        else:\n",
       "            handle.file_priority(file.index, 0)\n",
       "    handle.total_download = totaldownload\n",
       "    handle.selected_files_count = select_files_count\n",
       "    return True\n",
       " \n",
       "#### API / IMDB \n",
       "    \n",
       "def searchIMDB(imdbparams: IMDBParams, page= 1, perpage= 40, result: IMDBResult= None):\n",
       "    if page < 1: page = 1\n",
       "    imdbgroupsandlabels = \"\"\n",
       "    if imdbparams.top250:\n",
       "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_TOP_250 + \",\"\n",
       "    if imdbparams.top1000:\n",
       "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_TOP_1000 + \",\"\n",
       "    if imdbparams.oscarwinner:\n",
       "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_OSCAR_WINNER + \",\"\n",
       "    if imdbparams.bestpicturewinner:\n",
       "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_BEST_PICTURE_WINNER + \",\"\n",
       "    if imdbparams.bestdirectorwinner: \n",
       "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_BEST_DIRECTOR_WINNER \n",
       "\n",
       "    lists = ''\n",
       "    if imdbparams.inlists: lists = imdbparams.inlists\n",
       "    if imdbparams.notinlists:\n",
       "        lists = (lists + \",\" if lists else lists) + IMDB_EXCULDE_MARK + imdbparams.notinlists.replace(',', ',' + IMDB_EXCULDE_MARK) \n",
       "    if imdbparams.englishonly: \n",
       "        lists = (lists + \",\" if lists else lists) + IMDB_EXCULDE_MARK + config.international_titles_list + \",\" + IMDB_EXCULDE_MARK \\\n",
       "            + config.indian_titles_list + \",\" + IMDB_EXCULDE_MARK + config.animation_titles_list + \"&languages=en\"\n",
       "    else:\n",
       "        if imdbparams.internationaltitles: \n",
       "            lists = (lists + \",\" if lists else lists) + config.international_titles_list \n",
       "        if imdbparams.indiantitles: \n",
       "            lists = (lists + \",\" if lists else lists) + config.indian_titles_list\n",
       "        if imdbparams.animationtitles: \n",
       "            lists = (lists + \",\" if lists else lists) + config.animation_titles_list \n",
       "    \n",
       "    sortandorder = imdbparams.imdbsort\n",
       "    if imdbparams.imdborder == ASCORDER:   \n",
       "        sortandorder = sortandorder + \",asc\"\n",
       "    else:   sortandorder = sortandorder + \",desc\" \n",
       "    releasedates = f\"&release_date={imdbparams.startdate},{imdbparams.enddate}\" if imdbparams.startdate or imdbparams.enddate else ''\n",
       "    ratings = f\"&user_rating={imdbparams.minrating if imdbparams.minrating else ''},{imdbparams.maxrating if imdbparams.maxrating else ''}\" if imdbparams.minrating or imdbparams.maxrating else ''\n",
       "    votes = f\"&num_votes={imdbparams.minvotes if imdbparams.minvotes else ''},{imdbparams.maxvotes if imdbparams.maxvotes else ''}\" if imdbparams.minvotes or imdbparams.maxvotes else ''\n",
       "    runtime = f\"&runtime={imdbparams.minruntime if imdbparams.minruntime else ''},{imdbparams.maxruntime if imdbparams.maxruntime else ''}\" if imdbparams.minruntime or imdbparams.maxruntime else ''\n",
       "    userwatched = '' # \"&my_ratings=exclude\" if params.filterwatched else ''\n",
       "    pagestr= f\"start={1+((page-1)*perpage)}\"\n",
       "    url = f'{IMDB_BASE}/search/title/?title={imdbparams.keyword}&title_type={imdbparams.titletype}{releasedates}{ratings}{votes}{runtime}{userwatched}&lists={lists}&groups={imdbgroupsandlabels}&sort={sortandorder}&view=advanced&count={perpage}&{pagestr}'\n",
       "    if not result:\n",
       "        result = IMDBResult(search= imdbparams.keyword, imdbparams= imdbparams, url= url, sort=imdbparams.imdbsort,\n",
       "                            order= imdbparams.imdborder, attrs= imdbparams.attrs)\n",
       "        appstate.searchresults.append(result)\n",
       "    response = requests.get(url, headers = {\"Accept-Language\": \"en-US\"})\n",
       "    result.currentpageurl = url\n",
       "    result.page = page\n",
       "    result.sort = imdbparams.imdbsort\n",
       "    result.order = imdbparams.imdborder\n",
       "    result.request = response \n",
       "    if response.status_code == 200:\n",
       "        logger.info(\"\\n IMDB Search Done Successfully.\\n\")\n",
       "        soup = Soup(response.text,'html.parser')    \n",
       "        main = soup.find(\"div\", id= \"main\")\n",
       "        if not main :\n",
       "            logger.error(\"AdvancedIMDBSearch: Error: An error occured while performing the web scrapping.\")\n",
       "            return\n",
       "        countText = main.select_one(\"div.nav > div.desc > span\").text\n",
       "        countSearch = imdbcount_pt.search(countText)\n",
       "        if countSearch:\n",
       "            result.resultscount = int(countSearch.group())\n",
       "            result.totalpages = ceil(result.resultscount/perpage)\n",
       "            result.nextpage = page + 1 if page + 1 <= result.totalpages else 0  \n",
       "            result.previouspage = page - 1  \n",
       "        else:\n",
       "            result.previouspage = 0\n",
       "            result.nextpage = 0\n",
       "            result.totalpages = 1\n",
       "            \n",
       "        titles: list[IMDBTitle]= []\n",
       "        downloaded: list[IMDBTitle]= []\n",
       "        watched: list[IMDBTitle] = []\n",
       "        allitems = main.findAll(class_=\"lister-item\")\n",
       "        for item in allitems:\n",
       "            try:\n",
       "                title_tag  = item.find(class_=\"lister-item-header\").a\n",
       "                year_text  = item.find(class_=\"lister-item-year\").text\n",
       "                title_link = process_external_link(title_tag, year_text, IMDB_BASE)\n",
       "                title_text = find_title(title_tag.text, year_text)\n",
       "                runtime    = item.find(class_=\"runtime\")\n",
       "                rating     = item.find(class_=\"ratings-imdb-rating\")[\"data-value\"]\n",
       "                votes      = item.find(\"span\", {\"name\": \"nv\"}).text.strip()\n",
       "                if runtime: runtime = runtime.text.strip()\n",
       "                else: runtime = \"\"\n",
       "                genres = item.find(class_=\"genre\")\n",
       "                if genres: genres = genres.text.strip()\n",
       "                else: genres = \"\"\n",
       "                ppl = item.select_one(\"div.lister-item-content > p:nth-child(5)\")\n",
       "                pplstr = str(ppl).replace('\\n', '')\n",
       "                search = stars_pt.search(pplstr)\n",
       "                stars = search.group().replace('<a href=\"', f'<a {linkhtmlstr} href=\"{IMDB_BASE}') if search else \"\"\n",
       "                search = director_pt.search(pplstr)\n",
       "                directors = search.group().replace('<a href=\"', f'<a {linkhtmlstr} href=\"{IMDB_BASE}') if search else \"\"\n",
       "                title= IMDBTitle(title_text= title_text, title_link= title_link, runtime= runtime, rating= rating, votes= votes, genres= genres, directors= directors, stars= stars)\n",
       "                if title_text in config.watched_movies_list:\n",
       "                    title.watched = True\n",
       "                    watched.append(title)\n",
       "                if movie_exists(title_text)[\"foundpath\"]:\n",
       "                    downloaded.append(title)\n",
       "                    title.downloaded= True\n",
       "                    if not imdbparams.filterdownloaded:\n",
       "                        titles.append(title) \n",
       "                else:\n",
       "                    titles.append(title)\n",
       "                logger.info(f\"Scrapped IMDB title {title_link}\")\n",
       "            except:\n",
       "                logger.error(ex())\n",
       "                continue       \n",
       "        result.results = titles\n",
       "        result.resultpages[getresultpagekey(imdbparams.imdbsort, imdbparams.imdborder, page)] = titles\n",
       "        result.watchedtitles = watched\n",
       "        result.watchedtitlespages[page] = watched\n",
       "        result.downloadedtitles = downloaded\n",
       "        result.downloadedtitlespages[page] = downloaded\n",
       "        result.pageresultcount = len(titles)\n",
       "        result.downloadedcount = len(downloaded)\n",
       "        result.watchedcount = len(watched)\n",
       "        result.status = SUCCUSS\n",
       "    else:\n",
       "        result.error = f\"AdvancedIMDBSearch: Error accessing the web page. Code error: {response.status_code}\"\n",
       "        logger.error(result.error)\n",
       "        result.status = FAIL\n",
       "    logger.release()\n",
       "    return result\n",
       "\n",
       "#### API / Search \n",
       "\n",
       "requests_header = {\"Accept-Language\": \"en-US\", 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'}\n",
       "\n",
       "def getsitesort(sort, order, site):\n",
       "    if site == X1337X:\n",
       "        sort1337x = X1337X_SEEDERS\n",
       "        if sort == TIMESORT:\n",
       "            if order == DESCORDER:\n",
       "                sort1337x = X1337X_TIME_DESC\n",
       "            else:\n",
       "                sort1337x = X1337X_TIME_ASC\n",
       "        elif sort == SIZESORT:\n",
       "            if order == DESCORDER:\n",
       "                sort1337x = X1337X_SIZE_DESC\n",
       "            else:\n",
       "                sort1337x = X1337X_SIZE_ASC\n",
       "        return sort1337x\n",
       "\n",
       "def getsitecategory(category, site):\n",
       "    if site == X1337X:\n",
       "        if category == TVCATEGORY_TD:\n",
       "            return X1337X_TV\n",
       "        if category == MOVIESCATEGORY_TD:\n",
       "            return X1337X_MOVIES \n",
       "        if category == APPSCATEGORY_TD:\n",
       "            return X1337X_APPS\n",
       "        if category == GAMESCATEGORY_TD:\n",
       "            return X1337X_GAMES  \n",
       "    return ALLCATEGORIES_TD\n",
       "\n",
       "def build1337xUrl(search, sort= SEEDERSSORT, order= DESCORDER, category = \"\", page = 1):\n",
       "    l337xsort = getsitesort(sort, order, X1337X)\n",
       "    search_s = search.replace(\"'\", \" \").replace(\" \",\"%20\")\n",
       "    parameters = f\"/sort-category-search/{search_s}/{category}/{l337xsort}/{page}/\" if category else f\"/sort-search/{search_s}/{l337xsort}/{page}/\"\n",
       "    return X1337XPROXEY_BASE + parameters\n",
       "\n",
       "def search1337x(search, sort= SEEDERSSORT, order= DESCORDER, category = \"\", page = 1, attrs = None, result: SearchResult= None):\n",
       "    if page < 1: page = 1\n",
       "    url = build1337xUrl(search, sort, order, category, page)\n",
       "    logger.info(f\"Scraping 1337x search for: {search} Page: {page}\\nURL: {url}.\")\n",
       "    download_state = \"downloaded\" if check_download(attrs.type_, search) else \"not downloaded\"\n",
       "    logger.info(f\"{search} is {download_state}.\")\n",
       "    request = requests.get(url, headers= requests_header)\n",
       "    if not attrs:\n",
       "        attrs = DownloadAttrs()\n",
       "    if not result:    \n",
       "        result = SearchResult(search= search, site= X1337X, category= ALLCATEGORIES_TD, attrs= attrs, url= url)\n",
       "        appstate.searchresults.append(result)    \n",
       "    if request.status_code == 200 :\n",
       "        soup = Soup(request.text, 'html.parser' )\n",
       "        pagination = soup.find(attrs={\"class\":\"pagination\"})\n",
       "        if not pagination:\n",
       "            previouspage = 0\n",
       "            nextpage = 0\n",
       "            totalpages = 1\n",
       "        else:\n",
       "            lastpgelement = pagination.find(attrs= {'class':'last'})\n",
       "            if lastpgelement:\n",
       "                lastpg = lastpgelement.a\n",
       "                totalpages = int(l337xpages_pt.search(lastpg.get('href')).group())\n",
       "            else:\n",
       "                totalpages = page\n",
       "            previouspage = page - 1\n",
       "            nextpage = page + 1 if page + 1 <= totalpages else 0\n",
       "        result.page = page\n",
       "        result.previouspage = previouspage\n",
       "        result.nextpage = nextpage\n",
       "        result.totalpages = totalpages\n",
       "        result.sort = sort\n",
       "        result.order = order\n",
       "        result.currentpageurl = url\n",
       "        main_element = soup.find(\"tbody\")\n",
       "        if main_element is None:\n",
       "            logger.warning(\"\\nResults table is null search.\\n\")\n",
       "            result.status = FAIL\n",
       "            result.result = \"Null search. main element not found.\"\n",
       "            result.request = request\n",
       "        else:\n",
       "            result.status = SUCCUSS\n",
       "            all_res = main_element.findAll(\"tr\")\n",
       "            resulturl = size = uploader = seeders = leechers = \"\"\n",
       "            results = [] \n",
       "            if all_res:\n",
       "                logger.info(f\"Results found: {len(all_res)}.\")\n",
       "                for i in  range(len(all_res)):\n",
       "                    alldata: list[Tag] = all_res[i].findAll(\"td\")\n",
       "                    resulturl = process_external_link(alldata[0].findAll(\"a\")[1], base= X1337X_BASE)\n",
       "                    size = alldata[4].contents[0]\n",
       "                    date = alldata[3].text\n",
       "                    seeders = alldata[1].text\n",
       "                    leechers = alldata[2].text\n",
       "                    uploader = alldata[5].a.text\n",
       "                    href = X1337XPROXEY_BASE + alldata[0].findAll(\"a\")[1]['href']\n",
       "                    res = DownloadResult(resulturl= resulturl, size= size, date= date, seeders= seeders, leechers= leechers, uploader= uploader, href= href)\n",
       "                    results.append(res)\n",
       "                result.resultcount = len(results)\n",
       "                result.results = results\n",
       "                result.resultpages[getresultpagekey(sort, order, page)] = results\n",
       "            else:\n",
       "                logger.info(f\"No results found for {search}.\")\n",
       "                result.status = FAIL\n",
       "                result.result = f\"No results found for {search}.\"\n",
       "                result.request = request\n",
       "    else:\n",
       "        logger.error(f\"An error occured while trying to access 1337x.com  status: {request.status_code}.\")\n",
       "    logger.release()\n",
       "    return result\n",
       "\n",
       "def download1337x(result: DownloadResult, attrs: DownloadAttrs):\n",
       "    logger.info(f'Adding download {attrs.name} from search.')\n",
       "    maintabs.selected_index = appstate.tab_indices[ADD_TAB]\n",
       "    switchview(nav[ADD_TAB], getloadingview(f'Adding download from search results.'), temp= True)\n",
       "    downloadpage = requests.get(result.href)\n",
       "    soup = Soup(downloadpage.text, \"html.parser\")\n",
       "    attrs.site_source = X1337X  \n",
       "    hash = soup.find(class_=\"infohash-box\").span.text.strip()  \n",
       "    if not hash:\n",
       "        logger.error(\"Hash value couldn't be found.\")\n",
       "        switchview(nav[ADD_TAB])\n",
       "    else:\n",
       "        addresult =  add_hash_download(hash, attrs)\n",
       "        if not addresult.awaiting_decision:\n",
       "            process_adddownload_result(addresult)\n",
       "    logger.release()\n",
       "\n",
       "def search_process(site, search, attrs, category= '', sort= SEEDERSSORT, order= DESCORDER, page= 1, source= SEARCH_TAB):\n",
       "    logger.info(f\"Searching for {search} in sites {site}\")\n",
       "    category = getsitecategory(category, site)\n",
       "    if site == X1337X:\n",
       "        result = search1337x(search, sort= sort, order= order, category= category, page= page, attrs= attrs)\n",
       "    if result:\n",
       "        searchresultview = getsearchresultview(result)\n",
       "        viewstatus = False if source == SEARCH_TAB else True\n",
       "        switchview(nav[SEARCH_TAB], searchresultview, temp= viewstatus)\n",
       "\n",
       "#### API / Download files utils TODO move to side setup\n",
       "\n",
       "def move_download_old_files(attrs: DownloadAttrs): #disabled temporarly \n",
       "    logger.info(f'Cleaning distination for: {attrs.save_name}')\n",
       "    attrs.old_files_dirs = set()\n",
       "    delstr = '.replaced-' + nowstr()\n",
       "    if attrs.type_ == TV or attrs.type_ == SEASON or attrs.type_ == EPISODE:\n",
       "        for diritem in attrs.downloaded_diritems: #diritem is tuple of a dir and its content\n",
       "            season = get_season(diritem[0])\n",
       "            if season:\n",
       "                for filename in diritem[1]:\n",
       "                    lookup1 = episode_exists(attrs.show, season, filename)\n",
       "                    if lookup1['foundpath']:\n",
       "                        oldfilepath = lookup1['foundpath']\n",
       "                        oldfiletemppath = f\"{os.path.dirname(oldfilepath)}/{delstr}\"\n",
       "                        os.makedirs(oldfiletemppath, exist_ok=True)\n",
       "                        file_command(\"mv\", oldfilepath, oldfiletemppath)\n",
       "                        attrs.old_files_dirs.add(oldfiletemppath)\n",
       "                        logger.info(f'Old files found: {lookup1[\"foundname\"]}')\n",
       "\n",
       "    elif attrs.type_ == MOVIE:\n",
       "        if attrs.existing_path and os.path.isdir(attrs.existing_path):\n",
       "            oldfiletemppath = os.path.normpath(f\"{attrs.existing_path}/{delstr}\")\n",
       "            os.makedirs(oldfiletemppath, exist_ok=True)    \n",
       "            file_command(\"mv\", f\"{attrs.existing_path}/*\", oldfiletemppath)\n",
       "            attrs.old_files_dirs.add(oldfiletemppath)\n",
       "    logger.info('Cleaning distination done.')\n",
       "    return\n",
       "\n",
       "def verify_saving_download(attrs: DownloadAttrs):\n",
       "    fails = []\n",
       "    logger.info(f\"Verifying downloaded files for: {DownloadAttrs.save_name}\\nTotal downloaded: {data_str(attrs.total_downloaded)}\")\n",
       "    for i in range(len(attrs.verify_download)):\n",
       "        item = attrs.verify_download[i]\n",
       "        s1 = has_size(item[0], False)\n",
       "        s2 = has_size(item[1], False)\n",
       "        logger.info(f\"Verifying: ({'Does not exist.' if s1 == -1 else s1}) {item[0]}\\n       To: ({'Does not exist.' if s2 == -1 else s2}) {item[1]}\")\n",
       "        if s2 != -1 and abs(s2-s1) <= size_limit:\n",
       "            logger.info('Successfully transfered.')\n",
       "        else:\n",
       "            logger.info('Not transfered.')\n",
       "            fails.append(item[1])\n",
       "    if len(fails) == 0:\n",
       "        logger.info(f\"Successful transfer verification.\")\n",
       "        return True\n",
       "    else:\n",
       "        logger.error(f\"Verification failed.\\nFailed items: {len(fails)}\\n{list_lines(fails, str = True)}\")\n",
       "    return False\n",
       "\n",
       "def revert_download_file_transfer(attrs: DownloadAttrs):\n",
       "    logger.info('Reverting transfered files.')\n",
       "    for replacedpath in attrs.old_files_dirs:\n",
       "        replacedpath = os.path.normpath(replacedpath)\n",
       "        file_command(\"mv\", f\"{replacedpath}/*\", os.path.dirname(replacedpath))\n",
       "        file_command(\"rm\", replacedpath, options_str= \"-r\")\n",
       "    return\n",
       "\n",
       "def prepare_download_file_transfer(attrs: DownloadAttrs, donesavingpath):    # Matches download files with the target pathes for verification \n",
       "    logger.info(f\"Preparing transfer for: {donesavingpath}\\nSave dir: {attrs.saving_dir_path}\\nFile transfer verification items:\")\n",
       "    attrs.verify_download = []\n",
       "    total_size = 0 \n",
       "    diritems_str = \"\"\n",
       "    for diritem in attrs.downloaded_diritems:\n",
       "        dirbase = f\"/{diritem[0]}\" if diritem[0] else ''\n",
       "        donedirpath = donesavingpath + dirbase\n",
       "        savingtargetdirpath = attrs.saving_dir_path + dirbase\n",
       "        diritems_str += f\"In dir:  {donedirpath}/\\n\"\n",
       "        for filename in diritem[1]:\n",
       "            donefilepath = f\"{donedirpath}/{filename}\"\n",
       "            targetfilepath = f\"{savingtargetdirpath}/{filename}\"\n",
       "            attrs.verify_download.append((donefilepath, targetfilepath))\n",
       "            filesize = pathsize(donefilepath)\n",
       "            sizestr = data_str(filesize)\n",
       "            total_size += filesize\n",
       "            diritems_str += f'{sizestr} {donefilepath}\\n{(len(sizestr) + 1)*\" \"}{targetfilepath}\\n'\n",
       "    logger.info(diritems_str)\n",
       "    attrs.total_downloaded = total_size \n",
       "\n",
       "def file_command(commandname, source, target= \"\", options_str= \"\", log_message= \"\", raise_error= False):\n",
       "    if log_message:\n",
       "        log_message = log_message + \"\\n\"\n",
       "    command = f'{commandname} {options_str + \" \" if options_str.strip() else \"\"}\"{source}\"'\n",
       "    target = target.strip()\n",
       "    if target:\n",
       "        command += f' \"{target}\"'\n",
       "    logger.info(f\"{log_message}Excuting command: {command}\")\n",
       "    output = !$command\n",
       "    if output:\n",
       "        logger.error(f\"An error found in command output:\\n{output}\")\n",
       "        if raise_error:\n",
       "            raise(Exception(output))\n",
       "    else:\n",
       "        logger.info(\"Execution successful.\")\n",
       "    return output\n",
       "\n",
       "def transfer_download_files(handle, keep_local_files= False):\n",
       "    handle.pause()\n",
       "    attrs: DownloadAttrs = handle.attrs\n",
       "    os.makedirs(attrs.save_path, exist_ok= True)\n",
       "    status = handle.status()\n",
       "    local_downloaded_path = f'{status.save_path}/{status.name}'\n",
       "    local_save_dir_path = status.save_path \n",
       "    local_done_dir_save_path = f\"{done_path}/{attrs.save_name}\"   # rename mode included\n",
       "    logger.info(f'Transfering files for: {status.name}\\nSave name: {attrs.save_name}')\n",
       "    try:\n",
       "        if os.path.exists(local_downloaded_path):\n",
       "            if not os.path.isdir(local_downloaded_path):          # move all dirless files here. Ensures that localsavingpath is a dir, not dirless file.\n",
       "                logger.info(f'The download doesnt have a directory\\nMoving download files into a directory with the same name.')\n",
       "                local_save_dir_path = status.save_path + \"/\" + attrs.save_name # test sthing \n",
       "                os.makedirs(local_save_dir_path, exist_ok= True)\n",
       "                files = handle.torrent_file().files()\n",
       "                for i in range(files.num_files()):\n",
       "                    file_path = status.save_path + \"/\" + files.file_path(i)\n",
       "                    file_command(\"mv\", file_path, local_save_dir_path, raise_error= True)\n",
       "                local_downloaded_path = local_save_dir_path\n",
       "            shave_download(handle, local_save_dir_path, local_downloaded_path)\n",
       "            clean_download(attrs, localsavingpath= local_downloaded_path)\n",
       "            file_command(\"mv\", local_downloaded_path, local_done_dir_save_path, log_message= \"Moving download_path to done path with the new name.\", raise_error= True)\n",
       "        else:\n",
       "            raise(Exception(f\"Download dir or file is missing {local_downloaded_path}\"))\n",
       "        if not attrs.save_name:\n",
       "            attrs.save_name = status.name\n",
       "            local_done_dir_save_path = local_done_dir_save_path + attrs.save_name \n",
       "        prepare_download_file_transfer(attrs, local_done_dir_save_path)  \n",
       "        if attrs.type_ == EPISODE and os.path.isdir(local_done_dir_save_path):\n",
       "            local_done_dir_save_path = f'{local_done_dir_save_path}/' \n",
       "        if os.path.exists(local_done_dir_save_path):\n",
       "            if attrs.existing_mode == REPLACE_DOWNLOAD:\n",
       "                move_download_old_files(attrs)\n",
       "            option_str = \"--size-only -r\" if attrs.existing_mode == MERGE_DOWNLOAD else '-r'    # -I for replacing files \n",
       "            output = file_command(\"rsync\", local_done_dir_save_path, attrs.save_path, options_str= option_str)\n",
       "            if not output:\n",
       "                files_transfer_verification = verify_saving_download(attrs)   \n",
       "            if files_transfer_verification:\n",
       "                if dev or not keep_local_files:\n",
       "                    file_command(\"rm\", local_done_dir_save_path, options_str= \"-r\", log_message= \"\")               \n",
       "                if attrs.uncomplete_source and os.path.exists(attrs.uncomplete_source):\n",
       "                    file_command(\"rm\", attrs.uncomplete_source, options_str= \"-r\", log_message= \"Deleting uncompleted source\" )\n",
       "                if attrs.existing_mode == REPLACE_DOWNLOAD: # TODO\n",
       "                    #info('Deleting replaced files.')\n",
       "                    #for oldfilepath in attrs.old_files: rm(oldfilepath, process_backup= attrs.backup) \n",
       "                    pass\n",
       "                logger.info(f'Done saving {attrs.save_name}.')\n",
       "            else:\n",
       "                logger.error(\"Transfer verification failed.\")\n",
       "                if attrs.existing_mode == REPLACE_DOWNLOAD:\n",
       "                    revert_download_file_transfer(attrs)\n",
       "        else:\n",
       "            raise(Exception(f\"donesavingpath doesn't exit. Files for: {attrs.save_name} were not transfered.\\n donesavingpath= {local_done_dir_save_path}\"))\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "    logger.release()\n",
       "\n",
       "def save_download_progress(handle, savepath):\n",
       "    status = handle.status()\n",
       "    name = status.name\n",
       "    logger.info(f\"Saving download progress for {name}\")\n",
       "    os.makedirs(savepath, exist_ok= True)\n",
       "    downloadpath = temp_save + \"/\" + name\n",
       "    output = file_command(\"rsync\", downloadpath, savepath, options_str= \"-r\")\n",
       "    if not output:\n",
       "        logger.info(f\"Done saving download progress for {name}.\")\n",
       "    logger.release()\n",
       "\n",
       "def load_uncompleted(path, type_, local = False):\n",
       "    (path, files, dirs) = next(os.walk(path))\n",
       "    content = filter_checks(dirs) + files\n",
       "    if content:\n",
       "        print(\" Choose a directory or a file to load:\")\n",
       "        for i in range(len(content)):\n",
       "            p00 = f\"{path}/{content[i]}\"\n",
       "            size = pathsize(p00, True)\n",
       "            print(\"   {}- {:<90}{}\".format(i+1, content[i], size))\n",
       "        print()\n",
       "        choice = input().lower()\n",
       "        if \"\" == choice or \" \" == choice or  \"q\" == choice or \"s\" == choice:\n",
       "            return\n",
       "        elif \",\" in choice:\n",
       "            choices = choice.split(\",\")\n",
       "        else:\n",
       "            choices = [choice]\n",
       "        for select in choices:\n",
       "            select = int(select) - 1\n",
       "            if select >= len(content) or select < 0 :\n",
       "                print(\"\\nThe choice is out of range.\\n\")\n",
       "            else:\n",
       "                name = content[select]\n",
       "                if not local:\n",
       "                    p0 = f\"{path}/{name}\"\n",
       "                    if content[select].endswith(\"@SAVE2\"):\n",
       "                        name = content[select].split(\"@SAVE2\")[0]\n",
       "                    p1 = f\"{temp_save}/{name}\"\n",
       "                    logger.info(f\"Loading uncompleted download: {content[select]} to {p1}\")\n",
       "                    print(\"Loading into {}\\n\".format(p1))\n",
       "                    !cp -r \"$p0\" \"$p1\"\n",
       "                    print(\"{0} is Loaded\\n\".format(content[select]))\n",
       "                    logger.info(f\"Uncompleted download: {content[select]} loaded to {p1}\")\n",
       "                attrs = DownloadAttrs(type_= type_, name = name)\n",
       "                r = resume_uncomplete_download(name) \n",
       "                if r == -2:\n",
       "                    break\n",
       "                print(\"\\n   ...................\\n          Done\\n\")\n",
       "    else:\n",
       "        logger.error(\"Uncomplete directory is empty.\")\n",
       "\n",
       "def resume_uncomplete_download(attrs):\n",
       "    logger.info(f\"Resuming download {attrs.name}\")\n",
       "    lookup = name_movie(attrs.name)\n",
       "    print(f\"Downloading: {lookup}\\nSelect a source:\\n 1 - 1337x\\n 2 - rarbg\\n\")\n",
       "    select = input().lower()\n",
       "    if select == \"s\" or select == \"\":\n",
       "        return -1\n",
       "    elif select == \"q\" or select == \" \":\n",
       "        return -2\n",
       "    elif select == \"1\":\n",
       "        attrs.site_source = X1337X\n",
       "        search_process(X1337X, search= lookup,  attrs= attrs)\n",
       "    return 0\n",
       "\n",
       "def pause_resume_session(b= None):\n",
       "    try:\n",
       "        paused = ses.is_paused()\n",
       "        if appstate.running or not paused:\n",
       "            ses.pause()\n",
       "            for i in range(len(active)):\n",
       "                #active[i].progress_bar.bar_style = 'warning'\n",
       "                active[i].control_btn.disabled = True\n",
       "            appstate.running = False\n",
       "            startpause_btn.description = \"Start\"\n",
       "            logger.info(f\"Session has been paused.\")\n",
       "        elif active or paused:\n",
       "            ses.resume()\n",
       "            for i in range(len(active)):\n",
       "                #if not active[i].paused: active[i].progress_bar.bar_style = 'info'\n",
       "                active[i].control_btn.disabled = False\n",
       "            appstate.running = True\n",
       "            startpause_btn.description = \"Pause\"\n",
       "            startmonitor()\n",
       "            logger.info(f\"Session has been resumed.\")\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "        updatestatushtml('An error happend while pausing session.', ERROR_EVENT)\n",
       "    logger.release()\n",
       "\n",
       "def pause_start_download(handle, btn):\n",
       "    paused = handle.status().paused\n",
       "    if paused or handle.paused:\n",
       "        with hidden_output:\n",
       "            handle.auto_managed(True)\n",
       "        handle.resume()\n",
       "        handle.paused = False\n",
       "        handle.progress_bar.bar_style = 'info'\n",
       "        btn.description = \"||\"\n",
       "        startmonitor()\n",
       "        logger.info(f\"Download '{handle.name}' has been resumed.\")\n",
       "    else:\n",
       "        with hidden_output:\n",
       "            handle.auto_managed(False)\n",
       "        handle.pause()\n",
       "        handle.paused = True\n",
       "        handle.progress_bar.bar_style = 'warning'\n",
       "        btn.description = \"▷\"\n",
       "        logger.info(f\"Download '{handle.name}' has been paused.\")\n",
       "\n",
       "def remove_download(downloadview):\n",
       "    stopmonitor()\n",
       "    try:\n",
       "        handle = downloadview.handle\n",
       "        remove_active_view(downloadview)        \n",
       "        status = handle.status()\n",
       "        handle.pause()\n",
       "        if handle in active:\n",
       "            active.remove(handle)\n",
       "        elif handle in completed:\n",
       "            completed.remove(handle)\n",
       "        ses.remove_torrent(handle)\n",
       "        del downloads_dict[handle.attrs.hash]\n",
       "\n",
       "        appstate.total_downloads -= 1\n",
       "        appstate.total_wanted -= status.total_wanted\n",
       "        if handle.done:\n",
       "            appstate.completed -= 1\n",
       "            appstate.completed_down -= status.total_wanted_done\n",
       "            appstate.completed_up -= status.total_upload\n",
       "        elif handle.dead:\n",
       "            appstate.deads -= 1\n",
       "\n",
       "        if not active:\n",
       "            update_download_stats_labels()\n",
       "        startmonitor()\n",
       "        logger.info(f'{handle.name} was removed succussfully.')\n",
       "    except Exception as e:\n",
       "        logger.error(f\"An error happened while removing {handle.name}\")\n",
       "        logger.error(ex())\n",
       "        updatestatushtml(\"An error happened while removing download.\", ERROR_EVENT)\n",
       "    logger.release()\n",
       "\n",
       "def already_downloaded_handler(userdecision: AlreadyDownloadedDecision, attrs: DownloadAttrs):\n",
       "    try:\n",
       "        attrs.existing_mode = userdecision.action\n",
       "        if userdecision.action == CANCEL_DOWNLOAD:\n",
       "            switchview(nav[ADD_TAB])\n",
       "            return False\n",
       "        if userdecision.action == RENAME_DOWNLOAD and userdecision.newname: \n",
       "            attrs.renamed_file = userdecision.newname\n",
       "        switchview(nav[ADD_TAB], getloadingview(f'Adding download with {attrs.add_source}'), temp= True)\n",
       "        process_adddownload_result(add_download(attrs))\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "    logger.release()\n",
       "\n",
       "def validateconfig():\n",
       "    return True\n",
       "\n",
       "def saveuploadedfiles():\n",
       "    os.makedirs('uploadedfiles', exist_ok= True)\n",
       "    files= set()\n",
       "    try:\n",
       "        for filename in addsource_file.value:\n",
       "            content= addsource_file.value[filename]['content']\n",
       "            filepath= f'/content/uploadedfiles/{filename}'\n",
       "            with open(filepath, 'wb') as savefile:\n",
       "                savefile.write(content)\n",
       "                files.add(filepath)\n",
       "    except Exception as e:\n",
       "        logger.error(e)\n",
       "        print(e)\n",
       "    return files\n",
       "\n",
       "def selectallfiles(files: list[DownloadFile]):\n",
       "    doselect = False\n",
       "    for file in files:\n",
       "        if not file.selected:\n",
       "            doselect = True\n",
       "            break\n",
       "    if doselect:\n",
       "        for file in files: file.selected = True\n",
       "    else:\n",
       "        for file in files: file.selected = False\n",
       "\n",
       "def getfileselectionwithstr(files: list[DownloadFile], selectionstr = \"\"):\n",
       "    if not selectionstr:    return False\n",
       "    includefiles = set()\n",
       "    excludefiles = set()\n",
       "    seasonintervals = set()\n",
       "    if ',' in selectionstr:\n",
       "        inputs = selectionstr.split(',')\n",
       "    else:\n",
       "        inputs = [selectionstr]   \n",
       "    try:\n",
       "        for inputitem in inputs:\n",
       "            inputitem = inputitem.strip()\n",
       "            if inputitem:\n",
       "                if inputitem[0].lower() == 's':\n",
       "                    lookup = season_pt0.search(inputitem)\n",
       "                    if lookup:\n",
       "                        if '-' in inputitem:\n",
       "                            inputrange = inputitem.split('-')\n",
       "                            lookup1 = season_number_pt.search(inputrange[0])\n",
       "                            start = lookup1.group() if lookup1 else ''\n",
       "                            lookup1 = season_number_pt.search(inputrange[1])\n",
       "                            end = lookup1.group() if lookup1 else ''\n",
       "                            if not (start or end): continue\n",
       "                            elif start and end:\n",
       "                                seasonintervals.update({f'({addseason:02})' for addseason in range(int(start), int(end)+1)})\n",
       "                            else:\n",
       "                                addseason = int(end) if end else int(start)\n",
       "                                seasonintervals.add(f\"({addseason:02})\")\n",
       "                        else:\n",
       "                            lookup1 = season_number_pt.search(inputitem)\n",
       "                            if lookup1: seasonintervals.add(f\"({int(lookup1.group()):02})\")                \n",
       "\n",
       "                elif inputitem.lower().startswith('n:'):\n",
       "                    inputitem = inputitem[2:]\n",
       "                    if '-' in inputitem:\n",
       "                        inputrange = inputitem.split('-')\n",
       "                        excludefiles.update(set(range(int(inputrange[0])-1, int(inputrange[1]))))\n",
       "                    else:   excludefiles.add(int(inputitem)-1)\n",
       "\n",
       "                else:\n",
       "                    if '-' in inputitem :\n",
       "                        inputrange = inputitem.split('-')\n",
       "                        includefiles.update(set(range(int(inputrange[0])-1, int(inputrange[1]))))          \n",
       "                    else:   includefiles.add(int(inputitem)-1)\n",
       "    except:     \n",
       "        logger.error(ex())\n",
       " \n",
       "    seasonselectionstr_pt =  re.compile(r\"\\b\" + f\"[Ss]({'|'.join(seasonintervals)})\" + r\"(?=[Ee]|\\s|\\.)\") if seasonintervals else None\n",
       "    includes = len(includefiles) >= 1 or bool(seasonselectionstr_pt)\n",
       "    excludes = len(excludefiles) >= 1 \n",
       "    logger.info(f\"Selecting files: Seasons {seasonintervals}, Include {includefiles}, Exclude {excludefiles}\")\n",
       "    for file in files:\n",
       "        inputitem = file.index\n",
       "        if excludes and (inputitem in excludefiles):\n",
       "            file.selected = False\n",
       "        elif includes:\n",
       "            if (seasonselectionstr_pt and seasonselectionstr_pt.search(file.name)) or (inputitem in includefiles):\n",
       "                file.selected = True\n",
       "            else:   file.selected = False\n",
       "    logger.release()\n",
       "\n",
       "def process_adddownload_result(result):\n",
       "    if result.status == ADDPENDING or result.awaiting_decision :\n",
       "        return\n",
       "    try:     \n",
       "        propertiesview =  VBox(layout= downloadproperties_layout)\n",
       "        propertiesview.add_class('curved-40')\n",
       "        propertiesview.name = \"Download Properties.\"\n",
       "        resultview = getaddinfosubview(result)\n",
       "        if result.status == ADDSUCCUSS: \n",
       "            logger.info('Getting result view and files.')\n",
       "            propertiesview.titleview = resultview.titleview\n",
       "            result.handle.propertiesview = propertiesview\n",
       "            propertiesview.children = (resultview, getfileselectionsubview(result))\n",
       "            appstate.total_downloads += 1\n",
       "            status = result.handle.status()\n",
       "            if status.total_wanted_done < 50000:\n",
       "                logger.info(f\"Dead download: {result.handle.name}\")\n",
       "                appstate.deads += 1\n",
       "                result.handle.dead = True\n",
       "            else:\n",
       "                logger.info(f\"Live download: {result.handle.name}\")\n",
       "                result.handle.dead = False\n",
       "            if result.hasmetadata:\n",
       "                setfilesandsizeinfoview(result)\n",
       "                setwantedbytes(result.handle)\n",
       "            else:\n",
       "                appstate.metacheckerthread = Thread(target= metadata_watcher, args= (result,))\n",
       "                appstate.metacheckerthread.start()\n",
       "\n",
       "            logger.info('Launching view')  \n",
       "            create_active_download_view(result.handle)\n",
       "            active.append(result.handle)\n",
       "            if not appstate.monitoralive or not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
       "                if ses.is_paused():\n",
       "                    logger.info(\"Resuming session\") \n",
       "                    ses.resume()\n",
       "                logger.info(\"Launching monitor\")\n",
       "                startmonitor()\n",
       "            updatestatushtml(result.succussmessage, SUCCUSS)\n",
       "        else:\n",
       "            propertiesview.children = (resultview,)\n",
       "        switchview(nav[ADD_TAB], propertiesview, remove_on_tab_change= True)\n",
       "        logger.release()\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "        updatestatushtml('An error happend while adding Download.', ERROR_EVENT)\n",
       "        logger.release()\n",
       "\n",
       "### UI API\n",
       "\n",
       "gethtmltitle = lambda text, titlenumber, style=\"\": f'<h{titlenumber} style=\"{style}; font-family: {FONTFAMILY_GLOBAL}\">{text}</h{titlenumber}>'\n",
       "\n",
       "def hideview(*objs):\n",
       "    for obj in objs:\n",
       "        obj.layout.display = 'none'\n",
       "    notify_widgets(objs)\n",
       "\n",
       "def showviews(*objs):\n",
       "    for obj in objs:\n",
       "        obj.layout.display = 'flex'\n",
       "\n",
       "def toggleviewstates(*objs):\n",
       "    for obj in objs:\n",
       "        if obj.layout.display == 'none':\n",
       "            obj.layout.display = 'flex'\n",
       "        else:\n",
       "            obj.layout.display = 'none'\n",
       "    notify_widgets(objs)\n",
       "\n",
       "def setviewelements(tab, container, initialview, backbtn, navtab):\n",
       "    tab.maincontainer = container\n",
       "    container.tabname = tab.name\n",
       "    container.back_button = backbtn\n",
       "    container.viewstack = [initialview]\n",
       "    backbtn.on_click(lambda b: switchview(container))\n",
       "    nav[navtab] = container\n",
       "\n",
       "def switchview(container, nextview= None, temp= False, allowback= True, remove_on_tab_change= False, expires= 0):\n",
       "    try:\n",
       "        if container == None:\n",
       "            logger.error(\"The sent container is None.\")\n",
       "            logger.release()\n",
       "            return\n",
       "        \n",
       "        if hasattr(container, 'viewstack'):\n",
       "            if nextview: \n",
       "                logger.info(f\"Switched view in container: {container.tabname.lower()}. Next view {nextview.name}.\")\n",
       "                if temp:\n",
       "                    nextview.temp = True\n",
       "                else:\n",
       "                    nextview.temp = False\n",
       "                    container.viewstack.append(nextview)\n",
       "                container.children = (nextview,)\n",
       "\n",
       "                if allowback:\n",
       "                    container.back_button.disabled = False\n",
       "                else:\n",
       "                    container.back_button.disabled = True\n",
       "                if remove_on_tab_change:\n",
       "                    appstate.navactions.append((switchview, (container,)))\n",
       "\n",
       "            elif len(container.viewstack) >= 1:\n",
       "                logger.info(f\"Switched view in container: {container.tabname.lower()} to back.\")\n",
       "                if len(container.viewstack) > 1 and not container.children[0].temp:\n",
       "                    container.viewstack.pop(-1)\n",
       "                    \n",
       "                container.children = (container.viewstack[-1],)\n",
       "                if len(container.viewstack) == 1:\n",
       "                    container.back_button.disabled = True\n",
       "        else:\n",
       "            logger.error(\"The container viewstack is undefined\")\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "\n",
       "def saveconfighandler(button):\n",
       "    switchview(config_vbox.maincontainer, getloadingview(f'Setting up requirments'), temp= True, allowback= False)\n",
       "    config.activedownloads = configview1r1v1activedownload_numeric.value\n",
       "    config.ftpenabled = configview1r1v2ftptoggle_checkbox.value\n",
       "    if config.ftpenabled:\n",
       "        config.ftphost = configview1r1v3ftphost_text.value \n",
       "        config.ftpuser = configview1r1v3ftpuser_text.value \n",
       "        config.ftppassword = configview1r1v3ftppass_text.value \n",
       "    if config.gdriveenabled and IS_ENV_COLAB and not os.path.exists('/content/drive'):\n",
       "        set_remote_storage_and_pathes()\n",
       "    \n",
       "    LOCAL_BASE = configview1r2v1localbase_text.value.strip()\n",
       "    config.remotedownloadbase = configview1r2v1remotebase_text.value.strip()\n",
       "\n",
       "    # config.general_path = configview1r2v2generallib_text.value.strip()\n",
       "    # config.movies_path = configview1r2v3movielib_text.value.strip()\n",
       "    # config.tv_path = configview1r2v3tvlib_text.value.strip()\n",
       "    # config.music_path = configview1r2v2musiclib_text.value.strip()\n",
       "    \n",
       "    bkgeneral = configview1r3v2bkgenerallib_text.value.strip()\n",
       "    if bkgeneral: config.generalbackups.add(bkgeneral)\n",
       "\n",
       "    bkmovie = configview1r3v3bkmovielib_text.value.strip()\n",
       "    if bkmovie: config.moviesbackups.add(bkmovie)\n",
       "\n",
       "    bktv = configview1r3v3bktvlib_text.value.strip()\n",
       "    if bktv: config.tvbackups.add(bktv)\n",
       "\n",
       "    bkmusic = configview1r3v2bkmusiclib_text.value.strip()\n",
       "    if bkmusic: config.musicbackups.add(bkmusic)\n",
       "    \n",
       "    if validateconfig():\n",
       "        configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved.\", fontsize='14px', style= saveconfstyle) \n",
       "    switchview(config_vbox.maincontainer)\n",
       "\n",
       "def saveconffilehandler(button):\n",
       "    configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved to file.\", fontsize='14px', style= saveconfstyle) \n",
       "\n",
       "def loadconffilehandler(button):\n",
       "    configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration loaded.\", fontsize='14px', style= saveconfstyle) \n",
       "\n",
       "# Add handlers\n",
       "\n",
       "def addsource_change(obj):\n",
       "    newval = addsourcetype_dropdown.value\n",
       "    if newval == UPLOADFILE_ADDSOURCE:\n",
       "        addsource_text.layout.display = \"none\"\n",
       "        addsource_file.layout.display = \"flex\"\n",
       "        addsourcefile_labelhbox.layout.display = \"flex\"\n",
       "        return\n",
       "    if addsource_text.layout.display == \"none\":\n",
       "        addsource_text.layout.display = \"flex\"\n",
       "        addsource_file.layout.display = \"none\"\n",
       "        addsourcefile_labelhbox.layout.display = \"none\"\n",
       "    if newval == MAGNET_ADDSOURCE:\n",
       "        addsource_text.description = \"Download magnet\"\n",
       "    elif newval == HASH_ADDSOURCE:\n",
       "        addsource_text.description = \"Download hash\"\n",
       "    elif newval == LOCALFILE_ADDSOURCE:\n",
       "        addsource_text.description = \"Local file path\"\n",
       "    elif newval == URL_ADDSOURCE:\n",
       "        addsource_text.description = \"Download file URL\"\n",
       "\n",
       "def addinput_change(val):\n",
       "    if len(addsource_text.value.strip()) > 0:\n",
       "        if addadd_button.disabled:\n",
       "            addadd_button.disabled = False\n",
       "    else:\n",
       "        if not addadd_button.disabled:\n",
       "            addadd_button.disabled = True\n",
       "\n",
       "def addfile_change(val):\n",
       "    addadd_button.disabled = False\n",
       "\n",
       "def adddownload_handler(obj): \n",
       "    addsource = addsourcetype_dropdown.value\n",
       "    switchview(nav[ADD_TAB], getloadingview(f'Adding download with {addsource}'), temp= True)\n",
       "    input_ = addsource_text.value\n",
       "    type_ = addtype_dropdown.value\n",
       "    backup = addbackup_checkbox.value\n",
       "    \n",
       "    replace = addreplace_checkbox.value\n",
       "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
       "    customname = addcustomname_text.value\n",
       "    attrs = DownloadAttrs(type_= type_, existing_mode= existing_mode, backup= backup, save_name= customname)\n",
       "    try:    \n",
       "        if addsource == LOCALFILE_ADDSOURCE:\n",
       "            result: AddResult = add_local_files(path= input_, attrs=  attrs)\n",
       "        elif addsource == UPLOADFILE_ADDSOURCE:\n",
       "            if addsource_file.value:\n",
       "                files= saveuploadedfiles()\n",
       "                if files:\n",
       "                    result: AddResult = add_local_files(files= files, attrs= attrs)\n",
       "                else:\n",
       "                    return 0\n",
       "            else:\n",
       "                return\n",
       "        elif addsource == HASH_ADDSOURCE and input_:\n",
       "            result: AddResult = add_hash_download(hash= input_, attrs= attrs)\n",
       "        elif addsource == URL_ADDSOURCE:\n",
       "            result: AddResult = add_tor_url(url= input_, attrs= attrs)\n",
       "        elif addsource == MAGNET_ADDSOURCE and input_:\n",
       "            attrs.magnet = input_\n",
       "            attrs.add_source = addsource\n",
       "            result: AddResult = add_download(attrs)  \n",
       "    except Exception as e:\n",
       "        logger.error(ex())     \n",
       "    if not result.awaiting_decision:\n",
       "            process_adddownload_result(result)\n",
       "\n",
       "def search_handler(obj):\n",
       "    type_ = searchtype_dropdown.value \n",
       "    site = searchsite_dropdown.value \n",
       "    search = searchsearch_text.value.strip()\n",
       "    switchview(nav[SEARCH_TAB], getloadingview(f'Search for {download_types[type_]} \"{search}\" site: {site} page: 1.'), temp= True)\n",
       "    category = searchcategory_dropdown.value \n",
       "    sort = searchsort_dropdown.value  \n",
       "    order = searchorder_dropdown.value\n",
       "    saveas = searchsaveas_text.value\n",
       "    replace = searchreplace_checkbox.value \n",
       "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
       "    attrs = DownloadAttrs(type_= type_, save_name= saveas, existing_mode= existing_mode)\n",
       "    if search:\n",
       "        search_process(site= site, search= search, attrs= attrs, category= category, sort= sort, order= order)\n",
       "\n",
       "def imdb_handler(btn):   \n",
       "    switchview(nav[IMDB_TAB], getloadingview(f'Processing IMDB advanced search page: 1.'), temp= True)\n",
       "    type_ = imdbtype_dropdown.value \n",
       "    keyword = imdbkeyword_text.value \n",
       "    maxrating = imdbmaxrating_float.value \n",
       "    minrating = imdbminrating_float.value \n",
       "    minvotes = imdbminvotes_int.value\n",
       "    maxvotes = imdbmaxvotes_int.value\n",
       "    minruntime = imdbminruntime_int.value\n",
       "    maxruntime = imdbmaxruntime_int.value\n",
       "\n",
       "    if imdbstartdate_date.value: startdate = str(imdbstartdate_date.value.strftime(\"%Y-%m-%d\"))  \n",
       "    else: startdate =''\n",
       "    if imdbenddate_date.value: enddate = str(imdbenddate_date.value.strftime(\"%Y-%m-%d\")) \n",
       "    else: enddate =  ''\n",
       "    \n",
       "    inlists = imdbinlist_text.value\n",
       "    notinlists = imdbnotinlist_text.value\n",
       "    imdbsort = imdbsort_dropdown.value\n",
       "    imdborder = imdborder_dropdown.value\n",
       "    top250 = imdbtop250_checkbox.value \n",
       "    top1000 = imdbtop1000_checkbox.value  \n",
       "    oscarwinner = imdboscarwinner_checkbox.value \n",
       "    bestpicturewinner = imdbbestpicturewinner_checkbox.value \n",
       "    bestdirectorwinner = imdbbestdirectorwinner_checkbox.value\n",
       "    englishonly = imdbenglishonly_checkbox.value\n",
       "    animationtitles = imdbanimationtitles_checkbox.value\n",
       "    internationaltitles = imdbinternationaltitles_checkbox.value \n",
       "    indianmovies = imdbindiantitles_checkbox.value \n",
       "    filterdownloaded = imdbfilterdownloadded_checkbox.value\n",
       "    filterwatched = imdbfilterwatched_checkbox.value \n",
       "    \n",
       "    sites = [X1337X]\n",
       "    sitecategory = getsitecategory(site_categories[type_], sites[0])\n",
       "    searchparameters = imdbsearchparams_text.value\n",
       "    replace = imdbreplaceoldfiles_checkbox.value \n",
       "\n",
       "    if type_ == MOVIE:\n",
       "        title_type = IMDB_MOVIE_TITLE\n",
       "    elif type_ == TV:\n",
       "        title_type = IMDB_TV_TITLE\n",
       "    else:\n",
       "        title_type = IMDB_ANY_TITLE\n",
       "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
       "\n",
       "    attrs = DownloadAttrs(type_= type_, existing_mode= existing_mode,)\n",
       "    params = IMDBParams(keyword = keyword, titletype= title_type, startdate= startdate, enddate= enddate, minrating= minrating,\n",
       "                    maxrating= maxrating, minvotes= minvotes, maxvotes= maxvotes, minruntime= minruntime, maxruntime= maxruntime,\n",
       "                    inlists= inlists, notinlists= notinlists, imdbsort=  imdbsort, imdborder= imdborder, filterwatched = filterwatched,\n",
       "                    filterdownloaded = filterdownloaded, top250= top250, top1000= top1000, oscarwinner= oscarwinner,\n",
       "                    bestpicturewinner= bestpicturewinner, bestdirectorwinner= bestdirectorwinner, englishonly= englishonly,\n",
       "                    animationtitles= animationtitles, internationaltitles= internationaltitles, indianmovies= indianmovies,\n",
       "                    sites= sites, sitecategory= sitecategory, siteparameters= searchparameters,\n",
       "                    attrs= attrs)\n",
       "    result: IMDBResult = searchIMDB(params)\n",
       "    imdbresultview = getsearchresultview(result)\n",
       "    switchview(nav[IMDB_TAB], imdbresultview)\n",
       "\n",
       "### Monitor\n",
       "\n",
       "#stat = get_completed_stats() completed_down = stat[0] completed_up = stat[1] update_download_stats_labels(completed_down, completed_up)\n",
       "\n",
       "def get_eta(status):\n",
       "    remaining_bytes = status.total_wanted - status.total_wanted_done\n",
       "    if remaining_bytes >= 0 and status.download_rate > 0:\n",
       "        eta_sec = remaining_bytes/status.download_rate \n",
       "        eta_sec = eta_sec + 1.5 if remaining_bytes else 0\n",
       "        return f\"Estimated: {time_str(eta_sec)}\"\n",
       "    return \"\"\n",
       "\n",
       "def update_download_view(status, handle):\n",
       "    downloadvbox = handle.view\n",
       "    totalupload = status.all_time_upload\n",
       "    if totalupload == 0:\n",
       "        totalupload = status.total_upload \n",
       "    if handle.done or handle.transfering:\n",
       "        downloadvbox.progress_bar.value = 100\n",
       "        downloadvbox.progress_label.value = \"100%\"\n",
       "        downloadvbox.control_btn.description = \"▷\"        \n",
       "        if handle.transfering:\n",
       "            downloadvbox.progress_bar.bar_style = 'warning'\n",
       "            downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(0)}{whitespace3}↑ {speed_str(0)}\"\n",
       "            downloadvbox.transfer_label = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted)}{whitespace3}↑ {data_str(totalupload)}\" \n",
       "            downloadvbox.status_label.value = \"Transfering files\"\n",
       "            downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(0)} / {data_str(status.total_wanted)}\"\n",
       "            downloadvbox.eta_label.value = f\"Estimated {time_str(0)}\"\n",
       "            downloadvbox.remove_btn.disabled = True\n",
       "        elif handle.done:\n",
       "            downloadvbox.progress_bar.bar_style = 'success'\n",
       "            downloadvbox.speed_label.value = f\"Completed at {whitespace3}{time.strftime('%I:%M:%S %p', time.localtime(status.completed_time))}\"\n",
       "            downloadvbox.transfer_label = \"Total time:{}{:.2f} m\".format(whitespace3, status.active_time/60)\n",
       "            downloadvbox.status_label.value = \"Completed\"\n",
       "            downloadvbox.remaining_label.value = f\"Downloaded {whitespace3}{data_str(status.total_wanted)} / {data_str(status.total_wanted)}\"\n",
       "            downloadvbox.eta_label.value = f\"Uploaded {whitespace3}{data_str(totalupload)}\"\n",
       "            downloadvbox.remove_btn.disabled = False\n",
       "    else:\n",
       "        if handle.paused:\n",
       "            downloadvbox.status_label.value = 'Paused'\n",
       "            downloadvbox.control_btn.description = \"▷\"\n",
       "            downloadvbox.progress_bar.bar_style = 'warning'\n",
       "        else:\n",
       "            downloadvbox.status_label.value = downloadmonitorstatestrings[status.state]\n",
       "            downloadvbox.control_btn.description = \"||\"\n",
       "            downloadvbox.progress_bar.bar_style = 'info'\n",
       "        downloadvbox.progress_bar.value = status.progress*100\n",
       "        downloadvbox.progress_label.value = \"{:.2f}%\".format(status.progress*100)\n",
       "        downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\"\n",
       "        downloadvbox.transfer_label.value = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(totalupload)}\"\n",
       "        downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\"\n",
       "        downloadvbox.eta_label.value = get_eta(status)\n",
       "\n",
       "def notify_widgets(widgets):\n",
       "    for widget in widgets:\n",
       "        widget.notify_change({'name': 'value', 'type':'update'}) \n",
       "\n",
       "def update_download_stats_labels(active_downloaded= 0, active_uploaded= 0):\n",
       "    active_downloaded += appstate.completed_down\n",
       "    active_uploaded += appstate.completed_up\n",
       "    if appstate.total_wanted == 0:\n",
       "        appstate.total_progress = 0\n",
       "    else:\n",
       "        appstate.total_progress = (100*active_downloaded) / appstate.total_wanted \n",
       "    mointorview1completed_label.value = f\"Completed: {appstate.completed}\"\n",
       "    mointorview1active_label.value = f\"Active: {len(active) - appstate.deads - appstate.transferings}\"\n",
       "    mointorview1dead_label.value = f\"Dead: {appstate.deads}\"\n",
       "    mointorview1totaldownload_label.value = f\"Session download:  {data_str(active_downloaded)} / {data_str(appstate.total_wanted)}\"\n",
       "    mointorview1totalprogress_label.value = f\"{whitespace4}{round(appstate.total_progress,2)}%\"\n",
       "    mointorview1totalupload_label.value = f\"Session upload:  {data_str(active_uploaded)}\"\n",
       "\n",
       "def remove_active_view(view):\n",
       "    hideview(view)\n",
       "    if view in monitoractivedownload_views:\n",
       "        monitoractivedownload_views.remove(view)\n",
       "    elif view in monitorcompleted_views:\n",
       "        monitorcompleted_views.remove(view)\n",
       "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
       "\n",
       "def complete_active_view(view):\n",
       "    monitorcompleted_views.append(view)\n",
       "    monitoractivedownload_views.remove(view)\n",
       "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
       "\n",
       "def setwantedbytes(handle):\n",
       "    status = handle.status() \n",
       "    appstate.total_wanted += status.total_wanted\n",
       "    handle.progress = status.progress\n",
       "\n",
       "def create_active_download_view(handle):\n",
       "    logger.info(f\"Creating active download view for {handle.name}\")\n",
       "    if startpause_btn.disabled:\n",
       "        startpause_btn.disabled = False  \n",
       "        startpause_btn.description = \"Pause\"\n",
       "    appstate.running = True\n",
       "    handle.transfering = False\n",
       "    handle.paused = False\n",
       "    handle.done = False\n",
       "    get_download_view(handle)\n",
       "    monitordownloadscontainer_vbox.children = monitoractivedownload_views\n",
       "    logger.info(f\"Active download view created for {handle.name}\")\n",
       "\n",
       "def process_completed_download(handle, status):\n",
       "    try:\n",
       "        logger.info(f'{handle.name} finished downloading.')\n",
       "        clicktask(updatestatushtml, (f\"Saving {handle.attrs.save_name} to: {handle.attrs.save_path}\", INFO_EVENT, True, False))\n",
       "        appstate.transferings += 1\n",
       "        handle.transfering = True\n",
       "        transfer_download_files(handle)\n",
       "        handle.done = True\n",
       "        handle.transfering = False\n",
       "        appstate.transferings -= 1\n",
       "        stopmonitor()\n",
       "        clicktask(update_download_view, (status, handle))  \n",
       "        clicktask(complete_active_view, (handle.view,))\n",
       "        clicktask(update_download_stats_labels)\n",
       "        clicktask(updatestatushtml)\n",
       "        active.remove(handle)\n",
       "        completed.append(handle)\n",
       "        startmonitor()\n",
       "        handle.done = True\n",
       "        handle.pause()\n",
       "        if len(active) == 0:\n",
       "            appstate.running = False\n",
       "    except Exception:\n",
       "        logger.error(ex())\n",
       "    logger.release()\n",
       "\n",
       "def sort_download_views():\n",
       "    monitoractivedownload_views.sort(key = lambda obj: obj.handle.progress, reverse= True)\n",
       "    sortchanged = False\n",
       "    for i, view in enumerate(monitoractivedownload_views):\n",
       "        if view.index != i:\n",
       "            sortchanged = True\n",
       "            break\n",
       "    if sortchanged:\n",
       "        monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
       "    \n",
       "def monitoractivedownloads():\n",
       "    appstate.monitoralive = True\n",
       "    logger.info('Monitor thread has started.')\n",
       "    try:\n",
       "        sleeptime = 0.4\n",
       "        while appstate.monitoralive and active:\n",
       "            if ses.is_paused(): \n",
       "                logger.info(\"session is paused.\")\n",
       "                appstate.monitoralive = False\n",
       "                logger.release()\n",
       "                break            \n",
       "            clicktask(sort_download_views, wait= .2)\n",
       "            active_down = active_up = 0\n",
       "            for index in range(len(monitoractivedownload_views)):\n",
       "                handle = monitoractivedownload_views[index].handle\n",
       "                handle.view.index = index\n",
       "                if not handle.transfering:\n",
       "                    status = handle.status()\n",
       "                    downloadedbytes = status.total_wanted_done\n",
       "                    wantedbytes = status.total_wanted\n",
       "                    uploadedbytes = status.total_upload\n",
       "                    handle.progress = status.progress\n",
       "                    if handle.dead and downloadedbytes > 50000:\n",
       "                        appstate.deads -= 1\n",
       "                        handle.dead = False\n",
       "                        logger.info(f\"Download is live: {handle.name}\")\n",
       "                    clicktask(update_download_view, (status, handle))\n",
       "                    if status.is_finished or (wantedbytes > 10000 and downloadedbytes == wantedbytes):\n",
       "                        logger.info(f\"{handle.name} finished downloading\")\n",
       "                        appstate.completed += 1\n",
       "                        appstate.completed_down += downloadedbytes\n",
       "                        appstate.completed_up += uploadedbytes\n",
       "                        appstate.transferthread = Thread(target= process_completed_download, args= (handle, status))\n",
       "                        appstate.transferthread.start()\n",
       "                        if len(active) == 1:\n",
       "                            appstate.monitoralive = False\n",
       "                        break \n",
       "                    else:\n",
       "                        active_down += downloadedbytes\n",
       "                        active_up += uploadedbytes\n",
       "            clicktask(update_download_stats_labels, (active_down, active_up))\n",
       "            logger.release()\n",
       "            if appstate.monitoralive:\n",
       "                time.sleep(sleeptime)\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "        updatestatushtml('An error happend in download monitor.', ERROR_EVENT)\n",
       "    logger.info('Monitor thread has ended.')\n",
       "    logger.release()\n",
       "\n",
       "def startmonitor():\n",
       "    if not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
       "        appstate.monitorthread = Thread(target= monitoractivedownloads)\n",
       "        appstate.monitorthread.start()\n",
       "\n",
       "def stopmonitor():\n",
       "    appstate.monitoralive= False\n",
       "    while appstate.monitorthread.is_alive():\n",
       "        time.sleep(.01)\n",
       "\n",
       "### UI    \n",
       "### general style\n",
       "\n",
       "css_html = HTML(\"\"\"\n",
       "    <style>\n",
       "        input, .progress-bar {\n",
       "            border-radius: 5px;\n",
       "        }\n",
       "        .progress-bar-info {\n",
       "            background-color: #02afc5;\n",
       "            animation: info-progress 2s infinite;\n",
       "            box-shadow: 1px 1px 6px 3px rgb(3 182 204 / 30%);\n",
       "        }\n",
       "        .progress-bar-info::before{\n",
       "            content: '';\n",
       "            position: absolute;\n",
       "            border-radius: 8px;\n",
       "            background: radial-gradient(circle, rgba(6,215,241,0.45) 0%, rgba(6,215,241,0.25) 50%, rgba(6,215,241,0) 100%);\n",
       "            width:50%;\n",
       "            height: 80%;\n",
       "            left: -10%;\n",
       "            animation: info-overlay 4s infinite;\n",
       "        }\n",
       "        .progress-bar-warning {\n",
       "            background: #ff9800;\n",
       "                animation: warning-progress 2s infinite;\n",
       "            box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
       "        } \n",
       "        .progress-bar-success {\n",
       "            box-shadow: 1px 1px 8px 2px rgb(76 175 80 / 50%) ;\n",
       "        }   \n",
       "        .widget-box, .widget-hbox, .widget-vbox, .widget-tab-content {\n",
       "            transition: .3s;\n",
       "            overflow-x: hidden !important; \n",
       "        }\n",
       "        .curved-40, .widget-tab-content {\n",
       "            border-radius: 40px !important;\n",
       "        }\n",
       "        .curved-20 {\n",
       "            border-radius: 20px !important;\n",
       "        }\n",
       "        .jupyter-widgets.widget-tab > .widget-tab-contents  {\n",
       "            border: none !important;\n",
       "        }\n",
       "        .lm-Widget.p-Widget.lm-TabBar.p-TabBar.p-TabPanel-tabBar.widget-tab-bar {\n",
       "            padding-left: 150px !important;\n",
       "        }\n",
       "        .widget-label.label-flex {\n",
       "            display: flex;\n",
       "        }\n",
       "        label.widget-label-basic {\n",
       "            display: flex;\n",
       "            justify-content: center;\n",
       "        }\n",
       "        .jupyter-button{\n",
       "            border-radius: 6px !important;\n",
       "            transition: .4s;\n",
       "            background-color: #a9a9a93b;\n",
       "            border: 1px solid #c2c2c2a8;\n",
       "        }\n",
       "        .jupyter-button:hover:enabled, .jupyter-button:focus:enabled {\n",
       "            box-shadow: 0px 0px 5px 1px rgb(28 142 133 / 36%) !important;\n",
       "        }\n",
       "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab {\n",
       "            border-radius: 3px;\n",
       "            border: none;\n",
       "            text-align: center;\n",
       "            font-size: 15px;\n",
       "            color: var(--colab-primary-text-color) !important;\n",
       "            padding: 10px;\n",
       "            margin: 0 50px 0 0;\n",
       "        }  \n",
       "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab.p-mod-current {\n",
       "            margin-bottom: 3px !important;\n",
       "        }\n",
       "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab.p-mod-current:before {\n",
       "            top: unset;\n",
       "            bottom: 0;\n",
       "            height: 3px;\n",
       "        }           \n",
       "\n",
       "        input[type=\"checkbox\"] {\n",
       "            margin: 3px 5px !important;\n",
       "            border: none !important;\n",
       "            position: relative;\n",
       "            width: 40px;\n",
       "            height: 20px;\n",
       "            -webkit-appearance: none;\n",
       "            background: #c6c6c6;\n",
       "            outline: none;\n",
       "            border-radius: 20px;\n",
       "            box-shadow: inset 0 0 5px rgba(255, 0, 0, 0.2);\n",
       "            transition: 0.7s;\n",
       "        }\n",
       "        input:checked[type=\"checkbox\"] {\n",
       "        background: #03a9f4;\n",
       "        }\n",
       "        input[type=\"checkbox\"]:before {\n",
       "        content: '';\n",
       "        border: 1px solid #d0d0d0c4;\n",
       "        position: absolute;\n",
       "        width: 20px;\n",
       "        height: 20px;\n",
       "        border-radius: 20px;\n",
       "        top: -1px;\n",
       "        left:0;\n",
       "        background: #ffffff;\n",
       "        transform: scale(1.1);\n",
       "        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n",
       "        transition: .5s;\n",
       "        }\n",
       "        input:checked[type=\"checkbox\"]:before {\n",
       "        left: 20px;\n",
       "        }\n",
       "        @keyframes info-progress {\n",
       "            0% {\n",
       "                background-color: #03b6cc;\n",
       "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
       "            }\n",
       "            50% {\n",
       "                background-color:\n",
       "                    #00bcd4db;\n",
       "                box-shadow: 1px 1px 7px 3px rgb(5 153 204 / 35%);\n",
       "            }\n",
       "            100% {\n",
       "                background-color: #03b6cc;\n",
       "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
       "            }\n",
       "        }\n",
       "        @keyframes warning-progress {\n",
       "            0% {\n",
       "                background-color: #ff9800;\n",
       "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
       "            }\n",
       "            50% {\n",
       "                background-color:\n",
       "                    #ff9800c9;\n",
       "                box-shadow: 1px 1px 7px 3px rgb(255 152 0 / 41%);\n",
       "            }\n",
       "            100% {\n",
       "                background-color: #ff9800;\n",
       "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
       "            }\n",
       "        }\n",
       "        @keyframes info-overlay {\n",
       "            0% {\n",
       "                left: -10%;\n",
       "                opacity: 0\n",
       "            }\n",
       "            10% {\n",
       "                left: 0%;\n",
       "                opacity: .8\n",
       "            }\n",
       "            30% {\n",
       "                opacity: 1\n",
       "            }\n",
       "            50%{\n",
       "                left: 58%;\n",
       "                opacity: 1\n",
       "            }\n",
       "            90%{\n",
       "                    left: 0%;\n",
       "                opacity: .8\n",
       "            }\n",
       "            100%{\n",
       "                left: -10%;\n",
       "                opacity: 0\n",
       "            }\n",
       "        }\n",
       "                \n",
       "    </style>\"\"\")\n",
       "\n",
       "layout_15 ={'width':'auto', 'flex':'15 1 0%', 'align_items':\"center\"}\n",
       "layout_10 ={'width':'auto', 'flex':'10 1 0%', 'align_items':\"center\"}\n",
       "layout_8 ={'width':'auto', 'flex':'8 1 0%', 'align_items':\"center\"}\n",
       "layout_7 ={'width':'auto', 'flex':'7 1 0%', 'align_items':\"center\"}\n",
       "layout_5 ={'width':'auto', 'flex':'5 1 0%', 'align_items':\"center\"}\n",
       "layout_4 ={'width':'auto', 'flex':'4 1 0%', 'align_items':\"center\"}\n",
       "layout_3 ={'width':'auto', 'flex':'3 1 0%', 'align_items':\"center\"}\n",
       "layout_2 ={'width':'auto', 'flex':'2 1 0%', 'align_items':\"center\"}\n",
       "layout_1 ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"center\"}\n",
       "layout_1E ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"flex-start\"}\n",
       "\n",
       "col4layout = {'width':'%25','flex':'3 1 0%', 'align_items':\"center\"}\n",
       "col3layout = {'width':'%33','flex':'2 1 0%', 'align_items':\"center\"}\n",
       "col2layout = {'width':'%50','flex':'1 1 0%', 'align_items':\"center\"}\n",
       "\n",
       "empty_label_1 = Label(value = \"\", layout = layout_1)\n",
       "empty_label_2 = Label(value = \"\", layout = layout_2)\n",
       "empty_label_3 = Label(value = \"\", layout = layout_3)\n",
       "empty_label_4 = Label(value = \"\", layout = layout_4)\n",
       "empty_label_5 = Label(value = \"\", layout = layout_5)\n",
       "\n",
       "whitespace1 = ' '\n",
       "whitespace2 = '  '\n",
       "whitespace3 = '   '\n",
       "whitespace4 = '    '\n",
       "whitespace5 = '     '\n",
       "\n",
       "### UI Elements\n",
       "\n",
       "rowlayout = {'flex_flow':'row', 'align_items':'center', 'width':'90%', 'height':'160px', 'justify_content':'center'}\n",
       "saverowlayout = { 'flex_flow':'row', 'align_items':'center', 'width':'80%', 'justify_content':'center' }\n",
       "input_style = {\"description_width\":\"160px\"}\n",
       "samplestyle = {\"padding\":\"0 200px 0 200px\"}\n",
       "conflabelstyle = {\"padding\":\"0 0 0 150px\"}\n",
       "mainbox_layout = { 'height': MAINBOX_HEIGHT, 'width': '100%', 'margin':'0 0 20px 0' , 'border': f'1px solid {ACCENT_COLOR}', 'display': 'flex'}\n",
       "tabtitlerow_layout = Layout(height= '100px', width= '100%', padding= '10px 100px', align_items=  'center')\n",
       "formcontent_layout = {'height':'100%', 'width':'100%', 'padding':'40px 30% 0 0'}\n",
       "downloadproperties_layout = {'height':'100%', 'width':'100%', 'padding':'20px 50px'}\n",
       "viewcontainer_layout = Layout(height= '100%', width= '100%')\n",
       "t_formrow_layout = Layout(align_items= 'center', height= '50px', width= '100%', justify_content= 'center', padding= '0')\n",
       "tab_title_layout = Layout( width= \"200px\")\n",
       "t2labels_layout = {'width':'35%', 'justify_content': 'flex-end'}\n",
       "t2labels_style = {'font_size': '18px'}\n",
       "t2controls_layout = {'margin':'0 0 0 10px', 'width':'400px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
       "t2controls_style = {'font_size': '16px', 'description_width':'150px'}\n",
       "searchcheckboxs_layout = {'margin': '5px 0 0 10px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
       "bigbtn_style = {'font_size':'16px', 'font_weight':'600'}\n",
       "bigbtn_layout = {'width':'120px', 'height':'50px', 'margin': '0 0 8px 0'}\n",
       "top_btn_layout = {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'}\n",
       "checkboxstyle = {'description_width':'0'}\n",
       "checkboxlabellayout = {\"width\": \"220px\", \"justify_content\": \"flex-end\"}\n",
       "\n",
       "startpause_btn = Button(disabled= True, description=\"Start\", style= bigbtn_style, layout= top_btn_layout)\n",
       "startpause_btn.layout.display =  'none'\n",
       "startpause_btn.on_click(pause_resume_session)\n",
       "\n",
       "status_html = HTML(layout= {'with': '50%', 'margin': '0 0 0 20px'})\n",
       "status_html.temp = True\n",
       "\n",
       "### Tab Search\n",
       "## Row 1: Title\n",
       "\n",
       "searchtitle_html = HTML(gethtmltitle('Search', 1), layout= tab_title_layout)\n",
       "searchback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
       "searchr1_hbox = HBox((searchtitle_html, searchback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
       "\n",
       "## R2:  Content\n",
       "# View 1: Search\n",
       "\n",
       "searchsearch_text = Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
       "searchsearch_hbox = HBox((searchsearch_text,),layout= t_formrow_layout)\n",
       "\n",
       "searchtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK)], layout= t2controls_layout, style= t2controls_style)\n",
       "searchtype_hbox = HBox((searchtype_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "searchsite_dropdown = Dropdown(description= \"Site\", value= X1337X, options = [('1337x', X1337X)], layout= t2controls_layout, style= t2controls_style)\n",
       "searchsite_hbox = HBox((searchsite_dropdown,),layout= t_formrow_layout)\n",
       "\n",
       "searchcategory_dropdown = Dropdown(description= \"Search Category\", value= ALLCATEGORIES_TD, options = [('All', ALLCATEGORIES_TD), ('Movies', MOVIESCATEGORY_TD), ('TV', TVCATEGORY_TD), ('Apps', APPSCATEGORY_TD), ('Games', GAMESCATEGORY_TD)], layout= t2controls_layout, style= t2controls_style)\n",
       "searchcategory_hbox = HBox((searchcategory_dropdown,),layout= t_formrow_layout)\n",
       "\n",
       "searchsort_dropdown = Dropdown(description= \"Results Sorting\", value= SEEDERSSORT, options = [('By Seeders', SEEDERSSORT), ('By Time', TIMESORT), ('By Size', SIZESORT)], layout= t2controls_layout, style= t2controls_style)\n",
       "searchsort_hbox = HBox((searchsort_dropdown,),layout= t_formrow_layout)\n",
       "\n",
       "searchorder_dropdown = Dropdown(description= \"Results Order\", value= DESCORDER, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= t2controls_layout, style= t2controls_style)\n",
       "searchorder_hbox = HBox((searchorder_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "searchreplace_label = Label(\"Replace Existing\", layout= checkboxlabellayout)\n",
       "searchreplace_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "\n",
       "searchreplace_hbox = HBox((searchreplace_label, searchreplace_checkbox), layout= t_formrow_layout)\n",
       "searchbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
       "\n",
       "searchbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "searchbackup_hbox = HBox((searchbackup_label, searchbackup_checkbox), layout= t_formrow_layout)\n",
       "searchbackup_hbox.layout.display = None\n",
       "\n",
       "searchsaveas_text = Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
       "searchsaveas_hbox = HBox((searchsaveas_text,),layout= t_formrow_layout)\n",
       "\n",
       "searchsearch_button = Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
       "searchsearch_button.layout.align_self = \"center\"\n",
       "searchreplace_label.add_class(\"label-flex\")\n",
       "searchbackup_label.add_class(\"label-flex\")\n",
       "\n",
       "searchview1_vbox= VBox((searchsearch_hbox, searchtype_hbox, searchsite_hbox, searchcategory_hbox,\n",
       "                                   searchsort_hbox, searchorder_hbox, searchreplace_hbox,\n",
       "                                   searchbackup_hbox, searchsaveas_hbox, searchsearch_button), \n",
       "                                   layout= formcontent_layout)\n",
       "\n",
       "searchr2viewcontainer_vbox = VBox((searchview1_vbox, ), layout= viewcontainer_layout)\n",
       "search_vbox = VBox((searchr1_hbox, searchr2viewcontainer_vbox), layout= mainbox_layout)\n",
       "search_vbox.name = \"Search Tab\"\n",
       "search_vbox.add_class('curved-40')\n",
       "setviewelements(search_vbox, searchr2viewcontainer_vbox, searchview1_vbox, searchback_btn, SEARCH_TAB)\n",
       "\n",
       "### Tab IMDB \n",
       "## R1: Title\n",
       "\n",
       "imdbtitle_html = HTML(gethtmltitle('IMDB Search', 1), layout= tab_title_layout)\n",
       "imdbback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
       "\n",
       "imdbr1_hbox = HBox((imdbtitle_html, imdbback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
       "\n",
       "## R2\n",
       "\n",
       "imdbkeyword_text = Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbkeyword_hbox = HBox((imdbkeyword_text,),layout= t_formrow_layout)\n",
       "\n",
       "imdbtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('Movie', MOVIE), ('TV Show', SHOW), ('Episode', EPISODE)], layout= t2controls_layout, style= t2controls_style)\n",
       "imdbtype_hbox = HBox((imdbtype_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "imdbsort_dropdown = Dropdown(description= \"Results Sort\", value= IMDB_DATE_SORT ,options= [(\"By User Rating\", IMDB_RATING_SORT), (\"By Date\", IMDB_DATE_SORT), (\"Alphabetically\", IMDB_ALPHABETICAL_SORT)], layout= t2controls_layout, style= t2controls_style)\n",
       "imdbsort_hbox = HBox((imdbsort_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "imdborder_dropdown = Dropdown(description= \"Results Order\", value= ASCORDER, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= t2controls_layout, style= t2controls_style)\n",
       "imdborder_hbox = HBox((imdborder_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "imdbstartdate_date = DatePicker(description= \"Start Date\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbstartdate_hbox = HBox((imdbstartdate_date,), layout= t_formrow_layout)\n",
       "\n",
       "imdbenddate_date = DatePicker(description= \"End Date\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbenddate_hbox = HBox((imdbenddate_date,), layout= t_formrow_layout)\n",
       "\n",
       "numeric_layout = {\"width\": \"120px\"}\n",
       "numeric_style = {\"description_width\": \"30px\"}\n",
       "numericlabel_layout = {\"margin\": \"0 3px 0 32px\", \"width\": \"129px\", 'justify_content': 'flex-end'}\n",
       "\n",
       "imdbrating_label = Label(value= \"Rating \", layout= numericlabel_layout)\n",
       "imdbminrating_float = BoundedFloatText(description= \"Min\", value= 7, min= 1, max= 10, step= 0.1, layout= numeric_layout, style= numeric_style)\n",
       "imdbmaxrating_float = BoundedFloatText(description= \"Max\", value= 10, min= 1, max= 10, step= 0.1, layout= numeric_layout, style= numeric_style)\n",
       "imdbratings_hbox = HBox((imdbrating_label, imdbminrating_float, imdbmaxrating_float), layout= t_formrow_layout)\n",
       "imdbrating_label.add_class('label-flex')\n",
       "\n",
       "imdbvotes_label = Label(value= \"Votes \", layout= numericlabel_layout)\n",
       "imdbminvotes_int = BoundedIntText(description= \"Min\", value= 0, min= 0, max= 10000000, step= 1, layout= numeric_layout, style= numeric_style)\n",
       "imdbmaxvotes_int = BoundedIntText(description= \"Max\", value= 0, min= 0, max= 10000000, step= 1, layout= numeric_layout, style= numeric_style)\n",
       "imdbvotes_hbox = HBox((imdbvotes_label, imdbminvotes_int, imdbmaxvotes_int), layout= t_formrow_layout)\n",
       "imdbvotes_label.add_class('label-flex')\n",
       "\n",
       "imdbruntime_label = Label(value= \"Run Time \", layout= numericlabel_layout)\n",
       "imdbminruntime_int = BoundedIntText(description= \"Min\", value= 0, min= 0, max= 10000, step= 1, layout= numeric_layout, style= numeric_style)\n",
       "imdbmaxruntime_int = BoundedIntText(description= \"Max\", value= 0, min= 0, max= 10000, step= 1, layout= numeric_layout, style= numeric_style)\n",
       "imdbruntime_hbox = HBox((imdbruntime_label, imdbminruntime_int, imdbmaxruntime_int), layout= t_formrow_layout)\n",
       "imdbruntime_label.add_class('label-flex')\n",
       "\n",
       "imdbinlist_text = Text(description= \"In Lists\", value= config.watch_list, placeholder= \"Comma separated list.\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbinlist_hbox = HBox((imdbinlist_text,),layout= t_formrow_layout)\n",
       "\n",
       "imdbnotinlist_text = Text(description= \"Not In List\", value= \"\", placeholder= \"Comma separated list.\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbnotinlist_hbox = HBox((imdbnotinlist_text,),layout= t_formrow_layout)\n",
       "\n",
       "imdbtop250_label = Label(\"In Top 250\", layout= checkboxlabellayout)\n",
       "imdbtop250_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbtop250_hbox = HBox((imdbtop250_label, imdbtop250_checkbox), layout= t_formrow_layout)\n",
       "imdbtop250_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbtop1000_label = Label(\"In Top 1000\", layout= checkboxlabellayout)\n",
       "imdbtop1000_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbtop1000_hbox = HBox((imdbtop1000_label, imdbtop1000_checkbox), layout= t_formrow_layout)\n",
       "imdbtop1000_label.add_class(\"label-flex\")\n",
       "\n",
       "imdboscarwinner_label = Label(\"Oscar Winner\", layout= checkboxlabellayout)\n",
       "imdboscarwinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdboscarwinner_hbox = HBox((imdboscarwinner_label, imdboscarwinner_checkbox), layout= t_formrow_layout)\n",
       "imdboscarwinner_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbbestpicturewinner_label = Label(\"Best Picture Winner\", layout= checkboxlabellayout)\n",
       "imdbbestpicturewinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbbestpicturewinner_hbox = HBox((imdbbestpicturewinner_label, imdbbestpicturewinner_checkbox), layout= t_formrow_layout)\n",
       "imdbbestpicturewinner_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbbestdirectorwinner_label = Label(\"Best Director Winner\", layout= checkboxlabellayout)\n",
       "imdbbestdirectorwinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbbestdirectorwinner_hbox = HBox((imdbbestdirectorwinner_label, imdbbestdirectorwinner_checkbox), layout= t_formrow_layout)\n",
       "imdbbestdirectorwinner_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbenglishonly_label = Label(\"Only English Titles\", layout= checkboxlabellayout)\n",
       "imdbenglishonly_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbenglishonly_hbox = HBox((imdbenglishonly_label, imdbenglishonly_checkbox), layout= t_formrow_layout)\n",
       "imdbenglishonly_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbanimationtitles_label = Label(\"Animation Titles\", layout= checkboxlabellayout)\n",
       "imdbanimationtitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbanimationtitles_hbox = HBox((imdbanimationtitles_label, imdbanimationtitles_checkbox), layout= t_formrow_layout)\n",
       "imdbanimationtitles_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbinternationaltitles_label = Label(\"International Titles\", layout= checkboxlabellayout)\n",
       "imdbinternationaltitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbinternationaltitles_hbox = HBox((imdbinternationaltitles_label, imdbinternationaltitles_checkbox), layout= t_formrow_layout)\n",
       "imdbinternationaltitles_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbindiantitles_label = Label(\"Indian Titles\", layout= checkboxlabellayout)\n",
       "imdbindiantitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbindiantitles_hbox = HBox((imdbindiantitles_label, imdbindiantitles_checkbox), layout= t_formrow_layout)\n",
       "imdbindiantitles_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbfilterdownloadded_label = Label(\"Filter Downloaded\", layout= checkboxlabellayout)\n",
       "imdbfilterdownloadded_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbfilterdownloadded_hbox = HBox((imdbfilterdownloadded_label, imdbfilterdownloadded_checkbox), layout= t_formrow_layout)\n",
       "imdbfilterdownloadded_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbfilterwatched_label = Label(\"Filter Watched\", layout= checkboxlabellayout)\n",
       "imdbfilterwatched_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbfilterwatched_hbox = HBox((imdbfilterwatched_label, imdbfilterwatched_checkbox), layout= t_formrow_layout)\n",
       "imdbfilterwatched_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbreplaceoldfiles_label = Label(\"Replace and Merge Old Files\", layout= checkboxlabellayout)\n",
       "imdbreplaceoldfiles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbreplaceoldfiles_hbox = HBox((imdbreplaceoldfiles_label, imdbreplaceoldfiles_checkbox), layout= t_formrow_layout)\n",
       "imdbreplaceoldfiles_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
       "imdbbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "imdbbackup_hbox = HBox((imdbbackup_checkbox, imdbbackup_label), layout= t_formrow_layout)\n",
       "imdbbackup_hbox.layout.display = None\n",
       "imdbbackup_label.add_class(\"label-flex\")\n",
       "\n",
       "imdbsearchparams_text = Text(description= \"Search Parameters\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
       "imdbsearchparams_hbox = HBox((imdbsearchparams_text,),layout= t_formrow_layout)\n",
       "\n",
       "searchimdb_button = Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
       "searchimdb_button.layout.align_self = \"center\"\n",
       "\n",
       "imdbview1collayout = {\"width\": \"33.3%\", \"height\": \"100%\"}\n",
       "\n",
       "imdbrsearchviewcol1_vbox = VBox((imdbkeyword_hbox, imdbtype_hbox, imdbsort_hbox, imdborder_hbox, imdbstartdate_hbox, imdbenddate_hbox,\n",
       "                            imdbratings_hbox, imdbvotes_hbox, imdbruntime_hbox), layout= imdbview1collayout)\n",
       "\n",
       "imdbrsearchviewcol2_vbox = VBox((imdbinlist_hbox, imdbnotinlist_hbox, imdbsearchparams_hbox, imdbfilterdownloadded_hbox, imdbfilterwatched_hbox,\n",
       "                            imdbreplaceoldfiles_hbox, imdbenglishonly_hbox,\n",
       "                            ), layout= imdbview1collayout)\n",
       "\n",
       "imdbrsearchviewcol3_vbox = VBox((imdbinternationaltitles_hbox, imdbindiantitles_hbox, imdbanimationtitles_hbox, imdbtop250_hbox,\n",
       "                                 imdbtop1000_hbox, imdboscarwinner_hbox, imdbbestpicturewinner_hbox,\n",
       "                            imdbbestdirectorwinner_hbox), layout= imdbview1collayout)\n",
       "\n",
       "imdbsearchviewinnercontainer_hbox = HBox((imdbrsearchviewcol1_vbox, imdbrsearchviewcol2_vbox, imdbrsearchviewcol3_vbox),\n",
       "                                         layout= {\"width\": \"100%\", \"height\": \"500px\"})\n",
       "imdbrsearchview_vbox = VBox((imdbsearchviewinnercontainer_hbox, searchimdb_button), layout= viewcontainer_layout)\n",
       "\n",
       "imdbviewcontainer_vbox = VBox((imdbrsearchview_vbox,), layout= viewcontainer_layout)\n",
       "imdbsearch_vbox = VBox((imdbr1_hbox, imdbviewcontainer_vbox), layout= mainbox_layout)\n",
       "imdbsearch_vbox.name = \"IMDB Search Tab\"\n",
       "imdbsearch_vbox.add_class('curved-40')\n",
       "setviewelements(imdbsearch_vbox, imdbviewcontainer_vbox, imdbrsearchview_vbox, imdbback_btn, IMDB_TAB)\n",
       "\n",
       "### Tab Add Download\n",
       "## R1: Title\n",
       "\n",
       "addtitle_html = HTML(gethtmltitle('Add Downloads', 1), layout= tab_title_layout)\n",
       "addback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
       "\n",
       "addr1_hbox = HBox((addtitle_html, addback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
       "\n",
       "## R2: Main Content\n",
       "\n",
       "addsourcetype_dropdown = Dropdown(description= \"Download Type\", value= MAGNET_ADDSOURCE, \n",
       "                                         options= [('Magnet', MAGNET_ADDSOURCE), ('Hash', HASH_ADDSOURCE),\n",
       "                                        ('Upload File', UPLOADFILE_ADDSOURCE), ('Local File', LOCALFILE_ADDSOURCE), ('File URL', URL_ADDSOURCE)],\n",
       "                                         layout= t2controls_layout, style= t2controls_style)\n",
       "addsourcetype_hbox = HBox((addsourcetype_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "addsource_text = Text(description= \"Magnet\", layout= t2controls_layout, style= t2controls_style)\n",
       "\n",
       "addsourcefile_labelhbox = HBox((Label(value= \"Torrent File\", layout= {\"width\":'auto'}),),\n",
       "                                      layout= {'height':'auto', 'display':'none', 'width':'170px', 'margin': '0 11px 0 0'})\n",
       "addsourcefile_labelhbox.layout.justify_content= 'flex-end'\n",
       "addsourcefile_labelhbox.layout.align_items = 'center'\n",
       "\n",
       "addsource_file = FileUpload(description= \"Upload File\", layout= {'width':'240px', 'align-items': 'center','justify-content':'flex-start'})\n",
       "addsource_file.layout.display = 'none'\n",
       "addsource_file.layout.align_items = 'center'\n",
       "\n",
       "addsource_hbox = HBox((addsource_text, addsourcefile_labelhbox, addsource_file), layout= t_formrow_layout)\n",
       "\n",
       "addtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK), ('Software', SOFTWARE), ('Game', GAMES)], layout= t2controls_layout, style= t2controls_style)\n",
       "addtype_hbox = HBox((addtype_dropdown,), layout= t_formrow_layout)\n",
       "\n",
       "addreplacemerge_label = Label(\"Replace Existing\", layout= checkboxlabellayout)\n",
       "addreplace_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "addreplacemerge_hbox = HBox((addreplacemerge_label, addreplace_checkbox,), layout= t_formrow_layout)\n",
       "\n",
       "addbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
       "addbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
       "addbackup_hbox = HBox((addbackup_label, addbackup_checkbox,), layout= t_formrow_layout)\n",
       "\n",
       "addcustomname_text = Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
       "addcustomname_hbox = HBox((addcustomname_text,),layout= t_formrow_layout)\n",
       "\n",
       "addadd_button = Button(description= \"Add\", disabled= True, layout= bigbtn_layout, style= bigbtn_style)\n",
       "addadd_button.layout.align_self = \"center\"\n",
       "\n",
       "addr2view1_adddownload_vbox= VBox((addsourcetype_hbox, addsource_hbox, addtype_hbox, addreplacemerge_hbox, addbackup_hbox, addcustomname_hbox, addadd_button), layout= formcontent_layout)\n",
       "addr2viewcontainer_vbox = VBox((addr2view1_adddownload_vbox,), layout= viewcontainer_layout)\n",
       "\n",
       "adddownloads_vbox = VBox((addr1_hbox, addr2viewcontainer_vbox), layout= mainbox_layout)\n",
       "adddownloads_vbox.name = \"Add Tab\"\n",
       "adddownloads_vbox.add_class('curved-40')\n",
       "addreplacemerge_label.add_class(\"label-flex\")\n",
       "addbackup_label.add_class(\"label-flex\")\n",
       "setviewelements(adddownloads_vbox, addr2viewcontainer_vbox, addr2view1_adddownload_vbox, addback_btn, ADD_TAB)\n",
       "\n",
       "### Tab Monitor\n",
       "## Row 1: Title\n",
       "\n",
       "mointortitle_html = HTML(gethtmltitle('Downloads', 1), layout= tab_title_layout)\n",
       "mointorback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
       "mointorr1_hbox = HBox((mointortitle_html, mointorback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
       "\n",
       "## Row 2: Monitor view\n",
       "\n",
       "downloadtransferstate = 9\n",
       "downloadmonitorstatestrings = [\"Queued\",\"Checking\",\"Downloading metadata\",\"Downloading\",\"Finished\",\"Seeding\",\"Allocating\",\"Checking resume files\", \"Transfering files\"]\n",
       "\n",
       "mointorview1container_layout = {'width':'100%', 'height':'100%'}\n",
       "mointorview1r1_layout = {'flex_flow':'row','align_items':'center', 'height':'40px', 'width':'100%','justify_content':'space-around'}\n",
       "mointorview1r2manage_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','height':'50px','justify_content':'flex-start'}\n",
       "mointorview1r3_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','justify_content':'space-around'}\n",
       "mointorview1download_layout = {'flex_flow':'row','align_items':'center','width':'95%','justify_content':'space-around'}\n",
       "\n",
       "mointorview1sessionstatus_label = Label(layout= layout_3)\n",
       "mointorview1active_label = Label(value= \"Active:  0\", layout= layout_3)\n",
       "mointorview1dead_label = Label(value= \"Dead:  0\", layout= layout_3)\n",
       "\n",
       "mointorview1completed_label = Label(value= \"Completed:  0\", layout= layout_3)\n",
       "mointorview1totaldownload_label = Label(value= \"Session download:  0 MB\", layout= layout_5)\n",
       "mointorview1totalprogress_label = Label(value= \"\", layout= layout_3)\n",
       "mointorview1totalupload_label = Label(value= \"Session upload:  0 MB\", layout= layout_5)   \n",
       "\n",
       "mointorview1r2stats_box = Box([mointorview1sessionstatus_label, mointorview1active_label, mointorview1completed_label, mointorview1dead_label, mointorview1totaldownload_label, mointorview1totalprogress_label, mointorview1totalupload_label, empty_label_3], layout= mointorview1r1_layout)\n",
       "monitordownloadscontainer_vbox = VBox(layout= {'align_items': \"center\", 'width':'99.8%', 'height':'100%', 'margin': '22px 0 0 0'})\n",
       "monitordownload_layout = {'width':'95%','align_items':'center','border':'solid #d9dbda 1px', 'margin': \"0 0 7px 0\"}\n",
       "mointorview1downloadmonitor_vbox = VBox((mointorview1r2stats_box, monitordownloadscontainer_vbox), layout= {'width':'100%', 'height':'100%'})\n",
       "mointorr2viewcontainer_vbox = VBox((mointorview1downloadmonitor_vbox,), layout= viewcontainer_layout)\n",
       "\n",
       "monitor_vbox = VBox((mointorr1_hbox, mointorr2viewcontainer_vbox), layout= mainbox_layout)\n",
       "monitor_vbox.name = \"Monitor Tab\"\n",
       "monitor_vbox.add_class('curved-40')\n",
       "setviewelements(monitor_vbox, mointorr2viewcontainer_vbox, mointorview1downloadmonitor_vbox, mointorback_btn, MONITOR_TAB)\n",
       "\n",
       "### Tab Config\n",
       "### view1 r1\n",
       "\n",
       "configtitle_html = HTML(gethtmltitle('Configurations', 1), layout= tab_title_layout)\n",
       "configback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
       "configr1_hbox = HBox((configtitle_html, configback_btn, startpause_btn, status_html), layout= tabtitlerow_layout)\n",
       "\n",
       "configview1r1v1activedownload_numeric = BoundedIntText(value=5, min=1, max=25, step=1, description='Active Downloads', disabled=False, style=input_style)\n",
       "configview1r1v1_vbox = VBox((configview1r1v1activedownload_numeric,), layout= col4layout)\n",
       "\n",
       "configview1r1v2ftptoggle_checkbox = Checkbox(description= \"Enable FTP\", value= Save_To_FTP, disabled= False)\n",
       "configview1v2vbox = VBox((configview1r1v2ftptoggle_checkbox,), layout= col4layout)\n",
       "configview1v2vbox.layout.height = '45px'\n",
       "\n",
       "configview1r1v3ftphost_text = Text(placeholder= \"FTP host address\", description= \"FTP Host\", style= input_style)\n",
       "configview1r1v3ftpuser_text = Text(placeholder= \"FTP account username\", description= \"FTP Username\", style= input_style)\n",
       "configview1r1v3ftppass_text = Password(placeholder= \"FTP account Password\", description=\"FTP Password\", style= input_style)\n",
       "configview1r1v3_vbox = VBox((configview1r1v3ftphost_text, configview1r1v3ftpuser_text, configview1r1v3ftppass_text), layout= col4layout)\n",
       "\n",
       "configview1r1_hbox = HBox((configview1r1v1_vbox, configview1v2vbox, configview1r1v3_vbox), layout= rowlayout)\n",
       "\n",
       "### view1 r2\n",
       "\n",
       "configview1r2v1localbase_text = Text(placeholder= \"Local Base\", description= \"Local Base\", value= LOCAL_BASE, style= input_style)\n",
       "configview1r2v1remotebase_text = Text(placeholder= \"Remote Base\", description=\"Remote Base\", value= FTP_BASE, style= input_style)\n",
       "configview1r2v1_vbox = VBox((configview1r2v1localbase_text, configview1r2v1remotebase_text), layout= col3layout)\n",
       "\n",
       "configview1r2v2generallib_text = Text(placeholder= \"Remote Downloads Path\", description= \"Remote Downloads Path\", value= Remote_Downloads_Path, style= input_style)\n",
       "configview1r2v2softwarelib_text = Text(placeholder= \"Remote Software Path\", description= \"Remote Software Path\", value= Remote_Software_Path, style= input_style)\n",
       "configview1r2v2musiclib_text = Text(placeholder= \"Remote Music Library\", description= \"Remote Music Library\", value= Remote_Music_Library_Path, style= input_style)\n",
       "configview1r2v2_vbox = VBox((configview1r2v2generallib_text, configview1r2v2softwarelib_text, configview1r2v2musiclib_text), layout= col3layout)\n",
       "\n",
       "configview1r2v3movielib_text = Text(placeholder= \"Remote Movies Library\", description= \"Movies Library\", value= Remote_Movie_Library_Path, style= input_style)\n",
       "configview1r2v3tvlib_text = Text(placeholder= \"Remote TV Library\", description= \"Remote TV Library\", value= Remote_TV_Library_Path, style= input_style)\n",
       "configview1r2v3_vbox = VBox((configview1r2v3movielib_text, configview1r2v3tvlib_text), layout= col3layout)\n",
       "configview1r2_hbox = HBox((configview1r2v1_vbox, configview1r2v2_vbox, configview1r2v3_vbox), layout= rowlayout)\n",
       "\n",
       "### view1 r3\n",
       "\n",
       "configview1r3v1_vbox = VBox(layout= col3layout)\n",
       "\n",
       "configview1r3v2bkgenerallib_text = Text(placeholder= \"Backup General Library\", description= \"Backup General Library\", value= '', style= input_style)\n",
       "configview1r3v2bkmusiclib_text = Text(placeholder= \"Backup Music Library\", description= \"Backup Music Library\", value= '', style= input_style)\n",
       "configview1r3v2_vbox = VBox((configview1r3v2bkgenerallib_text, configview1r3v2bkmusiclib_text), layout= col3layout)\n",
       "\n",
       "configview1r3v3bkmovielib_text = Text(placeholder= \"Backup Movie Library\", description= \"Backup Movie Library\", value= '', style= input_style)\n",
       "configview1r3v3bktvlib_text = Text(placeholder= \"Backup TV Library\", description= \"Backup TV Library\", value= '', style= input_style)\n",
       "configview1r3v3_vbox = VBox((configview1r3v3bkmovielib_text, configview1r3v3bktvlib_text), layout= col3layout)\n",
       "\n",
       "configview1r3_hbox = HBox((configview1r3v1_vbox, configview1r3v2_vbox, configview1r3v3_vbox), layout= rowlayout)\n",
       "\n",
       "### view1 r4\n",
       "\n",
       "configview1r4v1_vbox = VBox(layout= col2layout)\n",
       "\n",
       "configview1r4v2conffile_text = Text(placeholder= \"Configuration File\", description= \"Configuration File\", value= '', style= input_style)\n",
       "configview1r4v2saveconffile_button = Button(description= \"Export Configuration\",)\n",
       "configview1r4v2saveconffile_button.on_click(saveconffilehandler)\n",
       "\n",
       "configview1r4v2loadconffile_button = Button(description= \"Load Configuration\",)\n",
       "configview1r4v2loadconffile_button.on_click(loadconffilehandler)\n",
       "configview1r4v2conffile_hbox = HBox((configview1r4v2saveconffile_button, configview1r4v2loadconffile_button), layout= {\"width\":\"auto\",\"justify-content\":\"space-around\"})\n",
       "configview1r4v2_vbox = VBox((configview1r4v2conffile_text, configview1r4v2conffile_hbox), layout= col2layout)\n",
       "\n",
       "configview1r4_hbox = HBox((configview1r4v1_vbox, configview1r4v2_vbox), layout= rowlayout)\n",
       "\n",
       "### view1 r5\n",
       "\n",
       "saveconfstyle = f\"color:{SUCCESS_COLOR}\"\n",
       "configview1r5saveconf_button = Button(description= \"Save Configuration\",)\n",
       "configview1r5saveconf_button.on_click(saveconfighandler)\n",
       "configview1r5saveconfoutput_html = HTML(layout= layout_4)\n",
       "configview1r5saveconfig_Box = Box((empty_label_3 ,configview1r5saveconf_button, empty_label_1, configview1r5saveconfoutput_html), layout= saverowlayout)\n",
       "configview1r5_hbox = HBox((configview1r5saveconfig_Box,), layout= rowlayout)\n",
       "\n",
       "configview1_vbox = VBox((configview1r1_hbox, configview1r2_hbox, configview1r3_hbox, configview1r4_hbox, configview1r5_hbox), )\n",
       "configr2container_vbox = VBox((configview1_vbox,), layout= viewcontainer_layout)\n",
       "config_vbox = VBox((configr1_hbox, configr2container_vbox), layout= mainbox_layout)\n",
       "config_vbox.name = \"Config Tab\"\n",
       "config_vbox.add_class('curved-40')\n",
       "setviewelements(config_vbox, configr2container_vbox, configview1_vbox, configback_btn, CONFIG_TAB)\n",
       "\n",
       "###\n",
       "\n",
       "def tabchanged_handler(change):\n",
       "    appstate.currentviewcontainer = maintabs.children[change['new']].maincontainer\n",
       "    if status_html.temp:\n",
       "        status_html.value = ''\n",
       "    if appstate.navactions:\n",
       "        try:\n",
       "            actions = appstate.navactions.copy()\n",
       "            appstate.navactions.clear()\n",
       "            logger.info(f\"Completing navigation actions. Action count: {len(actions)}.\")\n",
       "            for action in actions:\n",
       "                action[0](*action[1])\n",
       "        except Exception as e:\n",
       "            logger.error(ex())\n",
       "        logger.release()\n",
       "\n",
       "maintabs = Tab((search_vbox, adddownloads_vbox, monitor_vbox, imdbsearch_vbox, config_vbox), layout= {\"width\": \"100%\"})\n",
       "maintabs.observe(tabchanged_handler, 'selected_index')\n",
       "maintabs.set_title(0, 'Search')\n",
       "maintabs.set_title(1, 'Add Downloads')\n",
       "maintabs.set_title(2, 'Downloads')\n",
       "maintabs.set_title(3, 'IMDB Search')\n",
       "maintabs.set_title(4, 'Configuration')\n",
       "\n",
       "appstate.tab_indices[SEARCH_TAB] = 0\n",
       "appstate.tab_indices[ADD_TAB] = 1\n",
       "appstate.tab_indices[MONITOR_TAB] = 2\n",
       "appstate.tab_indices[IMDB_TAB] = 3\n",
       "appstate.tab_indices[CONFIG_TAB] = 4\n",
       "\n",
       "uiclicker_btn = Button(description= UICLICKER_RUN, layout= {'display':'none'})\n",
       "container = Box((maintabs, css_html, uiclicker_btn), layout= {\"width\": \"100%\"})\n",
       "\n",
       "### Dynamic views\n",
       "\n",
       "def getmessageview(text):\n",
       "    t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
       "    message_container = f'<div style=\"height: {MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text , style= t1style, fontsize= \"32px\")} </div>'\n",
       "    return HTML(message_container)\n",
       "\n",
       "def iconcss(s):\n",
       "    global icon_css\n",
       "    return [icon_css for i in range(len(s))]        \n",
       "\n",
       "def updateoutput(out: Output, view):\n",
       "    out.clear_output()\n",
       "    with out:\n",
       "        display(view)\n",
       "\n",
       "def updatesearchresults(result: WebResult, page, sort= None, order= None): #\n",
       "    switchview(result.tab, getloadingview(f'Search for {download_types[result.attrs.type_]} {result.search} site: {result.site} page: {page}.'), temp= True)\n",
       "    result.updateresults(page, sort, order)\n",
       "    pagination = getpagination(result)\n",
       "    dataframe = result.getdataframe()\n",
       "    result.table.value = dataframe\n",
       "    result.pagination_container.children = pagination    \n",
       "    updateoutput(result.tableoutput, result.table)\n",
       "    switchview(result.tab)\n",
       "\n",
       "def getpagination(result: WebResult):\n",
       "    logger.info(f\"Creating pagination for search {result.search}.\")\n",
       "    currentpage_btn = Button(description= str(result.page), disabled= True, layout= pagebtn_layout)\n",
       "    dots = HTML(gethtmltext('...', fontsize= '30px'), layout= {'height': '40px', 'padding':'0 6px 12px 0'})\n",
       "    pagination = [currentpage_btn]\n",
       "    if result.page > 1:\n",
       "        if result.page -1 != 0:\n",
       "            pagination.insert(0, Button(description= str(result.page - 1), layout= pagebtn_layout)) \n",
       "        if result.page - 1 > 1:\n",
       "            pagination = [Button(description= '1', layout= pagebtn_layout), dots] + pagination\n",
       "    if result.page < result.totalpages:\n",
       "        pagination.append(Button(description= str(result.page + 1), layout= pagebtn_layout))\n",
       "    if result.page + 1 < result.totalpages:\n",
       "        pagination += [dots, Button(description= str(result.totalpages), layout= pagebtn_layout)]\n",
       "    for obj in pagination:\n",
       "        if type(obj) == Button and not obj.disabled:\n",
       "            obj.on_click(result.pagination_handler)\n",
       "    return pagination\n",
       "\n",
       "def getsearchresultview(result: WebResult):\n",
       "    logger.info(f\"Creating search result view for {result.search}.\")\n",
       "    if result.status == FAIL:\n",
       "        result_html = HTML(gethtmltext(result.result, fontsize= '24px'), layout= {'margin': '150px 0 0 50px'})\n",
       "        children = (result_html,)\n",
       "    else:\n",
       "        searchtitle_html = HTML(gethtmltext(f\"Search results {result.search}\", fontsize= '22px'), layout= {'width': '33%'})\n",
       "        controls_hbox = HBox(result.getresultcontrols(), layout= {\"width\": \"700px\"})\n",
       "        pagination = getpagination(result)\n",
       "        pagination_hbox = HBox(pagination, layout= {'align_items':'center'})\n",
       "        row1 = HBox((searchtitle_html, controls_hbox, pagination_hbox), layout= viewtoprow_layout)\n",
       "\n",
       "        result.getresultstable()\n",
       "        resultsoutput = Output()\n",
       "        with resultsoutput:\n",
       "            display(result.table)\n",
       "        result.tableoutput = resultsoutput\n",
       "        result.pagination_container = pagination_hbox\n",
       "        row2 = VBox((resultsoutput,), layout= {\"height\": \"700px\", \"width\": \"100%\"})\n",
       "        children = (row1, row2)\n",
       "\n",
       "    searchresults_vbox = VBox(children, layout= {\"width\": \"100%\", \"height\": \"100%\"})\n",
       "    logger.info(f\"Search result view created for {result.search}.\")\n",
       "    searchresults_vbox.name = \"Search results view.\"\n",
       "    return searchresults_vbox\n",
       "\n",
       "def setfilesandsizeinfoview(result: AddResult):\n",
       "    result.sizehtml.value = gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( data_str(result.size), fontsize= addresultvaluefontsize)\n",
       "    result.selectedfileshtml.value = gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.selectedfiles_count, fontsize= addresultvaluefontsize)\n",
       "\n",
       "def getaddinfosubview(result: AddResult):\n",
       "    if result.status == ADDSUCCUSS:\n",
       "        resulttitlehtml = HTML(gethtmltext(\"Download Properties\", fontsize= addrestitlefont, style= addrestitlestyle))\n",
       "        namehtml = HTML(gethtmltext(\"Download name:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext(result.name, fontsize= addresultvaluefontsize))\n",
       "        savenamehtml = HTML(gethtmltext(\"Save as:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savename,fontsize= addresultvaluefontsize))\n",
       "        sizehtml = HTML(gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
       "        fileshtml = HTML(gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
       "        hashhtml = HTML(gethtmltext(\"Hash:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.hash, fontsize= addresultvaluefontsize))\n",
       "        savepathhtml = HTML(gethtmltext(\"Save path:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savepath, fontsize= addresultvaluefontsize))\n",
       "        children = (resulttitlehtml, namehtml, savenamehtml, sizehtml, fileshtml, hashhtml, savepathhtml)\n",
       "        result.sizehtml = sizehtml\n",
       "        result.selectedfileshtml = fileshtml\n",
       "    else:\n",
       "        resulttitlehtml = HTML(gethtmltext(result.errormessage, fontsize= addrestitlefont, style= addrestitlestyle))\n",
       "        children = (resulttitlehtml,)\n",
       "    downloadinfoview = VBox(children, layout= addresultlayout)\n",
       "    downloadinfoview.titleview = resulttitlehtml\n",
       "    return downloadinfoview\n",
       "\n",
       "def getdownloadsdataframe(files: list[DownloadFile]):\n",
       "    filetablesource = {\"No\": [], \"Download\":[], \"Size\": [], \"Name\": []}\n",
       "    for item in files:\n",
       "        filetablesource['No'].append(item.index + 1)\n",
       "        filetablesource['Download'].append(item.selected)\n",
       "        filetablesource['Size'].append(data_str(item.size))\n",
       "        filetablesource['Name'].append(item.name)\n",
       "    return pd.DataFrame(filetablesource)\n",
       "\n",
       "def makedownloadfiletable(files: list[DownloadFile]):\n",
       "    dataframe = getdownloadsdataframe(files)\n",
       "    filetable = pn.widgets.Tabulator(dataframe, \n",
       "                                        sizing_mode= 'stretch_width', \n",
       "                                        widths= filetablecolumnwidths, \n",
       "                                        disabled= False, \n",
       "                                        show_index= False, \n",
       "                                        pagination= None, \n",
       "                                        editors= filetableeditors,\n",
       "                                        formatters= filetableformatters) \n",
       "    def editfiles(e):\n",
       "        files[e.row].selected = e.value\n",
       "    filetable.on_edit(editfiles)\n",
       "    return filetable\n",
       "\n",
       "def getfileselectionsubview(result: AddResult, fileselectionview_vbox= None):\n",
       "    if not fileselectionview_vbox:\n",
       "        fileselectionview_vbox = VBox(layout= fileselectionlayout)\n",
       "    if result.status == ADDSUCCUSS:\n",
       "        handle = result.handle\n",
       "        files: list[DownloadFile] = result.files\n",
       "        fileselectiontitle = HTML(gethtmltext(\"Select files\", fontsize= addrestitlefont, style= fileselectiontitlestyle))\n",
       "        selectall_button = Button(description= \"All\", layout= fileselectionbuttonlayout)\n",
       "        selectall_button.layout.margin = f'2px 0 20px'\n",
       "        selectall_button.layout.width = '60px'\n",
       "        selectintervals_text = Text(description= 'Intervals', placeholder= 'Start-end, single, n:start-end, s01-s03..', layout= {'width':'400px', 'margin': \"3px 0 0 0\"})\n",
       "        selectintervals_button = Button(description= \"Select\", layout= fileselectionbuttonlayout)\n",
       "        selectintervals_button.layout.margin = '2px 0 0 16px'\n",
       "        savefiles_button = Button(description= \"Save\", layout= fileselectionbuttonlayout)\n",
       "        savefiles_button.layout.margin = '2px 0 0 12px'\n",
       "        selectstatus_html = HTML(layout= {\"margin\": \"0 0 0 20px\", 'padding': '4px 0 0 0'})\n",
       "        toprow_hbox = HBox((fileselectiontitle, selectall_button, selectintervals_text, selectintervals_button, savefiles_button, selectstatus_html), layout= {'width': '100%', 'height':'62px'})\n",
       "\n",
       "        filetable = makedownloadfiletable(files)\n",
       "        filetableoutput = Output()\n",
       "        result.filetable = filetable\n",
       "        result.filetableoutput = filetableoutput\n",
       "        result.selectall_button = selectall_button\n",
       "        result.selectintervals_button = selectintervals_button\n",
       "        with filetableoutput:\n",
       "            display(filetable)\n",
       "        filetable_vbox = VBox((filetableoutput,), layout= {'width': '100%', 'height': '400px'})\n",
       "        filetable_vbox.layout.border = '1px solid #ababab'\n",
       "        filetable_vbox.add_class('curved-20')\n",
       "        fileselectionview_vbox.children = (toprow_hbox, filetable_vbox)\n",
       "        fileselectionview_vbox.filetable = filetable\n",
       "        fileselectionview_vbox.filetableoutput = filetableoutput\n",
       "\n",
       "        def selectallandpatch(b):\n",
       "            if files:\n",
       "                selectallfiles(files)\n",
       "                patchfiletableandinfo(result)\n",
       "            \n",
       "        def selectseasonintervalandpatch(b):\n",
       "            selection = selectintervals_text.value.strip()\n",
       "            if selection and files:\n",
       "                getfileselectionwithstr(files, selection)\n",
       "                patchfiletableandinfo(result)\n",
       "\n",
       "        def handlefileselection(b):\n",
       "            status = selectdownloadfiles(handle, files)\n",
       "            if status:\n",
       "                color = SUCCESS_COLOR\n",
       "                statusstr = \"Files selected successfully.\"\n",
       "                appstate.total_wanted -= result.size\n",
       "                result.selectedfiles_count = handle.selected_files_count\n",
       "                result.size = handle.total_download\n",
       "                appstate.total_wanted += result.size\n",
       "                setfilesandsizeinfoview(result)\n",
       "                updateoutput(filetableoutput, filetable)\n",
       "            else:\n",
       "                color = FAIL_COLOR\n",
       "                statusstr = 'Files selection failed.'\n",
       "            selectstatus_html.value = gethtmltext(statusstr, fontsize= '16px', color= color)\n",
       "\n",
       "        selectall_button.on_click(selectallandpatch)\n",
       "        selectintervals_button.on_click(selectseasonintervalandpatch)\n",
       "        savefiles_button.on_click(handlefileselection)\n",
       "    return fileselectionview_vbox \n",
       "\n",
       "def metadata_watcher(result: AddResult):\n",
       "    try:\n",
       "        appstate.metacheckeralive = True\n",
       "        while appstate.metacheckeralive:\n",
       "            torrentfile = result.handle.torrent_file()\n",
       "            if torrentfile:\n",
       "                result.hasmetadata = True\n",
       "                setwantedbytes(result.handle)\n",
       "                set_download_filtered_files(result)\n",
       "                clicktask(updatedownloadproperties, (result,))\n",
       "                appstate.metacheckeralive = False\n",
       "                break\n",
       "            time.sleep(0.2)\n",
       "        appstate.metacheckeralive = False\n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "        updatestatushtml('An error happend while checking download metadata', ERROR_EVENT)\n",
       "    logger.release()\n",
       "\n",
       "def updatedownloadproperties(result: AddResult):\n",
       "    dataframe = getdownloadsdataframe(result.files)\n",
       "    result.filetable.value = dataframe\n",
       "    setfilesandsizeinfoview(result)\n",
       "    result.selectall_button.disabled = False\n",
       "    result.selectintervals_button.disabled = False\n",
       "    updateoutput(result.filetableoutput, result.filetable)\n",
       "\n",
       "def patchfiletableandinfo(result: AddResult): \n",
       "    patch = {\"Download\": []}\n",
       "    for i in range(len(result.files)):\n",
       "        patch[\"Download\"].append((i, result.files[i].selected))\n",
       "    result.filetable.patch(patch)\n",
       "    updateoutput(result.filetableoutput, result.filetable)\n",
       "\n",
       "## User Input\n",
       "\n",
       "def userInputview(inputrows: list, title, description= \"\", height= \"\", width= \"\"):\n",
       "    title_html = HTML(gethtmltext(title, fontsize= '22px'))\n",
       "    titlerow_box = Box((title_html,), layout= userinputtitle_layout)\n",
       "    message_html = HTML(gethtmltext(description, fontsize= '16px'))\n",
       "    boxrow1userinput_box = Box((message_html,), layout= userinputrow1_layout)\n",
       "    inputrows.insert(0, boxrow1userinput_box)\n",
       "    userinput_vbox = VBox(inputrows, layout= userinput_layout)\n",
       "    if height:\n",
       "        userinput_vbox.layout.height = height\n",
       "    if width:\n",
       "        userinput_layout.layout.width = width\n",
       "    userinput_vbox.add_class('curved-20')\n",
       "    userinputview_vbox = VBox((titlerow_box, userinput_vbox), layout= userinputview_layout)\n",
       "    userinputview_vbox.name = \"User Decision\"\n",
       "    return userinputview_vbox\n",
       "\n",
       "def get_action_box_view(title, description, action_handlers, actions= (\"Yes\", \"No\")):\n",
       "    primaryAction_btn = Button(description= actions[0], layout= userinputbtn_layout)\n",
       "    secondaryAction_btn = Button(description= actions[1], layout= userinputbtn_layout)\n",
       "    primaryAction_btn.on_click(action_handlers[0])\n",
       "    secondaryAction_btn.on_click(action_handlers[1])\n",
       "    userinputsrow1_hbox = HBox((primaryAction_btn, secondaryAction_btn), layout= userinputrow2_layout)\n",
       "    return userInputview([userinputsrow1_hbox], title, description)\n",
       "\n",
       "def already_downloaded_decision_controls(prep_res: Prepare_Result):\n",
       "    message = f'The {prep_res.typestr} \"{prep_res.attrs.name}\" is already downloaded and saved as: {prep_res.foundpath}<br>Do you want to replace old file or rename main file?'\n",
       "    replaceoption_btn = Button(description= \"Replace\", layout= userinputbtn_layout)\n",
       "    mergeoption_btn = Button(description= \"Merge\", layout= userinputbtn_layout)\n",
       "    canceloption_btn = Button(description= \"Cancel Download\", layout= userinputbtn_layout)\n",
       "    rename_btn = Button(description= \"Rename New File\", layout= userinputbtn_layout)\n",
       "    userinputsrow1_hbox = HBox((mergeoption_btn, replaceoption_btn, canceloption_btn, rename_btn), layout= userinputrow2_layout)\n",
       "\n",
       "    v720p_btn = Button(description= \"720p\", layout= versioninputbtn_layout)\n",
       "    v1080p_btn = Button(description= \"1080p\", layout= versioninputbtn_layout)\n",
       "    v4k_btn = Button(description= \"4K\", layout= versioninputbtn_layout)\n",
       "    v3d_btn = Button(description= \"3D\", layout= versioninputbtn_layout)\n",
       "    userinputsrow2_hbox = HBox((v720p_btn, v1080p_btn, v4k_btn, v3d_btn), layout= userinputrow3_layout)  \n",
       "\n",
       "    newname_text = Text(description= \"New file name: \", style={'description_width': '100px'}, value= prep_res.attrs.save_name, layout= userinputtext_layout)\n",
       "    savename_btn = Button(description= \"Save\", disabled= True, layout = userinputtextbtn_layout)\n",
       "    userinputrow3_hbox = HBox((newname_text, savename_btn), layout = userinputrow4_layout)\n",
       "    rename_btn.on_click(lambda b: toggleviewstates(userinputsrow2_hbox, userinputrow3_hbox))\n",
       "\n",
       "    def handletextinputchange(change):\n",
       "        newval = newname_text.value.strip()\n",
       "        if newval == prep_res.attrs.save_name:\n",
       "            savename_btn.disabled = True\n",
       "        else: savename_btn.disabled = False\n",
       "    \n",
       "    def editboxvalue(addedvalue):\n",
       "        newname_text.value = f\"{newname_text.value} {addedvalue}\" \n",
       "        savename_btn.disabled = False\n",
       "\n",
       "    v720p_btn.on_click(lambda b: editboxvalue(\"720p\"))\n",
       "    v1080p_btn.on_click(lambda b: editboxvalue(\"1080p\"))\n",
       "    v4k_btn.on_click(lambda b: editboxvalue(\"4K\"))\n",
       "    v3d_btn.on_click(lambda b: editboxvalue(\"3D\"))\n",
       "    newname_text.observe(handletextinputchange, 'value')\n",
       "\n",
       "    savename_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(RENAME_DOWNLOAD, newname_text.value.strip()), prep_res.attrs))\n",
       "    replaceoption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(REPLACE_DOWNLOAD), prep_res.attrs))\n",
       "    mergeoption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(MERGE_DOWNLOAD), prep_res.attrs))\n",
       "    canceloption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(CANCEL_DOWNLOAD), prep_res.attrs))\n",
       "\n",
       "    alreadydownloadeduserInputview = userInputview([userinputsrow1_hbox, userinputsrow2_hbox, userinputrow3_hbox], \"Already Downloaded\", message, height= \"400px\")\n",
       "    switchview(nav[ADD_TAB], nextview= alreadydownloadeduserInputview, temp= True)\n",
       "\n",
       "##\n",
       "\n",
       "def updatestatushtml(message: str= '' , event= INFO_EVENT, animated= False, temp= True):\n",
       "    if not message:\n",
       "        status_html.value = ''\n",
       "    else:   \n",
       "        status_html.temp = temp\n",
       "        if event == ERROR_EVENT:\n",
       "            color = LOADING_COLOR\n",
       "        elif event == SUCCUSS:\n",
       "            color = SUCCESS_COLOR\n",
       "        else: color = ACCENT_COLOR\n",
       "        status_html.value = gethtmltext(message, fontsize= '16px', color= color, animated= animated)\n",
       "\n",
       "### Monitor\n",
       "\n",
       "def setpatheshtml():\n",
       "    t5view1r1pathes_html = HTML(layout= {'height':'35px', 'width':'99.8%'})\n",
       "    pathstr = \"<style>.path-str{margin: 0 0 0 80px; font-size: 14px}</style>\"\n",
       "    if config.general_path:\n",
       "        pathstr += f'<span class=\"path-str\">Downloads: {config.general_path}</span>'     \n",
       "    if config.movies_path:\n",
       "        pathstr += f'<span class=\"path-str\">Movies: {config.movies_path}</span>'\n",
       "    if config.tv_path:\n",
       "        pathstr += f'<span class=\"path-str\">TV: {config.tv_path}</span>'\n",
       "    if config.music_path:\n",
       "        pathstr += f'<span class=\"path-str\">Music: {config.music_path}</span>'        \n",
       "    t5view1r1pathes_html.value = pathstr\n",
       "    logger.info(\"Pathes html status is set.\")\n",
       "\n",
       "def get_download_view(handle):\n",
       "    status = handle.status()\n",
       "    title_label = Label(value= handle.attrs.name, layout= layout_10)\n",
       "    progress_label = Label(value= \"{:.2f}%\".format(status.progress*100), layout= layout_1)\n",
       "    progress_bar = FloatProgress(value= status.progress*100, min= 0, max= 100, step= 0.2, bar_style= 'info', orientation= 'horizontal', layout= layout_15)\n",
       "    control_btn = Button(description= \"∣∣\", layout= {'width':'28px', 'height':'29px', 'padding': '0px 1px 2px 2px', 'margin': '0 6px 6px 18px'})\n",
       "    info_btn = Button(description= \"i\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 5px 0 0'})\n",
       "    remove_btn = Button(description= \"✕\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 5px 0 0'})\n",
       "    edittrackers_btn = Button(description= \"T\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 5px 0 0'})\n",
       "    save_btn = Button(description= \"S\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 20px 0 0'})\n",
       "    status_label = Label(value= \"Downloading\", layout= layout_2)\n",
       "    type_label = Label(value= download_types[handle.attrs.type_], layout= layout_1)\n",
       "    speed_label = Label(value= f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\", layout= layout_3)\n",
       "    transfered_label = Label(value= f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(status.total_upload)}\", layout= layout_4)\n",
       "    remaining_label = Label(value= f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\" , layout= layout_4)\n",
       "    eta_label = Label(value= get_eta(status), layout= layout_2)\n",
       "    downloadrow1box = Box((title_label, progress_label, progress_bar, empty_label_1), layout = mointorview1r3_layout)\n",
       "    downloadrow2box = Box((control_btn, info_btn, remove_btn, edittrackers_btn, save_btn, status_label, type_label, speed_label, transfered_label, remaining_label, eta_label), layout= mointorview1r3_layout)\n",
       "    downloadvbox = VBox((downloadrow1box,downloadrow2box), layout= monitordownload_layout)\n",
       "    downloadvbox.add_class('curved-20')\n",
       "    downloadvbox.title_label = title_label\n",
       "    downloadvbox.progress_label = progress_label\n",
       "    downloadvbox.progress_bar = progress_bar\n",
       "    downloadvbox.control_btn = control_btn\n",
       "    downloadvbox.info_btn = info_btn\n",
       "    downloadvbox.remove_btn = remove_btn\n",
       "    downloadvbox.status_label = status_label\n",
       "    downloadvbox.type_label = type_label\n",
       "    downloadvbox.speed_label = speed_label\n",
       "    downloadvbox.transfer_label = transfered_label\n",
       "    downloadvbox.remaining_label =  remaining_label\n",
       "    downloadvbox.eta_label = eta_label\n",
       "    downloadvbox.handle = handle\n",
       "    handle.view = downloadvbox\n",
       "    handle.view.index = len(active)\n",
       "    handle.progress_bar = progress_bar \n",
       "    handle.control_btn = control_btn \n",
       "    control_btn.on_click(lambda btn: pause_start_download(downloadvbox.handle, btn))\n",
       "    info_btn.on_click(lambda btn: switchview(nav[MONITOR_TAB], downloadvbox.handle.propertiesview))\n",
       "    remove_btn.on_click(lambda btn: remove_download(downloadvbox))\n",
       "    edittrackers_btn.on_click(lambda btn: edittracker_handler(handle))\n",
       "    save_btn.on_click(lambda btn: saveuncompleteddownload_handler(handle))\n",
       "    monitoractivedownload_views.append(downloadvbox)\n",
       "    logger.info(f'Download view created for: {handle.name}')\n",
       "    return downloadvbox\n",
       "\n",
       "def edittracker_handler(handle):\n",
       "    return\n",
       "\n",
       "def saveuncompleteddownload_handler(handle):\n",
       "    attrs: DownloadAttrs = handle.attrs\n",
       "    title = \"Saving Download Progress\"\n",
       "    description = f\"Do you want to save the download progress?<br>{handle.name}\"\n",
       "    def confirm_handler(b):\n",
       "        switchview(nav[MONITOR_TAB], getloadingview(f'Saving progress {attrs.name}.'), temp= True)\n",
       "        save_download_progress(handle, config.remote_uncompleted_path)\n",
       "        switchview(nav[MONITOR_TAB])\n",
       "    def cancel_handler(b):\n",
       "        switchview(nav[MONITOR_TAB])\n",
       "    confirmingview = get_action_box_view(title, description, action_handlers= (confirm_handler, cancel_handler))\n",
       "    switchview(nav[MONITOR_TAB], confirmingview, temp= True)\n",
       "    return\n",
       "    \n",
       "### Handling\n",
       "\n",
       "addsourcetype_dropdown.observe(addsource_change, names= \"value\")\n",
       "addsource_text.observe(addinput_change, 'value')\n",
       "addsource_file.observe(addfile_change, names= 'value')\n",
       "addadd_button.on_click(adddownload_handler)\n",
       "searchsearch_button.on_click(search_handler)\n",
       "searchimdb_button.on_click(imdb_handler)\n",
       "\n",
       "def makeclickjs(btn_desc, interval= 0, use_evaljs= False, enable_console= False, getstr= False):\n",
       "    logger.info(f\"Creating click js for bottun discription: {btn_desc}\")\n",
       "    if IS_ENV_COLAB:\n",
       "        if interval > 0:\n",
       "            funcname= f\"pyfunc{nowstr()}\"\n",
       "            funcstart =  f\"function {funcname}() {{\"\n",
       "            funcendrepeat = f\"}} setInterval({funcname}, {interval});\"\n",
       "        else:\n",
       "            funcname = funcstart = funcendrepeat = \"\"\n",
       "        if enable_console:\n",
       "            contrue = f\"console.info('Click made to {btn_desc} button.');\"\n",
       "            confalse = f'console.info(\"{btn_desc} wasn\\'t found\");'\n",
       "        else:\n",
       "            contrue = confalse = \"\"\n",
       "        clickjs = f\"\"\"{funcstart}\n",
       "        els = Array.prototype.slice.call(document.getElementsByTagName('button')).filter(el => el.textContent.startsWith('{btn_desc}'));\n",
       "        if (els.length > 0) {{els[0].click(); {contrue}}} else {{{confalse}}} {funcendrepeat} \"\"\"\n",
       "        if getstr:\n",
       "            return clickjs\n",
       "        if use_evaljs:\n",
       "            eval_js(clickjs, ignore_result= True)\n",
       "            logger.info(f\"Click js for bottun {btn_desc} was sent with eval_js.\")\n",
       "        else:\n",
       "            display(Javascript(clickjs))\n",
       "            logger.info(f\"Click js for bottun {btn_desc} was sent with display javascript.\")\n",
       "\n",
       "def clicktask(task, args= (), wait= 0):\n",
       "    appstate.clicktasks.append((task, args))\n",
       "    if wait:\n",
       "        time.sleep(wait)\n",
       "    \n",
       "def clicktaskshandler(btn= None):\n",
       "    # mointorr2viewcontainer_vbox.notify_change({'name': 'value', 'type':'update'}) \n",
       "    if appstate.clicktasks:\n",
       "        worktasks = appstate.clicktasks.copy()\n",
       "        appstate.clicktasks.clear()\n",
       "        for task in worktasks:\n",
       "            try:\n",
       "                task[0](*task[1])\n",
       "            except Exception as e:\n",
       "                logger.error(ex())\n",
       "                logger.release()\n",
       "\n",
       "def run_uiclicker():\n",
       "    uiclicker_btn.description = UICLICKER_RUN\n",
       "\n",
       "def stop_uiclicker():\n",
       "    uiclicker_btn.description = UICLICKER_STOP\n",
       "\n",
       "uiclicker_btn.on_click(clicktaskshandler)\n",
       "\n",
       "if arethreadsworking(config.setupthreads) and False:\n",
       "    for thread in config.setupthreads: \n",
       "        if thread.is_alive(): thread.join()\n",
       "\n",
       "logger.info(\"Cell execution done.\")\n",
       "logger.release()\n",
       "\n",
       "js = makeclickjs(UICLICKER_RUN, 200, use_evaljs= False, enable_console= False, getstr= True)\n",
       "if not dev:\n",
       "    #if IS_ENV_COLAB:  output.clear() \n",
       "    display(container, Javascript(js))\n"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
       "cellView": "form",
       "id": "ZxUTGFyDuBUz"
      },
      "outputs": [],
      "source": [
       "#@title { form-width: \"2%\" }\n",
       "#@markdown\n",
       " \n",
       "# debuging\n",
       "# !pip install ipdb\n",
       "# %pdb on\n",
       "\n",
       "# issues\n",
       "# using Javascript is persisted in the output\n",
       "# when cell done executing with setup thread running in the background, output is cleared.\n",
       "# to debug and see exceptions turn off all back threads.\n",
       "# format table:: table.style.format({\"ww1\": lambda value: {\"white-space\": \"pre-wrap\", \"word-break\": \"break-word\"}})\n",
       "# t1 = t.style.format({\"aa\": lambda value: html.unescape(value)})\n",
       "# an issue happens after inhereting bokeh.models.cell_formatter class, then creating a tabulator and display it\n",
       "# \n",
       "# the app doesnt display anything after installing jupyter bookah"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
       "cellView": "form",
       "id": "ZxUTGFyDuBUz"
      },
      "outputs": [],
      "source": [
       "#@title { form-width: \"2%\" }\n",
       "#@markdown\n",
       " \n",
       "#### deprecated code\n",
       "\n",
       "def backthreadchecker(threadset):\n",
       "    try:\n",
       "        at = arethreadsworking(threadset)\n",
       "        while at: \n",
       "            logger.info(f\"Active tasks: {', '.join(at)}\")\n",
       "            time.sleep(0.5)\n",
       "            at = arethreadsworking(threadset)\n",
       "            if not at:\n",
       "                logger.info(\"Threads have finished working.\") \n",
       "                switchview(config_vbox.maincontainer) \n",
       "    except Exception as e:\n",
       "        logger.error(ex())\n",
       "    logger.release()\n",
       "\n",
       "def check_pip_pgks_installed(check_pkgs, installmissing = False, v= False): # depracated\n",
       "    for chk_pkg in check_pkgs:\n",
       "        for pkg in config.installed_pkgs:\n",
       "            if pkg.startswith(chk_pkg):\n",
       "                check_pkgs.remove(chk_pkg)\n",
       "                break\n",
       "        if len(check_pkgs) == 0:\n",
       "            break\n",
       "    if check_pkgs:\n",
       "        if installmissing:\n",
       "            logger.info(\"Installing required packages.\")\n",
       "            for pkg in check_pkgs:\n",
       "                install_pip_pkgs(pkg)\n",
       "            return True            \n",
       "        else:    \n",
       "            msg = f'Missing packages: {\", \".join(check_pkgs)}'\n",
       "            if v:\n",
       "                print(msg)\n",
       "            return check_pkgs\n",
       "    else:\n",
       "        return True\n",
       "\n",
       "def setupreqs(): # deprecated\n",
       "    reqs = set()\n",
       "    if config.ftpenabled:\n",
       "        reqs.add('ftputil')\n",
       "        if IS_ENV_COLAB:\n",
       "            !sudo apt-get install lftp $NULL_STREAM \n",
       "    if config.spotifyenabled:\n",
       "        reqs.add('savify')\n",
       "    if config.ftpenabled:\n",
       "        global ftputil\n",
       "        import ftputil \n",
       "    check_pip_pgks_installed(reqs, True)"
      ]
     }
    ],
    "metadata": {
     "colab": {
      "collapsed_sections": [],
      "include_colab_link": true,
      "name": "Hydraulic",
      "provenance": []
     },
     "gpuClass": "standard",
     "kernelspec": {
      "display_name": "Python 3.9.7 64-bit",
      "language": "python",
      "name": "python3"
     },
     "language_info": {
      "codemirror_mode": {
       "name": "ipython",
       "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.1"
     },
     "vscode": {
      "interpreter": {
       "hash": "c347c8f9a7ef94e4c9e03b4513be7835ed18f45b99a2a817fb579f408b867b16"
      }
     }
    },
    "nbformat": 4,
    "nbformat_minor": 0
   }
   