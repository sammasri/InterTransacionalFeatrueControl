{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "\n",
    "#@title { form-width: \"2%\" }\n",
    "#@markdown ### Setups and Drive\n",
    "\n",
    "import os, re, pytz\n",
    "from datetime import date, datetime\n",
    "\n",
    "from google.colab import drive\n",
    " \n",
    "if not os.path.exists('/content/drive'):\n",
    "    drive.mount('/content/drive')\n",
    "\n",
    "tz = pytz.timezone('Turkey')\n",
    "size_limit = 20000\n",
    "\n",
    "zipfile_re = re.compile(r\"\\.([Zz][Ii][Pp]|[Gg][Zz]|[Rr][Aa][Rr]|7[Zz]|[Tt][Aa][Rr])$\")\n",
    "extdot_re = r\"\\.(?=\\w+$)\"\n",
    "file_re = r\"^.*\\.[A-Z,a-z,0-9]+$\"\n",
    "url_re = r\"((http[s]?):\\/\\/)?([^:\\/\\s]+)((\\/\\w+\\/)*\\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?\"\n",
    "file_url_re = r\"((http[s]?):\\/\\/)?([^:\\/\\s\\\"<>(\\\\n)]+)((\\/\\w{3}\\/)*\\/)([\\w\\-\\.]+[^#?\\s\\\"<>(\\\\n)]+)([^:\\/\\s\\\"<>(\\\\n)].*)?(#[\\w\\-]+)?\"\n",
    "\n",
    "_path_inner_chars = '/\\\\:?*<>\\0|\"'\n",
    "_segment = f'[^{_path_inner_chars}]+'\n",
    "# Path pattern is enclosed in a raw f-string with re.VERBOSE for readability.\n",
    "_path = rf\"\"\"\n",
    "(?: / (?: {_segment} (?: / {_segment} )* )? /?\n",
    "|  (?: [^\\s~{_path_inner_chars}][^~{_path_inner_chars}]* ) (?: / {_segment} )* /? )\n",
    "\"\"\"\n",
    "linux_path_regex_str = rf\"(?:\\\"{_path}\\\"|'{_path}')|^{_path}$\"\n",
    "linuxfilepath_re = re.compile(linux_path_regex_str, re.VERBOSE)\n",
    "\n",
    "quotation_re = re.compile(r'^\\s*([\\'\"])(.*?)\\1\\s*$')\n",
    "def remove_quotes(text):\n",
    "    \"\"\"Removes matching quotes from the start and end of a string.\"\"\"\n",
    "    return quotation_re.sub(r'\\2', text)\n",
    "\n",
    "lastletters_re = re.compile(r\"\\s*[A-Za-z]{1,}\\s*\")\n",
    "digits_re = re.compile(r\"\\s*[0-9]{1,}\\s*\")\n",
    "\n",
    "def str_num(numstr):\n",
    "    num = digits_re.search(numstr)\n",
    "    if not num:\n",
    "        return 0\n",
    "    letters = lastletters_re.search(numstr)\n",
    "    num = num.group()\n",
    "    if letters:\n",
    "        letters = letters.group()\n",
    "        if letters.startswith(\"k\"):\n",
    "            return int(num) * 1000\n",
    "        elif letters.startswith(\"m\"):\n",
    "            return int(num) * 1000000\n",
    "        elif letters.startswith(\"g\"):\n",
    "            return int(num) * 1000000000\n",
    "    return int(num)\n",
    "\n",
    "exlessbase = lambda path: os.path.basename(os.path.splitext(path)[0])\n",
    "nowstr = lambda separete = False: datetime.now(tz).strftime(\"%y-%m-%d-%H-%M-%S\") if separete else str(round(time.time()))\n",
    "\n",
    "def RoundTo1(n) :\n",
    "    if n < 1 and (n - 0.9765625) >= 0 :\n",
    "        return 1\n",
    "    else: \n",
    "        return n\n",
    "\n",
    "ByteToGB = lambda n: RoundTo1(n/1073741824)\n",
    "ByteToMB = lambda n: RoundTo1(n/1048576)\n",
    "ByteToKB = lambda n: RoundTo1(n/1024)\n",
    "\n",
    "def data_str(byte_val):\n",
    "    size = ByteToGB(byte_val)\n",
    "    if (size >= 1):\n",
    "        return \"{:.1f} GB\".format(size)\n",
    "    size = ByteToMB(byte_val)\n",
    "    if (size >= 1):\n",
    "        return \"{:.1f} MB\".format(size)\n",
    "    size = ByteToKB(byte_val)\n",
    "    if (size >= 1):\n",
    "        return \"{:.1f} KB\".format(size)\n",
    "    return \"{:.1f} B\".format(size)\n",
    "\n",
    "def pathsize(path, string = False):\n",
    "    size = 0\n",
    "    if not os.path.exists(path):\n",
    "        return 0\n",
    "    if os.path.isfile(path):\n",
    "        size = os.path.getsize(path)\n",
    "    else:  \n",
    "      for path, dirs, files in os.walk(path):\n",
    "          for f in files:\n",
    "              fp = os.path.join(path, f)\n",
    "              size += os.path.getsize(fp)\n",
    "    if string:\n",
    "        return data_str(size)\n",
    "    else:\n",
    "        return size\n",
    "\n",
    "def has_size(path, only_check = True):\n",
    "    size = 0\n",
    "    if not os.path.exists(path):\n",
    "        return 0\n",
    "    if os.path.isfile(path):\n",
    "        size = os.path.getsize(path)\n",
    "    else:  \n",
    "        for path, dirs, files in os.walk(path):\n",
    "            for f in files:\n",
    "                fp = os.path.join(path, f)\n",
    "                size += os.path.getsize(fp)\n",
    "                if only_check and size >= size_limit:\n",
    "                    return size\n",
    "    if size >= size_limit:\n",
    "        return size\n",
    "    else:\n",
    "        return 0\n",
    "        \n",
    "def zip(input, saveto: str = \"\", split = \"\", totalfilessize= \"\", deletefiles= False, callback = None):\n",
    "    \"\"\"Zips the input file or directory to a specified location.\n",
    "    ### Args:\n",
    "        input (str): Directory or file to zip.\n",
    "        saveto (str, optional): Saving directory or filename. Defaults to \"\".\n",
    "        split (str, optional): create split archive with splits of size ssize, where ssize as nm, n number and m multiplier (k, m, g or t. Default m), 100k -> 100 kB. Defaults to \"\".\n",
    "        callback (function, optional): callback func to call with the zip file(s). Defaults to None.\n",
    "    \"\"\"\n",
    "    # linuxfilepath_re\n",
    "    saveto = saveto.strip()\n",
    "    if input:\n",
    "        cwd = os.getcwd()\n",
    "        filenames = linuxfilepath_re.findall(input)\n",
    "        totalfilessize = str_num(totalfilessize)\n",
    "        print(filenames)\n",
    "        if len(filenames) == 1:\n",
    "            input = remove_quotes(input)\n",
    "            # if totalfilessize and input\n",
    "            inputdir = os.path.dirname(input)\n",
    "            basename = os.path.basename(input)\n",
    "            savename = f\"{basename}.zip\"\n",
    "            input = f'\"{basename}\"'\n",
    "            dirparams = \"-r\"\n",
    "            if inputdir and os.path.isdir(inputdir):\n",
    "                os.chdir(inputdir)\n",
    "        elif len(filenames) > 1:\n",
    "            savename = f\"zipped-files-{nowstr(True)}.zip\"\n",
    "            dirparams = \"-j\"\n",
    "        else:\n",
    "            print(\"Check input.\")\n",
    "            return\n",
    "        if saveto:  \n",
    "            sch = zipfile_re.search(saveto)\n",
    "            if sch:\n",
    "                savedir = os.path.dirname(saveto)\n",
    "                savename = saveto\n",
    "            else:\n",
    "                savedir = saveto\n",
    "                savename = os.path.join(saveto, savename)\n",
    "            if savedir:\n",
    "                os.makedirs(savedir, exist_ok=True)            \n",
    "        splitparam = f\" -s {split} \" if split else \"\"\n",
    "        print(f\"Zipping: {input}\\nTo: {saveto}\")\n",
    "        cm = f'zip -7 {dirparams}{splitparam} -qdg \"{savename}\" {input}'\n",
    "        print(cm)\n",
    "        !$cm\n",
    "        os.chdir(cwd)\n",
    "    else:\n",
    "        print(\"No input file or directory provided.\")\n",
    "\n",
    "def unzip(input, save: str = \"\", callback = None):\n",
    "    save = save.strip()\n",
    "    if input:\n",
    "        print(f\"Unzipping: {input}\\nTo: {save}\")\n",
    "        saving = \"-d \" + f'\"{save}\"' if save else \"\"\n",
    "        !unzip \"$input\" $saving\n",
    "        print(f'Done, check output: {save}')\n",
    " \n",
    "def FolderSize(path):\n",
    "    print(f\"Checking size for path: {path}\")\n",
    "    size = pathsize(path, True)\n",
    "    print(f\"    {size}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "\n",
    "#@title { form-width: \"2%\" }\n",
    "#@markdown ### Setup Rcl0ne\n",
    "\n",
    "build_version = \"stable\" #@param [\"stable\", \"beta\"]\n",
    "automatically_clear_cell_output = True  # @param{type: \"boolean\"}\n",
    "# ================================================================ #\n",
    "\n",
    "import os\n",
    "import IPython\t\n",
    "from IPython.display import clear_output\n",
    "\n",
    "\n",
    "if build_version == \"stable\":\n",
    "\t!curl https://rclone.org/install.sh | sudo bash\n",
    "else:\n",
    "\t!curl https://rclone.org/install.sh | sudo bash -s beta\n",
    "\n",
    "!sudo apt-get -y install fuse3\n",
    "\n",
    "os.makedirs(\"/root/.config/rclone\", exist_ok=True)\n",
    "!mv \"/content/rclone.conf\" \"/root/.config/rclone\"\n",
    "\n",
    "if automatically_clear_cell_output is True:\n",
    "\tclear_output()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "t03ZdwQ-IvPv"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "#@markdown\n",
    "\n",
    "Mode = \"Copy\" #@param [\"Copy\", \"Move\", \"Sync\", \"Checker\", \"Deduplicate\", \"Remove Empty Directories\", \"Empty Trash\"]\n",
    "Source = \"\" #@param {type:\"string\"}\n",
    "Destination = \"\" #@param {type:\"string\"}\n",
    "\n",
    "#@markdown ---\n",
    "#@markdown <h3><font color=\"#3399ff\"><b>Global Configuration </b></font></h3>\n",
    "Extra_Arguments = \"\" #@param {type:\"string\"}\n",
    "Compare = \"Size & Mod-Time\" #@param [\"Size & Mod-Time\", \"Size & Checksum\", \"Only Mod-Time\", \"Only Size\", \"Only Checksum\"]\n",
    "Checkers = 5 #@param {type:\"slider\", min:1, max:40, step:1}\n",
    "Transfers = 5 #@param {type:\"slider\", min:1, max:20, step:1}\n",
    "Dry_Run = False #@param {type:\"boolean\"}\n",
    "Do_not_cross_filesystem_boundaries = False\n",
    "Do_not_update_modtime_if_files_are_identical = False #@param {type:\"boolean\"}\n",
    "Google_Drive_optimization = False #@param {type:\"boolean\"}\n",
    "Large_amount_of_files_optimization = False #@param {type:\"boolean\"}\n",
    "Simple_Ouput = True #@param {type:\"boolean\"}\n",
    "Skip_all_files_that_exist = False #@param {type:\"boolean\"}\n",
    "Skip_files_that_are_newer_on_the_destination = False #@param {type:\"boolean\"}\n",
    "Output_Log_File = \"OFF\" #@param [\"OFF\", \"NOTICE\", \"INFO\", \"ERROR\", \"DEBUG\"]\n",
    "\n",
    "#@markdown <br><h3><font color=\"#3399ff\"><b> Sync Configuration </b></font></h3>\n",
    "Sync_Mode = \"Delete during transfer\" #@param [\"Delete during transfer\", \"Delete before transfering\", \"Delete after transfering\"]\n",
    "Track_Renames = False #@param {type:\"boolean\"}\n",
    "\n",
    "#@markdown <br><h3><font color=\"#3399ff\"><b>Deduplicate Configuration </b></font></h3>\n",
    "Deduplicate_Mode = \"Interactive\" #@param [\"Interactive\", \"Skip\", \"First\", \"Newest\", \"Oldest\", \"Largest\", \"Rename\"]\n",
    "Deduplicate_Use_Trash = True #@param {type:\"boolean\"}\n",
    "\n",
    "#@markdown ---\n",
    "automatically_clear_cell_output = False  # @param{type: \"boolean\"}\n",
    "# ================================================================ #\n",
    "\n",
    "##### Importing the needed modules\n",
    "import os\n",
    "import IPython\n",
    "from IPython.display import  clear_output\n",
    "\n",
    "bufferC = \"--buffer-size 96M\"\n",
    "\n",
    "if Compare == \"Size & Checksum\":\n",
    "    compareC = \"-c\"\n",
    "elif Compare == \"Only Mod-Time\":\n",
    "    compareC = \"--ignore-size\"\n",
    "elif Compare == \"Only Size\":\n",
    "    compareC = \"--size-only\"\n",
    "elif Compare == \"Only Checksum\":\n",
    "    compareC = \"-c --ignore-size\"\n",
    "else:\n",
    "    compareC = \"\"\n",
    "\n",
    "sourceC = Source\n",
    "destinationC = Destination\n",
    "transfersC = \"--transfers \"+str(Transfers)\n",
    "checkersC = \"--checkers \"+str(Checkers)\n",
    "\n",
    "if Skip_files_that_are_newer_on_the_destination == True:\n",
    "    skipnewC = \"-u\"\n",
    "else:\n",
    "    skipnewC = \"\"\n",
    "  \n",
    "if Skip_all_files_that_exist == True:\n",
    "    skipexistC = \"--ignore-existing\"\n",
    "else:\n",
    "    skipexistC = \"\"\n",
    "  \n",
    "if Do_not_cross_filesystem_boundaries == True:\n",
    "    nocrossfilesystemC = \"--one-file-system\"\n",
    "else:\n",
    "    nocrossfilesystemC = \"\"\n",
    "  \n",
    "if Do_not_update_modtime_if_files_are_identical == True:\n",
    "    noupdatemodtimeC = \"--no-update-modtime\"\n",
    "else:\n",
    "    noupdatemodtimeC = \"\"\n",
    "\n",
    "if Large_amount_of_files_optimization == True:\n",
    "    filesoptimizeC = \"--fast-list\"\n",
    "else:\n",
    "    filesoptimizeC = \"\"\n",
    "  \n",
    "if Google_Drive_optimization == True:\n",
    "    driveoptimizeC = \"--drive-chunk-size 32M --drive-acknowledge-abuse --drive-keep-revision-forever\"\n",
    "else:\n",
    "    driveoptimizeC = \"\"\n",
    "  \n",
    "if Dry_Run == True:\n",
    "    dryrunC = \"-n\"\n",
    "else:\n",
    "    dryrunC = \"\"\n",
    "  \n",
    "if Output_Log_File != \"OFF\":\n",
    "    statsC = \"--log-file=/root/.rclone_log/rclone_log.txt\"\n",
    "else:\n",
    "    if Simple_Ouput == True:\n",
    "        statsC = \"-v --stats-one-line --stats=5s\"\n",
    "    else:\n",
    "        statsC = \"-v --stats=5s\"\n",
    "statsC = \"\"\n",
    "\n",
    "if Output_Log_File == \"INFO\":\n",
    "    loglevelC = \"--log-level INFO\"\n",
    "elif Output_Log_File == \"ERROR\":\n",
    "    loglevelC = \"--log-level ERROR\"\n",
    "elif Output_Log_File == \"DEBUG\":\n",
    "    loglevelC = \"--log-level DEBUG\"\n",
    "else:\n",
    "    loglevelC = \"\"\n",
    "\n",
    "extraC = Extra_Arguments\n",
    "\n",
    "if Sync_Mode == \"Delete during transfer\":\n",
    "    syncmodeC = \"--delete-during\"\n",
    "elif Sync_Mode == \"Delete before transfering\":\n",
    "    syncmodeC = \"--delete-before\"\n",
    "elif Sync_Mode == \"Delete after transfering\":\n",
    "    syncmodeC = \"--delete-after\"\n",
    "  \n",
    "if Track_Renames == True:\n",
    "    trackrenamesC = \"--track-renames\"\n",
    "else:\n",
    "    trackrenamesC = \"\"\n",
    "  \n",
    "if Deduplicate_Mode == \"Interactive\":\n",
    "    deduplicateC = \"interactive\"\n",
    "elif Deduplicate_Mode == \"Skip\":\n",
    "    deduplicateC = \"skip\"\n",
    "elif Deduplicate_Mode == \"First\":\n",
    "    deduplicateC = \"first\"\n",
    "elif Deduplicate_Mode == \"Newest\":\n",
    "    deduplicateC = \"newest\"\n",
    "elif Deduplicate_Mode == \"Oldest\":\n",
    "    deduplicateC = \"oldest\"\n",
    "elif Deduplicate_Mode == \"Largest\":\n",
    "    deduplicateC = \"largest\"\n",
    "elif Deduplicate_Mode == \"Rename\":\n",
    "    deduplicateC = \"rename\"\n",
    "  \n",
    "if Deduplicate_Use_Trash == True:\n",
    "    deduplicatetrashC = \"\"\n",
    "else:\n",
    "    deduplicatetrashC = \"--drive-use-trash=false\"\n",
    "\n",
    "##### rclone Execution\n",
    "if Output_Log_File != \"OFF\" and Mode != \"Config\":\n",
    "    !mkdir -p -m 666 /root/.rclone_log/\n",
    "    print(\"Logging enabled\")\n",
    "\n",
    "if Mode == \"Copy\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf copy \"$sourceC\" \"$destinationC\" $transfersC $checkersC $statsC $loglevelC $compareC $skipnewC $skipexistC $nocrossfilesystemC $noupdatemodtimeC $bufferC $filesoptimizeC $driveoptimizeC $dryrunC $extraC\n",
    "elif Mode == \"Move\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf move \"$sourceC\" \"$destinationC\" $transfersC $checkersC $statsC $loglevelC --delete-empty-src-dirs $compareC $skipnewC $skipexistC $nocrossfilesystemC $noupdatemodtimeC $bufferC $filesoptimizeC $driveoptimizeC $dryrunC $extraC\n",
    "elif Mode == \"Sync\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf sync \"$sourceC\" \"$destinationC\" $transfersC $checkersC $statsC $loglevelC $syncmodeC $trackrenamesC $compareC $skipnewC $skipexistC $nocrossfilesystemC $noupdatemodtimeC $bufferC $filesoptimizeC $driveoptimizeC $dryrunC $extraC\n",
    "elif Mode == \"Checker\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf check \"$sourceC\" \"$destinationC\" $checkersC $statsC $loglevelC $compareC $skipnewC $skipexistC $nocrossfilesystemC $noupdatemodtimeC $bufferC $filesoptimizeC $driveoptimizeC $dryrunC $extraC\n",
    "elif Mode == \"Deduplicate\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf dedupe \"$sourceC\" $checkersC $statsC $loglevelC --dedupe-mode $deduplicateC $deduplicatetrashC $compareC $skipnewC $skipexistC $nocrossfilesystemC $noupdatemodtimeC $bufferC $filesoptimizeC $driveoptimizeC $dryrunC $extraC\n",
    "elif Mode == \"Remove Empty Directories\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf rmdirs \"$sourceC\" $statsC $loglevelC $dryrunC $extraC\n",
    "elif Mode == \"Empty Trash\":\n",
    "    !rclone --config=/root/.config/rclone/rclone.conf cleanup \"$sourceC\" $statsC $loglevelC $dryrunC $extraC\n",
    "\n",
    "\n",
    "##### Log Output\n",
    "if Output_Log_File != \"OFF\" and Mode != \"Config\":\n",
    "\n",
    "    ##### Rename log file and output settings.\n",
    "    !mv /root/.rclone_log/rclone_log.txt /root/.rclone_log/rclone_log_$(date +%Y-%m-%d_%H.%M.%S).txt\n",
    "    with open(\"/root/.rclone_log/\" + Mode + \"_settings.txt\", \"w\") as f:\n",
    "        f.write(\"Mode: \" + Mode + \\\n",
    "            \"\\nCompare: \" + Compare + \\\n",
    "            \"\\nSource: \\\"\" + Source + \\\n",
    "            \"\\\"\\nDestination: \\\"\" + Destination + \\\n",
    "            \"\\\"\\nTransfers: \" + str(Transfers) + \\\n",
    "            \"\\nCheckers: \" + str(Checkers) + \\\n",
    "            \"\\nSkip files that are newer on the destination: \" + str(Skip_files_that_are_newer_on_the_destination) + \\\n",
    "            \"\\nSkip all files that exist: \" + str(Skip_all_files_that_exist) + \\\n",
    "            \"\\nDo not cross filesystem boundaries: \" + str(Do_not_cross_filesystem_boundaries) + \\\n",
    "            \"\\nDo not update modtime if files are identical: \" + str(Do_not_update_modtime_if_files_are_identical) + \\\n",
    "            \"\\nDry-Run: \" + str(Dry_Run) + \\\n",
    "            \"\\nOutput Log Level: \" + Output_Log_File + \\\n",
    "            \"\\nExtra Arguments: \\\"\" + Extra_Arguments + \\\n",
    "            \"\\\"\\nSync Moden: \" + Sync_Mode + \\\n",
    "            \"\\nTrack Renames: \" + str(Track_Renames) + \\\n",
    "            \"\\nDeduplicate Mode: \" + Deduplicate_Mode + \\\n",
    "            \"\\nDeduplicate Use Trash: \" + str(Deduplicate_Use_Trash))\n",
    "\n",
    "    ##### Compressing log file.\n",
    "    !rm -f /root/rclone_log.zip\n",
    "    !zip -r -q -j -9 /root/rclone_log.zip /root/.rclone_log/\n",
    "    !rm -rf /root/.rclone_log/\n",
    "    !mkdir -p -m 666 /root/.rclone_log/\n",
    "\n",
    "    ##### Send Log\n",
    "    if os.path.isfile(\"/root/rclone_log.zip\") == True:\n",
    "        try:\n",
    "            files.download(\"/root/rclone_log.zip\")\n",
    "            !rm -f /root/rclone_log.zip\n",
    "            print(\"Sending log to your browser...\")\n",
    "        except:\n",
    "            !mv /root/rclone_log.zip /content/rclone_log_$(date +%Y-%m-%d_%H.%M.%S).zip\n",
    "            print(\"You can use file explorer to download the log file\")\n",
    "    else:\n",
    "        clear_output()\n",
    "        print(\"There is no log file\")\n",
    "    \n",
    "\n",
    "### Operation has been successfully completed.\n",
    "if Mode != \"Config\":\n",
    "    print(\"Operation has been successfully completed\")\n",
    "\n",
    "\n",
    "##### Automatically clear terminal output if the checkbox's value on the top is set to True.\n",
    "if automatically_clear_cell_output is True:\n",
    "    clear_output()\n",
    "else:\n",
    "\tpass##### Automatically clear terminal output if the checkbox's value on the top is set to True.\n",
    "if automatically_clear_cell_output is True:\n",
    "    clear_output()\n",
    "else:\n",
    "\tpass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "#@markdown <font size=5>rclone WebUI Configuration</font><br>\n",
    "#@markdown rclone WebUI Default Credential\n",
    "#@markdown >Username: user</br>Password: pass\n",
    "\n",
    "USE_FREE_TOKEN = True\n",
    "TOKEN = \"\"\n",
    "REGION = \"US\"\n",
    "Tunneling = \"argo_tunnel_(cloudflare)\" #@param [\"argo_tunnel_(cloudflare)\", \"localhost.run\", \"ngrok\"]\n",
    "\n",
    "if Tunneling == \"argo_tunnel_(cloudflare)\":\n",
    "    PORT_FORWARD = \"argotunnel\"\n",
    "elif Tunneling == \"localhost.run\":\n",
    "    PORT_FORWARD = \"localhost\"\n",
    "elif Tunneling == \"ngrok\":\n",
    "    PORT_FORWARD = \"ngrok\"\n",
    "# ================================================================ #\n",
    "\n",
    "import os, signal, random, string, urllib.request, time\n",
    "from IPython.display import HTML, clear_output\n",
    "\n",
    "HOME = os.path.expanduser(\"~\")\n",
    "runW = get_ipython()\n",
    "\n",
    "if not os.path.exists(\"/root/.ipython/mixlab.py\"):\n",
    "    from shlex import split as _spl\n",
    "    from subprocess import run\n",
    "\n",
    "    shellCmd = \"wget -qq https://shirooo39.github.io/MiXLab/resources/mixlab.py \\\n",
    "                -O /root/.ipython/mixlab.py\"\n",
    "    run(_spl(shellCmd))\n",
    "\n",
    "from mixlab import (\n",
    "    runSh,\n",
    "    loadingAn,\n",
    "    PortForward_wrapper,\n",
    "    displayUrl,\n",
    "    findProcess,\n",
    "    CWD,\n",
    "    textAn,\n",
    "    checkAvailable,\n",
    "    displayOutput,\n",
    "    prepareSession,\n",
    "    rcloneConfigurationPath,\n",
    "    accessSettingFile,\n",
    "    memGiB\n",
    ")\n",
    "\n",
    "loadingAn()\n",
    "prepareSession()\n",
    "\n",
    "pid = findProcess(\"rclone\", \"rcd\", isPid=True)\n",
    "\n",
    "try:\n",
    "    os.kill(int(pid), signal.SIGTERM)\n",
    "except TypeError:\n",
    "    pass\n",
    "  \n",
    "cmd = \"rclone rcd --rc-web-gui --rc-addr :5572\" \\\n",
    "      \" --rc-serve\" \\\n",
    "      \" --rc-user=user --rc-pass=pass\" \\\n",
    "      \" --rc-no-auth\" \\\n",
    "      rf\" --config {rcloneConfigurationPath}/rclone.conf\" \\\n",
    "      ' --user-agent \"Mozilla\"' \\\n",
    "      ' --transfers 16' \\\n",
    "      \" &\"\n",
    "\n",
    "runSh(cmd, shell=True)\n",
    "Server = PortForward_wrapper(PORT_FORWARD, TOKEN, USE_FREE_TOKEN, [['rcloneWebUI', 5572, 'http']], 'REGION.lower', [f\"{HOME}/.ngrok2/rcloneWebUI.yml\", 4099]).start('rcloneWebUI', displayB=False)\n",
    "clear_output()\n",
    "displayUrl(Server, pNamU='rclone WebUI : ')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>rclone CLI Configuration</font>\n",
    "# @markdown <p>Run this cell to create and/or edit an rclone configuration.</p>\n",
    "# @markdown > After you have created a configuration, download the configuration file.</br>In the next time you want to mount an rclone drive, simply import the configuration file.\n",
    "USE_FREE_TOKEN = True\n",
    "TOKEN = \"\"  #\n",
    "REGION = \"US\"\n",
    "Tunneling = \"argo_tunnel_(cloudflare)\" #@param [\"argo_tunnel_(cloudflare)\", \"localhost.run\", \"ngrok\"]\n",
    "\n",
    "automatically_clear_cell_output = True  # @param{type: \"boolean\"}\n",
    "\n",
    "if Tunneling == \"argo_tunnel_(cloudflare)\":\n",
    "    PORT_FORWARD = \"argotunnel\"\n",
    "elif Tunneling == \"localhost.run\":\n",
    "    PORT_FORWARD = \"localhost\"\n",
    "elif Tunneling == \"ngrok\":\n",
    "    PORT_FORWARD = \"ngrok\"\n",
    "# ================================================================ #\n",
    "\n",
    "import os, urllib.request, IPython\n",
    "from IPython.display import HTML, clear_output\n",
    "\n",
    "HOME = os.path.expanduser(\"~\")\n",
    "runW = get_ipython()\n",
    "\n",
    "if not os.path.exists(\"/root/.ipython/mixlab.py\"):\n",
    "  from shlex import split as _spl\n",
    "  from subprocess import run\n",
    "\n",
    "  shellCmd = \"wget -qq https://shirooo39.github.io/MiXLab/resources/mixlab.py \\\n",
    "                  -O /root/.ipython/mixlab.py\"\n",
    "  run(_spl(shellCmd))\n",
    "\n",
    "from mixlab import (\n",
    "    prepareSession,\n",
    "    rcloneConfigurationPath,\n",
    "    runSh,\n",
    "    PortForward_wrapper\n",
    ")\n",
    "\n",
    "import codecs, contextlib, locale, os, pty, select, signal, subprocess, sys, termios, time\n",
    "from IPython.utils import text\n",
    "import six\n",
    "from google.colab import _ipython\n",
    "from google.colab import _message\n",
    "from google.colab.output import _tags\n",
    "\n",
    "# Linux read(2) limits to 0x7ffff000 so stay under that for clarity.\n",
    "_PTY_READ_MAX_BYTES_FOR_TEST = 2**20  # 1MB\n",
    "\n",
    "_ENCODING = 'UTF-8'\n",
    "\n",
    "class ShellResult(object):\n",
    "  \"\"\"Result of an invocation of the shell magic.\n",
    "\n",
    "  Note: This is intended to mimic subprocess.CompletedProcess, but has slightly\n",
    "  different characteristics, including:\n",
    "    * CompletedProcess has separate stdout/stderr properties. A ShellResult\n",
    "      has a single property containing the merged stdout/stderr stream,\n",
    "      providing compatibility with the existing \"!\" shell magic (which this is\n",
    "      intended to provide an alternative to).\n",
    "    * A custom __repr__ method that returns output. When the magic is invoked as\n",
    "      the only statement in the cell, Python prints the string representation by\n",
    "      default. The existing \"!\" shell magic also returns output.\n",
    "  \"\"\"\n",
    "\n",
    "  def __init__(self, args, returncode, command_output):\n",
    "    self.args = args\n",
    "    self.returncode = returncode\n",
    "    self.output = command_output\n",
    "\n",
    "  def check_returncode(self):\n",
    "    if self.returncode:\n",
    "      raise subprocess.CalledProcessError(\n",
    "          returncode=self.returncode, cmd=self.args, output=self.output)\n",
    "\n",
    "  def _repr_pretty_(self, p, cycle):  # pylint:disable=unused-argument\n",
    "    # Note: When invoking the magic and not assigning the result\n",
    "    # (e.g. %shell echo \"foo\"), Python's default semantics will be used and\n",
    "    # print the string representation of the object. By default, this will\n",
    "    # display the __repr__ of ShellResult. Suppress this representation since\n",
    "    # the output of the command has already been displayed to the output window.\n",
    "    if cycle:\n",
    "      raise NotImplementedError\n",
    "\n",
    "\n",
    "def _configure_term_settings(pty_fd):\n",
    "  term_settings = termios.tcgetattr(pty_fd)\n",
    "  # ONLCR transforms NL to CR-NL, which is undesirable. Ensure this is disabled.\n",
    "  # http://man7.org/linux/man-pages/man3/termios.3.html\n",
    "  term_settings[1] &= ~termios.ONLCR\n",
    "\n",
    "  # ECHOCTL echoes control characters, which is undesirable.\n",
    "  term_settings[3] &= ~termios.ECHOCTL\n",
    "\n",
    "  termios.tcsetattr(pty_fd, termios.TCSANOW, term_settings)\n",
    "\n",
    "\n",
    "def _run_command(cmd, clear_streamed_output):\n",
    "  \"\"\"Calls the shell command, forwarding input received on the stdin_socket.\"\"\"\n",
    "  locale_encoding = locale.getpreferredencoding()\n",
    "  if locale_encoding != _ENCODING:\n",
    "    raise NotImplementedError(\n",
    "        'A UTF-8 locale is required. Got {}'.format(locale_encoding))\n",
    "\n",
    "  parent_pty, child_pty = pty.openpty()\n",
    "  _configure_term_settings(child_pty)\n",
    "\n",
    "  epoll = select.epoll()\n",
    "  epoll.register(\n",
    "      parent_pty,\n",
    "      (select.EPOLLIN | select.EPOLLOUT | select.EPOLLHUP | select.EPOLLERR))\n",
    "\n",
    "  try:\n",
    "    temporary_clearer = _tags.temporary if clear_streamed_output else _no_op\n",
    "\n",
    "    with temporary_clearer(), _display_stdin_widget(\n",
    "        delay_millis=500) as update_stdin_widget:\n",
    "      # TODO(b/115531839): Ensure that subprocesses are terminated upon\n",
    "      # interrupt.\n",
    "      p = subprocess.Popen(\n",
    "          cmd,\n",
    "          shell=True,\n",
    "          executable='/bin/bash',\n",
    "          stdout=child_pty,\n",
    "          stdin=child_pty,\n",
    "          stderr=child_pty,\n",
    "          close_fds=True)\n",
    "      # The child PTY is only needed by the spawned process.\n",
    "      os.close(child_pty)\n",
    "\n",
    "      return _monitor_process(parent_pty, epoll, p, cmd, update_stdin_widget)\n",
    "  finally:\n",
    "    epoll.close()\n",
    "    os.close(parent_pty)\n",
    "\n",
    "\n",
    "class _MonitorProcessState(object):\n",
    "\n",
    "  def __init__(self):\n",
    "    self.process_output = six.StringIO()\n",
    "    self.is_pty_still_connected = True\n",
    "\n",
    "\n",
    "def _monitor_process(parent_pty, epoll, p, cmd, update_stdin_widget):\n",
    "  \"\"\"Monitors the given subprocess until it terminates.\"\"\"\n",
    "  state = _MonitorProcessState()\n",
    "\n",
    "  # A single UTF-8 character can span multiple bytes. os.read returns bytes and\n",
    "  # could return a partial byte sequence for a UTF-8 character. Using an\n",
    "  # incremental decoder is incrementally fed input bytes and emits UTF-8\n",
    "  # characters.\n",
    "  decoder = codecs.getincrementaldecoder(_ENCODING)()\n",
    "\n",
    "  num_interrupts = 0\n",
    "  echo_status = None\n",
    "  while True:\n",
    "    try:\n",
    "      result = _poll_process(parent_pty, epoll, p, cmd, decoder, state)\n",
    "      if result is not None:\n",
    "        return result\n",
    "      term_settings = termios.tcgetattr(parent_pty)\n",
    "      new_echo_status = bool(term_settings[3] & termios.ECHO)\n",
    "      if echo_status != new_echo_status:\n",
    "        update_stdin_widget(new_echo_status)\n",
    "        echo_status = new_echo_status\n",
    "    except KeyboardInterrupt:\n",
    "      try:\n",
    "        num_interrupts += 1\n",
    "        if num_interrupts == 1:\n",
    "          p.send_signal(signal.SIGINT)\n",
    "        elif num_interrupts == 2:\n",
    "          # Process isn't responding to SIGINT and user requested another\n",
    "          # interrupt. Attempt to send SIGTERM followed by a SIGKILL if the\n",
    "          # process doesn't respond.\n",
    "          p.send_signal(signal.SIGTERM)\n",
    "          time.sleep(0.5)\n",
    "          if p.poll() is None:\n",
    "            p.send_signal(signal.SIGKILL)\n",
    "      except KeyboardInterrupt:\n",
    "        # Any interrupts that occur during shutdown should not propagate.\n",
    "        pass\n",
    "\n",
    "      if num_interrupts > 2:\n",
    "        # In practice, this shouldn't be possible since\n",
    "        # SIGKILL is quite effective.\n",
    "        raise\n",
    "\n",
    "\n",
    "def _poll_process(parent_pty, epoll, p, cmd, decoder, state):\n",
    "  \"\"\"Polls the process and captures / forwards input and output.\"\"\"\n",
    "\n",
    "  terminated = p.poll() is not None\n",
    "  if terminated:\n",
    "    termios.tcdrain(parent_pty)\n",
    "    # We're no longer interested in write events and only want to consume any\n",
    "    # remaining output from the terminated process. Continuing to watch write\n",
    "    # events may cause early termination of the loop if no output was\n",
    "    # available but the pty was ready for writing.\n",
    "    epoll.modify(parent_pty,\n",
    "                 (select.EPOLLIN | select.EPOLLHUP | select.EPOLLERR))\n",
    "\n",
    "  output_available = False\n",
    "\n",
    "  events = epoll.poll()\n",
    "  input_events = []\n",
    "  for _, event in events:\n",
    "    if event & select.EPOLLIN:\n",
    "      output_available = True\n",
    "      raw_contents = os.read(parent_pty, _PTY_READ_MAX_BYTES_FOR_TEST)\n",
    "      import re\n",
    "      decoded_contents = re.sub(r\"http:\\/\\/127.0.0.1:53682\", Server[\"url\"], \n",
    "                                decoder.decode(raw_contents))\n",
    "      sys.stdout.write(decoded_contents)\n",
    "      state.process_output.write(decoded_contents)\n",
    "\n",
    "    if event & select.EPOLLOUT:\n",
    "      # Queue polling for inputs behind processing output events.\n",
    "      input_events.append(event)\n",
    "\n",
    "    # PTY was disconnected or encountered a connection error. In either case,\n",
    "    # no new output should be made available.\n",
    "    if (event & select.EPOLLHUP) or (event & select.EPOLLERR):\n",
    "      state.is_pty_still_connected = False\n",
    "\n",
    "  for event in input_events:\n",
    "    # Check to see if there is any input on the stdin socket.\n",
    "    # pylint: disable=protected-access\n",
    "    input_line = _message._read_stdin_message()\n",
    "    # pylint: enable=protected-access\n",
    "    if input_line is not None:\n",
    "      # If a very large input or sequence of inputs is available, it's\n",
    "      # possible that the PTY buffer could be filled and this write call\n",
    "      # would block. To work around this, non-blocking writes and keeping\n",
    "      # a list of to-be-written inputs could be used. Empirically, the\n",
    "      # buffer limit is ~12K, which shouldn't be a problem in most\n",
    "      # scenarios. As such, optimizing for simplicity.\n",
    "      input_bytes = bytes(input_line.encode(_ENCODING))\n",
    "      os.write(parent_pty, input_bytes)\n",
    "\n",
    "  # Once the process is terminated, there still may be output to be read from\n",
    "  # the PTY. Wait until the PTY has been disconnected and no more data is\n",
    "  # available for read. Simply waiting for disconnect may be insufficient if\n",
    "  # there is more data made available on the PTY than we consume in a single\n",
    "  # read call.\n",
    "  if terminated and not state.is_pty_still_connected and not output_available:\n",
    "    sys.stdout.flush()\n",
    "    command_output = state.process_output.getvalue()\n",
    "    return ShellResult(cmd, p.returncode, command_output)\n",
    "\n",
    "  if not output_available:\n",
    "    # The PTY is almost continuously available for reading input to provide\n",
    "    # to the underlying subprocess. This means that the polling loop could\n",
    "    # effectively become a tight loop and use a large amount of CPU. Add a\n",
    "    # slight delay to give resources back to the system while monitoring the\n",
    "    # process.\n",
    "    # Skip this delay if we read output in the previous loop so that a partial\n",
    "    # read doesn't unnecessarily sleep before reading more output.\n",
    "    # TODO(b/115527726): Rather than sleep, poll for incoming messages from\n",
    "    # the frontend in the same poll as for the output.\n",
    "    time.sleep(0.1)\n",
    "\n",
    "\n",
    "@contextlib.contextmanager\n",
    "def _display_stdin_widget(delay_millis=0):\n",
    "  \"\"\"Context manager that displays a stdin UI widget and hides it upon exit.\n",
    "\n",
    "  Args:\n",
    "    delay_millis: Duration (in milliseconds) to delay showing the widget within\n",
    "      the UI.\n",
    "\n",
    "  Yields:\n",
    "    A callback that can be invoked with a single argument indicating whether\n",
    "    echo is enabled.\n",
    "  \"\"\"\n",
    "  shell = _ipython.get_ipython()\n",
    "  display_args = ['cell_display_stdin', {'delayMillis': delay_millis}]\n",
    "  _message.blocking_request(*display_args, parent=shell.parent_header)\n",
    "\n",
    "  def echo_updater(new_echo_status):\n",
    "    # Note: Updating the echo status uses colab_request / colab_reply on the\n",
    "    # stdin socket. Input provided by the user also sends messages on this\n",
    "    # socket. If user input is provided while the blocking_request call is still\n",
    "    # waiting for a colab_reply, the input will be dropped per\n",
    "    # https://github.com/googlecolab/colabtools/blob/56e4dbec7c4fa09fad51b60feb5c786c69d688c6/google/colab/_message.py#L100.\n",
    "    update_args = ['cell_update_stdin', {'echo': new_echo_status}]\n",
    "    _message.blocking_request(*update_args, parent=shell.parent_header)\n",
    "\n",
    "  yield echo_updater\n",
    "\n",
    "  hide_args = ['cell_remove_stdin', {}]\n",
    "  _message.blocking_request(*hide_args, parent=shell.parent_header)\n",
    "\n",
    "\n",
    "@contextlib.contextmanager\n",
    "def _no_op():\n",
    "  yield\n",
    "\n",
    "prepareSession()\n",
    "\n",
    "Server = PortForward_wrapper(PORT_FORWARD, TOKEN, USE_FREE_TOKEN, [['rcloneConfiguration', 53682, 'http']], 'REGION.lower', [f\"{HOME}/.ngrok2/rcloneConfiguration.yml\", 4074]).start('rcloneConfiguration', displayB=False, v=False)\n",
    "\n",
    "printData = \"\"\"\n",
    "Before finishing the configuration, you will be redirected to an address.\n",
    "Replace the address http://127.0.0.0:53682 with {}\"\"\".format(Server['url'])\n",
    "print(printData)\n",
    "display(HTML('</br>(Click <a href=\"https://raw.githubusercontent.com/tofuliang/Google-Colab-CloudTorrent/master/src/rclone_config_create.gif\" target=\"_blank\">here</a> to see how to do it)</br></br>'))\n",
    "print(f\"{Server['url']}\", end=\"\\n\\n\")\n",
    "_run_command(f\"rclone config --config {rcloneConfigurationPath}/rclone.conf\", False)\n",
    "\n",
    "\n",
    "if automatically_clear_cell_output is True:\n",
    "\tclear_output()\n",
    "else:\n",
    "\tpass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>Mount/Unmount rclone Drive (Optional)</font>\n",
    "# @markdown Mount a remote drive as a local drive on a mountpoint.\n",
    "\n",
    "Cache_Directory = \"DISK\" #@param [\"RAM\", \"DISK\"]\n",
    "# ================================================================ #\n",
    "\n",
    "import os\n",
    "from IPython.display import HTML, clear_output\n",
    "import uuid\n",
    "import ipywidgets as widgets\n",
    "from google.colab import output\n",
    "import re\n",
    "\n",
    "if not os.path.exists(\"/root/.ipython/mixlab.py\"):\n",
    "  from shlex import split as _spl\n",
    "  from subprocess import run\n",
    "\n",
    "  shellCmd = \"wget -qq https://shirooo39.github.io/MiXLab/resources/mixlab.py \\\n",
    "                  -O /root/.ipython/mixlab.py\"\n",
    "  run(_spl(shellCmd))\n",
    "\n",
    "from mixlab import (\n",
    "    runSh,\n",
    "    prepareSession,\n",
    "    rcloneConfigurationPath,\n",
    ")\n",
    "\n",
    "class MakeButton(object):\n",
    "  def __init__(self, title, callback, style):\n",
    "    self._title = title\n",
    "    self._callback = callback\n",
    "    self._style = style\n",
    "  def _repr_html_(self):\n",
    "    callback_id = 'button-' + str(uuid.uuid4())\n",
    "    output.register_callback(callback_id, self._callback)\n",
    "    if self._style != \"\":\n",
    "      style_html = \"p-Widget jupyter-widgets jupyter-button widget-button mod-\" + self._style\n",
    "    else:\n",
    "      style_html = \"p-Widget jupyter-widgets jupyter-button widget-button\"\n",
    "    template = \"\"\"<button class=\"{style_html}\" id=\"{callback_id}\">{title}</button>\n",
    "        <script>\n",
    "          document.querySelector(\"#{callback_id}\").onclick = (e) => {{\n",
    "            google.colab.kernel.invokeFunction('{callback_id}', [], {{}})\n",
    "            e.preventDefault();\n",
    "          }};\n",
    "        </script>\"\"\"\n",
    "    html = template.format(title=self._title, callback_id=callback_id, style_html=style_html)\n",
    "    return html\n",
    "  \n",
    "def ShowAC():\n",
    "  clear_output(wait=True)\n",
    "  display(\n",
    "      widgets.HBox(\n",
    "          [widgets.VBox(\n",
    "              [widgets.HTML(\n",
    "                  '''<h3 style=\"font-family:Trebuchet MS;color:#4f8bd6;margin-top:0px;\">\n",
    "                  Available drive to mount/unmount:</h3>\n",
    "                  '''\n",
    "                  ),\n",
    "               mountNam]\n",
    "               )\n",
    "          ]\n",
    "          )\n",
    "      )\n",
    "  \n",
    "  display(HTML(\"<br>\"), MakeButton(\"Mount\", MountCMD, \"primary\"),\n",
    "          MakeButton(\"Unmount\", unmountCMD, \"danger\"))\n",
    "\n",
    "prepareSession()\n",
    "content = open(f\"{rcloneConfigurationPath}/rclone.conf\").read()\n",
    "avCon = re.findall(r\"^\\[(.+)\\]$\", content, re.M)\n",
    "mountNam = widgets.Dropdown(options=avCon)\n",
    "\n",
    "if Cache_Directory == 'RAM':\n",
    "  cache_path = '/dev/shm'\n",
    "elif Cache_Directory == 'DISK':\n",
    "  os.makedirs('/tmp', exist_ok=True)\n",
    "  cache_path = '/tmp'\n",
    "\n",
    "def MountCMD():\n",
    "    mPoint = f\"/content/drives/{mountNam.value}\"\n",
    "    os.makedirs(mPoint, exist_ok=True)\n",
    "    cmd = rf\"rclone mount {mountNam.value}: {mPoint}\" \\\n",
    "      rf\" --config {rcloneConfigurationPath}/rclone.conf\" \\\n",
    "      ' --user-agent \"Mozilla\"' \\\n",
    "      ' --buffer-size 256M' \\\n",
    "      ' --transfers 10' \\\n",
    "      ' --vfs-cache-mode full' \\\n",
    "      ' --vfs-cache-max-age 0h0m1s' \\\n",
    "      ' --vfs-cache-poll-interval 0m1s' \\\n",
    "      f' --cache-dir {cache_path}' \\\n",
    "      ' --allow-other' \\\n",
    "      ' --daemon'\n",
    "\n",
    "    if runSh(cmd, shell=True) == 0:\n",
    "      print(f\"The drive have been successfully mounted! - \\t{mPoint}\")\n",
    "    else:\n",
    "      print(f\"Failed to mount the drive! - \\t{mPoint}\")\n",
    "\n",
    "def unmountCMD():\n",
    "  mPoint = f\"/content/drives/{mountNam.value}\"\n",
    "  if os.system(f\"fusermount -uz {mPoint}\") == 0:\n",
    "    runSh(f\"rm -r {mPoint}\")\n",
    "    print(f\"The drive have been successfully unmounted! - \\t{mPoint}\")\n",
    "  else:\n",
    "    runSh(f\"fusermount -uz {mPoint}\", output=True)\n",
    "\n",
    "ShowAC()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>Upload Configuration File </font>\n",
    "# @markdown <p>If you already have an rclone configuration file, you can upload it by running this cell.</p>\n",
    "\n",
    "MODE = \"RCONFIG\" # @param ['UTILS', 'RCONFIG', 'RCONFIG_append', \"GENERATELIST\"]\n",
    "REMOTE = \"mnc\" # @param {type:\"string\"}\n",
    "QUERY_PATTERN = \"\" # @param {type:\"string\"}\n",
    "# @markdown > <p><font size=2px>For those who are unable to upload local file: <a href=\"https://stackoverflow.com/a/58661947\">StackOverflow</a></font></p>\n",
    "# ================================================================ #\n",
    "\n",
    "from os import path as _p\n",
    "from IPython.display import HTML, clear_output\n",
    "\n",
    "if not _p.exists(\"/root/.ipython/mixlab.py\"):\n",
    "    from shlex import split as _spl\n",
    "    from subprocess import run  # nosec\n",
    "\n",
    "    shellCmd = \"wget -qq https://shirooo39.github.io/MiXLab/resources/mixlab.py \\\n",
    "                    -O /root/.ipython/mixlab.py\"\n",
    "    run(_spl(shellCmd))  # nosec\n",
    "\n",
    "import importlib, mixlab\n",
    "from google.colab import files  # pylint: disable=import-error #nosec\n",
    "from mixlab import checkAvailable, runSh, rcloneConfigurationPath, prepareSession\n",
    "\n",
    "\n",
    "def generateUploadList():\n",
    "    prepareSession()\n",
    "    if checkAvailable(\"/content/upload.txt\"):\n",
    "        runSh(\"rm -f upload.txt\")\n",
    "    runSh(\n",
    "        f\"rclone --config {rcloneConfigurationPath}/rclone.conf lsf {REMOTE}: --include '{QUERY_PATTERN}' --drive-shared-with-me --files-only --max-depth 1 > /content/upload.txt\",\n",
    "        shell=True,  # nosec\n",
    "    )\n",
    "\n",
    "\n",
    "def uploadLocalFiles():\n",
    "    prepareSession()\n",
    "    if MODE == \"UTILS\":\n",
    "        filePath = \"/root/.ipython/mixlab.py\"\n",
    "    elif MODE in (\"RCONFIG\", \"RCONFIG_append\"):\n",
    "        filePath = f\"{rcloneConfigurationPath}/rclone.conf\"\n",
    "    else:\n",
    "        pass\n",
    "\n",
    "    try:\n",
    "      if checkAvailable(filePath):\n",
    "        runSh(f\"rm -f {filePath}\")\n",
    "      display(HTML(\"<h2 style=\\\"font-family:Trebuchet MS;color:#4f8bd6;\\\">Upload rclone.conf from your local machine.</h2><br>\"))\n",
    "      uploadedFile = files.upload()\n",
    "      fileNameDictKeys = uploadedFile.keys()\n",
    "      fileNo = len(fileNameDictKeys)\n",
    "      if fileNo > 1:\n",
    "          for fn in fileNameDictKeys:\n",
    "              runSh(f'rm -f \"/content/{fn}\"')\n",
    "          return print(\"\\nOnly upload one configuration file!\")\n",
    "      elif fileNo == 0:\n",
    "          return print(\"\\nFile upload cancelled.\")\n",
    "      elif fileNo == 1:\n",
    "          for fn in fileNameDictKeys:\n",
    "              if checkAvailable(f\"/content/{fn}\"):\n",
    "                  if MODE == \"RCONFIG_append\":\n",
    "                    import urllib\n",
    "                    urllib.request.urlretrieve(\"https://shirooo39.github.io/MiXLab/resources/configurations/rclone/rclone.conf\",\n",
    "                                               \"/usr/local/sessionSettings/rclone.conf\")\n",
    "                    with open(f\"/content/{fn}\", 'r+') as r:\n",
    "                      new_data = r.read()\n",
    "                      runSh(f'rm -f \"/content/{fn}\"')\n",
    "                    with open(filePath, 'r+') as f:\n",
    "                      old_data = f.read()\n",
    "                      f.seek(0)\n",
    "                      f.truncate(0)\n",
    "                      f.write(old_data + new_data)\n",
    "                    print(\"\\nUpdate completed.\")\n",
    "                  else:\n",
    "                    runSh(f'mv -f \"/content/{fn}\" {filePath}')\n",
    "                    runSh(f\"chmod 666 {filePath}\")\n",
    "                    runSh(f'rm -f \"/content/{fn}\"')\n",
    "                    importlib.reload(mixlab)\n",
    "                    !rm /content/upload.txt\n",
    "                    clear_output()\n",
    "                    print(\"rclone.conf has been uploaded to Colab!\")\n",
    "              return\n",
    "      else:\n",
    "          print(\"\\nNo file is chosen!\")\n",
    "          return\n",
    "    except:\n",
    "      return print(\"\\nFailed to upload!\")\n",
    "\n",
    "\n",
    "if MODE == \"GENERATELIST\":\n",
    "    generateUploadList()\n",
    "else:\n",
    "    uploadLocalFiles()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>Download Configuration File </font>\n",
    "# @markdown <p>Download configuration file from the VM into your local machine.</p>\n",
    "\n",
    "MODE = \"RCONFIG\" # @param ['UTILS', 'RCONFIG']\n",
    "# ================================================================ #\n",
    "\n",
    "from IPython.display import clear_output\n",
    "from google.colab import files\n",
    "\n",
    "def downloadFile():\n",
    "  if MODE == \"UTILS\":\n",
    "      filePath = \"/root/.ipython/mixlab.py\"\n",
    "  elif MODE == \"RCONFIG\":\n",
    "      filePath = f\"{rcloneConfigurationPath}/rclone.conf\"\n",
    "  else:\n",
    "      pass\n",
    "  try:\n",
    "    files.download(filePath)\n",
    "  except FileNotFoundError:\n",
    "    print(\"File not found!\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "  downloadFile()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>Mounting</font>\n",
    "\n",
    "cmd = rf\"rclone mount drive1: /content/drive1\" \\\n",
    "      ' --user-agent \"Mozilla\"' \\\n",
    "      ' --buffer-size 256M' \\\n",
    "      ' --transfers 10' \\\n",
    "      ' --vfs-cache-mode full' \\\n",
    "      ' --vfs-cache-max-age 0h0m1s' \\\n",
    "      ' --vfs-cache-poll-interval 0m1s' \\\n",
    "      ' --allow-other' \\\n",
    "      ' --daemon'\n",
    "!$cmd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW2"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n",
    "# @markdown <font size=5>Zip</font>\n",
    "\n",
    "Input = \"\\\"/content/sample_data/Untitled Folder\\\"\" #@param {type:\"string\"}\n",
    "SaveTo = \"aa.zip\" #@param {type:\"string\"}\n",
    "Split = \"\" #@param {type:\"string\"}\n",
    "Op = \"Zip\" #@param [\"Zip\", \"Unzip\"] {type:\"raw\"}\n",
    "\n",
    "\n",
    "if os.path.exists(Input):\n",
    "    if Op == \"Zip\":\n",
    "         # !zip -r -q -j -9 $SaveTo $Input\n",
    "        zip(Input, SaveTo, split= Split)\n",
    "\n",
    "    elif Op == \"Unzip\":\n",
    "        if os.path.exists(SaveTo):\n",
    "            print(\"File already exists!\")\n",
    "        else:\n",
    "            unzip(Input, SaveTo)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cellView": "form",
    "id": "ZqEu3vDTqnW5"
   },
   "outputs": [],
   "source": [
    "#@title { form-width: \"2%\" }\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
