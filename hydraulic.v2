{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "cellView": "form",
        "id": "6mYSH1yDOwvw"
      },
      "outputs": [],
      "source":   [
        "\n",
        "#@title { form-width: \"2%\" }\n",
        "#@markdown \n",
        "\n",
        "import os, sys, platform, pytz, time, traceback, unicodedata, re, requests, random\n",
        "import ipywidgets as widgets\n",
        "from bs4 import BeautifulSoup\n",
        "from datetime import date, datetime\n",
        "from threading import Thread\n",
        "from IPython.display import Javascript\n",
        "pytz.timezone('Turkey')\n",
        "\n",
        "#### Init\n",
        "td_id = \"TD1\"\n",
        "td_email = \"default@mail.com\"\n",
        "tz = pytz.timezone('Turkey')\n",
        "os.environ['TZ'] = 'Turkey'\n",
        "\n",
        "nowstr = lambda separete = False: datetime.now(tz).strftime(\"%y-%m-%d-%H-%M-%S\") if separete else str(round(time.time()))\n",
        "rand = lambda: str(random.randint(10000000, 100000000))\n",
        "tb = lambda e: ''.join(traceback.format_tb(e.__traceback__))\n",
        "def js(script: str, ignore_result: bool= False) -> None: pass\n",
        "ex = traceback.format_exc\n",
        "hide = widgets.Output()\n",
        "\n",
        "IS_ENV_COLAB = 'google.colab' in sys.modules\n",
        "WINDOWS = 'Windows'\n",
        "LINUX = 'Linux'\n",
        "\n",
        "# init UI\n",
        "\n",
        "INFO_EVENT = 0\n",
        "ERROR_EVENT = 10\n",
        "SUCCUSS_EVENT = 20\n",
        "\n",
        "BLUE_COLOR = '#085fb1'\n",
        "LIGHTBLUE_COLOR = '#469dff'\n",
        "GREYCOLOR = '#c2c2c2'\n",
        "DARKGERYCOLOR = '#474747'\n",
        "ORANGE_500 = '#FF9800'\n",
        "\n",
        "ACCENT_COLOR = LIGHTBLUE_COLOR\n",
        "SUCCESS_COLOR = '#039129'\n",
        "FAIL_COLOR = '#9c0909'\n",
        "LOADING_COLOR = '#d96d1a'\n",
        "WARNING_COLOR = ORANGE_500\n",
        "\n",
        "FONTFAMILY_GLOBAL = 'system-ui'\n",
        "MESSAGE_CONTAINER_HEIGHT = '250px'\n",
        "MESSAGE_CONTAINER_PADDING = '15% 0 0 0' \n",
        "MAINBOX_HEIGHT = '800px'\n",
        "\n",
        "def gethtmltext(text, tag= \"span\", elid=\"\", elclass= \"\", fontsize= \"32px\", style= \"\", color= ACCENT_COLOR, animated= False):\n",
        "    if not elid:\n",
        "        elid = 'el' + rand()\n",
        "    colorstyle = f\"color: {color};\" if color != ACCENT_COLOR else ''\n",
        "    animation = getcssblinkanimation(color= color, elementid= elid) if animated else ''\n",
        "    return f'<{tag} id=\"{elid}\" class=\"{elclass}\" style=\"font-size: {fontsize}; {colorstyle} {style}\">{text}</{tag}>{animation}'\n",
        "\n",
        "def getcssblinkanimation(color, elementid = \"\", elementclass = \"\"):\n",
        "    if not elementclass and not elementid:\n",
        "        return None\n",
        "    shadecolor = color[:-2] + '2c' if len(color) == 9 else color + '2c'\n",
        "    styletag = '<style>'\n",
        "    idpart = f'#{elementid}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementid else \"\"\n",
        "    animationpart = f' @keyframes color-change {{ 0% {{ color: {color}; }} 50% {{ color: {shadecolor}; }} 100% {{ color: {color} ; }} }}</style>'\n",
        "    classpart = f'.{elementclass}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementclass else \"\"\n",
        "    return styletag + idpart + classpart + animationpart\n",
        "\n",
        "def getloadingview(text):\n",
        "    elid= 'el-' + rand()\n",
        "    t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    spinnerhtml = \"<div class=loadingio-spinner-spinner-m4dbaxm5cdf><div class=ldio-orkmsj9nbq><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><style>@keyframes ldio-orkmsj9nbq{0%{opacity:1}100%{opacity:0}}.ldio-orkmsj9nbq div{left:47px;top:16px;position:absolute;animation:ldio-orkmsj9nbq linear 1.1111111111111112s infinite;background:#184cad;width:6px;height:12px;border-radius:2.16px;transform-origin:3px 34px}.ldio-orkmsj9nbq div:first-child{transform:rotate(0);animation-delay:-1.0185185185185184s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(2){transform:rotate(30deg);animation-delay:-.9259259259259258s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(3){transform:rotate(60deg);animation-delay:-.8333333333333333s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(4){transform:rotate(90deg);animation-delay:-.7407407407407407s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(5){transform:rotate(120deg);animation-delay:-.6481481481481481s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(6){transform:rotate(150deg);animation-delay:-.5555555555555555s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(7){transform:rotate(180deg);animation-delay:-.4629629629629629s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(8){transform:rotate(210deg);animation-delay:-370.3703703703703ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(9){transform:rotate(240deg);animation-delay:-277.7777777777777ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(10){transform:rotate(270deg);animation-delay:-.18518518518518517s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(11){transform:rotate(300deg);animation-delay:-92.59259259259258ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(12){transform:rotate(330deg);animation-delay:0s;background:#184cad}.loadingio-spinner-spinner-m4dbaxm5cdf{width:100px;height:100px;display:inline-block;overflow:hidden;background:0 0}.ldio-orkmsj9nbq{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-orkmsj9nbq div{box-sizing:content-box}</style>\"\n",
        "    loading_container = f'<div style=\"height:{MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text + \" \", elid= elid, style=t1style)} {spinnerhtml}</div>' + getcssblinkanimation(color= ACCENT_COLOR, elementid=elid)\n",
        "    loadingview = widgets.HTML(loading_container)\n",
        "    loadingview.name = \"Loading\"\n",
        "    return loadingview\n",
        "\n",
        "display(widgets.VBox((getloadingview(\"Setting up requirments\"),), layout= {\"height\": MAINBOX_HEIGHT, 'width': '100%'}))\n",
        "\n",
        "# Drive\n",
        "\n",
        "if IS_ENV_COLAB:\n",
        "    time.tzset()\n",
        "    from google.colab import output, drive\n",
        "    from google.colab.output import eval_js as js\n",
        "    with hide:\n",
        "        if not os.path.exists(\"/content/drive\"):\n",
        "            drive.mount('/content/drive')\n",
        "\n",
        "    if os.path.exists(\"/content/sample_data\"): \n",
        "        !rm -r \"/content/sample_data\"\n",
        "\n",
        "# Platform\n",
        "\n",
        "ENV_OS = platform.uname().system\n",
        "if ENV_OS == WINDOWS:\n",
        "    NULL_STREAM =  ' > NUL' \n",
        "elif ENV_OS == LINUX:\n",
        "    NULL_STREAM = ' > /dev/null 2>&1' \n",
        "\n",
        "UICLICKER_STOP = \"uiclicker\"\n",
        "UICLICKER_RUN = \"runuiclicker\"\n",
        "SIMULATECLICK_DESC = 'C' + nowstr()\n",
        "\n",
        "# Log\n",
        "\n",
        "LOG_FILENAME = f\"td-log-{nowstr()}\"\n",
        "LOG_DIR_LOCAL = '/content/tdlogs' if ENV_OS == 'Linux' else \"'c:/td/logs'\"\n",
        "LOG_FILE = f\"{LOG_DIR_LOCAL}/{LOG_FILENAME}.txt\"\n",
        "INFO_LOG = \"Info\"\n",
        "WARNING_LOG = \"Warning\"\n",
        "ERROR_LOG = \"Error\"\n",
        "MAIN = \"Main\"\n",
        "\n",
        "os.makedirs(LOG_DIR_LOCAL, exist_ok = True)\n",
        "\n",
        "def append_lines(filename,  line = '', lines = None):\n",
        "    if lines or line:\n",
        "        with open(filename, \"a+\") as file:\n",
        "            file.seek(0)\n",
        "            data = file.read(100)\n",
        "            if len(data) > 0:\n",
        "                file.write(\"\\n\")\n",
        "\n",
        "            if line:\n",
        "                file.write(line + \"\\n\")\n",
        "\n",
        "            if lines:\n",
        "                for i in range(len(lines)):\n",
        "                    file.write(lines[i])\n",
        "                    if i < len(lines) - 1:\n",
        "                        file.write(\"\\n\")\n",
        "        return True\n",
        "    return False \n",
        "  \n",
        "class Logger: \n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def getInstance():\n",
        "        if Logger._instance == None:\n",
        "            Logger()\n",
        "        return Logger._instance\n",
        "\n",
        "    def __init__(self):\n",
        "        if Logger._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")\n",
        "        else:\n",
        "            Logger._instance = self\n",
        "\n",
        "    logs = []\n",
        "    log_drv = \"\"\n",
        "    def init(self, hold = False):\n",
        "        if hold:\n",
        "            self.logs.append(self.makelog('Log started.', INFO_LOG, MAIN))\n",
        "        else:\n",
        "            self.log( 'Log started.', INFO_LOG,  MAIN)\n",
        "\n",
        "    def makelog(self, text: str, log_type: str= 'Info', source: str= MAIN) -> str:\n",
        "        now = datetime.now(tz).strftime(\"%y:%m:%d:%H:%M:%S\")\n",
        "        source = source.replace('_', ' ').title()\n",
        "        start = \"{} {:^7} {}:\". format(now, log_type, source)\n",
        "        text = text.replace(\"\\n\", f\"\\n{len(start)*' '} \")\n",
        "        lg = f\"{start} {text}\"\n",
        "        return lg\n",
        "\n",
        "    def queue(self, text: str, log_type: str= 'Info', source= MAIN):\n",
        "        self.logs.append(self.makelog(text, log_type = log_type, source = source))\n",
        "\n",
        "    def info(self, text: str= \"\", lines = None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "                self.queue(line, INFO_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, INFO_LOG, src)\n",
        "\n",
        "    def warning(self, text: str= \"\", lines= None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "              self.queue(line, WARNING_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, WARNING_LOG, src)  \n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def error(self, text: str= \"\", lines = None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "                self.queue(line, ERROR_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, ERROR_LOG, src)\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def release(self):\n",
        "        if (self.logs):\n",
        "            if self.log(logs = self.logs):\n",
        "                self.logs.clear()\n",
        "            else:\n",
        "                print(\"Logger: An error happend while trying to write log. logs are preserved.\")\n",
        "\n",
        "    def log(self, text = '', log_type= INFO_LOG,  source = MAIN, logs = None): \n",
        "        if not logs and not text:\n",
        "            return True\n",
        "        res = False\n",
        "        if text:\n",
        "            text = self.makelog(text, log_type, source)\n",
        "        res = append_lines(filename = LOG_FILE, line = text, lines = logs)\n",
        "\n",
        "        if res:\n",
        "            #self.save_log()\n",
        "            return True\n",
        "        else:\n",
        "            print(\"Logger: log: An error happened while trying to write log.\")\n",
        "            return False\n",
        "\n",
        "    def save_log(self):\n",
        "        if self.log_drv and os.path.exists(self.log_drv) and os.path.isfile(LOG_FILE):\n",
        "            !rsync -I \"$log_file\" \"$log_drv_file\"\n",
        "\n",
        "logger = Logger.getInstance()   \n",
        "info = logger.info\n",
        "error = logger.error\n",
        "warning = logger.warning\n",
        "release = logger.release\n",
        "\n",
        "if not os.path.isfile(LOG_FILE):\n",
        "    logger.init(True)\n",
        "    info(f\"New Session.\")\n",
        "\n",
        "#### Setup\n",
        "\n",
        "LOCALBASE_DEFAULT = '/content/Downloads' if ENV_OS == LINUX else \"c:/td/Downloads\"\n",
        "REMOTEBASE_DEFAULT = '/Downloads'\n",
        "\n",
        "MOVIES_DRIVE_PATH_DEFAULT = '/content/drive/MyDrive/Movies' \n",
        "TV_DRIVE_PATH_DEFAULT = '/content/drive/MyDrive/TV' \n",
        "GENERAL_DRIVE_PATH_DEFAULT = '/content/drive/MyDrive/Downloads'\n",
        "MUSIC_DRIVE_PATH_DEFAULT = '/content/drive/MyDrive/Music'\n",
        "\n",
        "general_path = GENERAL_DRIVE_PATH_DEFAULT\n",
        "movies_path = MOVIES_DRIVE_PATH_DEFAULT\n",
        "tv_path = TV_DRIVE_PATH_DEFAULT\n",
        "music_path = MUSIC_DRIVE_PATH_DEFAULT\n",
        "\n",
        "moviesbackups = set()\n",
        "tvbackups = set()\n",
        "musicbackups = set()\n",
        "generalbackups = set()\n",
        "uncompleted_sources = set()\n",
        "\n",
        "downloads_dict = {}\n",
        "active = []\n",
        "completed = [] \n",
        "uncompleted = []\n",
        "watched_movies_list = []\n",
        "watched_list_url = \"https://www.imdb.com/search/title/?title_type=feature&lists=ls047519430&view=simple&sort=alpha,asc&count=250&start=\"\n",
        "\n",
        "checkpoint = '.ipynb_checkpoints'\n",
        "savetodrive = 'Save to Google Drive'\n",
        "savetoftp = 'Save to FTP'\n",
        "\n",
        "class SystemConfig():\n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if SystemConfig._instance == None:\n",
        "            SystemConfig()\n",
        "        return SystemConfig._instance\n",
        "    def __init__(self):\n",
        "        if SystemConfig._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")            \n",
        "        else:\n",
        "            SystemConfig._instance = self\n",
        "\n",
        "    savetoftpconst = 1\n",
        "    savetogdriveconst = 2\n",
        "\n",
        "    savetoftp = False\n",
        "    savetogdrive = False\n",
        "\n",
        "    ltenabled = True\n",
        "    activedownloads = 5\n",
        "    spotifyenabled = False\n",
        "    \n",
        "    gdriveenabled = False\n",
        "    ftpenabled = True\n",
        "    backupenabled = False\n",
        "    \n",
        "    ftpuser = \"\"\n",
        "    ftppassword = \"\"\n",
        "    ftphost = \"\"\n",
        "\n",
        "    localdownloadbase = LOCALBASE_DEFAULT\n",
        "    remotedownloadbase = REMOTEBASE_DEFAULT\n",
        "\n",
        "    generallibrarypath = GENERAL_DRIVE_PATH_DEFAULT\n",
        "    musiclibrarypath = MUSIC_DRIVE_PATH_DEFAULT\n",
        "    movieslibrarypath = MOVIES_DRIVE_PATH_DEFAULT\n",
        "    tvlibrarypath = TV_DRIVE_PATH_DEFAULT\n",
        "    setupthreads= set()\n",
        "    pkgs = set()\n",
        "\n",
        "config = SystemConfig.instance()\n",
        "\n",
        "def get_installed_pip_pkgs():\n",
        "    with hide:\n",
        "        cmd = !pip list\n",
        "        hide.clear_output()\n",
        "        return cmd[2:]\n",
        "\n",
        "config.pkgs = get_installed_pip_pkgs()\n",
        "\n",
        "def enablegdrive():\n",
        "    if IS_ENV_COLAB and not os.path.exists(\"/content/drive\"):\n",
        "        drive.mount('/content/drive')\n",
        "        if os.path.exists(\"/content/drive\"):\n",
        "            info(\"Google drive is mounted.\")\n",
        "            config.savetogdrive = True\n",
        "        else:\n",
        "            config.savetogdrive = False\n",
        "\n",
        "def setuppathes():\n",
        "    global general_path, movies_path, tv_path, music_path\n",
        "    if IS_ENV_COLAB and os.path.exists(\"/content/drive\"):\n",
        "        if general_path:\n",
        "            if not os.path.exists(general_path):\n",
        "                os.makedirs(general_path, exist_ok = True)     \n",
        "            info(f\"General saving path: {general_path}\")\n",
        "        else:\n",
        "            error(f\"General saving path isn't set.\")\n",
        "            general_path = f\"{config.localdownloadbase}/Downloads\"\n",
        "            os.makedirs(general_path, exist_ok = True)\n",
        "\n",
        "        if movies_path:\n",
        "            if not os.path.exists(movies_path):\n",
        "                os.makedirs(movies_path, exist_ok = True)   \n",
        "            info(f\"Movies saving path: {movies_path}\")\n",
        "        else:\n",
        "            error(f\"Movies saving path isn't set.\")\n",
        "            movies_path = f\"{config.localdownloadbase}/Movies\"\n",
        "            os.makedirs(movies_path, exist_ok = True)\n",
        "\n",
        "        if tv_path:\n",
        "            if not os.path.exists(tv_path):\n",
        "                os.makedirs(tv_path, exist_ok = True)    \n",
        "            info(f\"TV saving path: {tv_path}\")\n",
        "        else:\n",
        "            error(f\"TV saving path isn't set\")\n",
        "            tv_path = f\"{config.localdownloadbase}/TV Shows\"\n",
        "            os.makedirs(tv_path, exist_ok = True)\n",
        "\n",
        "        if music_path:\n",
        "            if not os.path.exists(music_path):\n",
        "                os.makedirs(music_path, exist_ok = True)  \n",
        "            info(f\"Music saving path: {music_path}\")\n",
        "        else:\n",
        "            error(f\"Music saving path isn't set\")\n",
        "            music_path = f\"{config.localdownloadbase}/Music\"\n",
        "            os.makedirs(music_path, exist_ok = True)\n",
        "    else:\n",
        "        general_path = f\"{config.localdownloadbase}/Downloads\"\n",
        "        movies_path = f\"{config.localdownloadbase}/Movies\"\n",
        "        tv_path = f\"{config.localdownloadbase}/TV Shows\"\n",
        "        music_path = f\"{config.localdownloadbase}/Music\"\n",
        "        os.makedirs(general_path, exist_ok = True)\n",
        "        os.makedirs(movies_path, exist_ok = True)\n",
        "        os.makedirs(tv_path, exist_ok = True)\n",
        "        os.makedirs(music_path, exist_ok = True)\n",
        "        info(f\"Downloads base is set to: {config.localdownloadbase}\")\n",
        "        \n",
        "    if general_path:\n",
        "        checkuncompletesources()        \n",
        " \n",
        "def checkuncompletesources():\n",
        "    info(f\"Checking uncomplete downloads sources in: {general_path}/.uncomplete\")\n",
        "    p0 = general_path + \"/\" + \".uncomplete\"\n",
        "    if os.path.exists(p0):\n",
        "        if is_empty(p0):\n",
        "            !rm -r \"$p0\"\n",
        "        else:\n",
        "            info(f\"Adding uncomplete downloads sources: {p0}\")\n",
        "            uncompleted_sources.append(p0)\n",
        "\n",
        "def enablelt():\n",
        "    if  not 'ses' in globals():\n",
        "        global ses\n",
        "        ses = lt.session()\n",
        "        User_Agent = '\"Utorrent\"/3.5.5' \n",
        "        sett = {'allow_multiple_connections_per_ip': True, 'active_downloads': config.activedownloads, 'active_seeds':1, 'active_checking': 3, 'active_limit':10, 'announce_to_all_tiers': True, 'announce_to_all_trackers':True, 'allow_multiple_connections_per_ip':True, 'auto_sequential':True, 'auto_manage_interval': 30, 'connections_limit':2330, 'connection_speed': 80, 'connections_slack':50, 'close_redundant_connections':True, 'file_pool_size':20, 'local_service_announce_interval':200, 'max_rejects':8, 'max_peerlist_size': 5000, 'max_paused_peerlist_size': 2000, 'max_failcount':3, 'min_announce_interval':30, 'min_reconnect_time': 20, 'peer_timeout':20, 'request_timeout':10, 'half_open_limit': 100, 'send_buffer_watermark':5*1024*1024, 'strict_end_game_mode':True, 'seed_time_limit': 60, 'tracker_completion_timeout':30, 'upload_rate_limit':0} #'user_agent': User_Agent,'inactivity_timeout':20, 'ban_web_seeds':False,\n",
        "        ses.apply_settings(sett)\n",
        "        info(f\"LT Client session started.\\nListening ports: 6881, 6891. User agent: {User_Agent}, Active downloads: {config.activedownloads}.\")\n",
        "        for item in uncompleted_sources:\n",
        "            info(f\"Uncomplete source: {item}\")\n",
        "\n",
        "def normalizestring(input_str):\n",
        "    nfkd_form = unicodedata.normalize('NFKD', input_str)\n",
        "    return u\"\".join([c for c in nfkd_form if not unicodedata.combining(c)])\n",
        "\n",
        "def find_title(title_raw, year_raw):\n",
        "    year = re.search(year_re, year_raw)\n",
        "    year = year.group() if year else \"\"\n",
        "    title = \"{0} {1}\".format(title_raw, year)\n",
        "    table = title.maketrans(\"/\",\" \",\":'(,?)\")\n",
        "    title = title.translate(table)\n",
        "    return normalizestring(title.replace(\"&\", \"and\"))\n",
        "\n",
        "def scrape_watched_movies_list(startpage= 1, endpage = 1):\n",
        "    info(f\"Scrapping watched movies list from IMDB. URL:{watched_list_url}.\")\n",
        "    try:\n",
        "        for i in range(startpage-1, endpage):\n",
        "            currentpage = watched_list_url + str(i*251)\n",
        "            imdbresponse = requests.get(currentpage, headers = {\"Accept-Language\": \"en-US\"})\n",
        "            soup = BeautifulSoup(imdbresponse.text,'html.parser')    \n",
        "            scrape = soup.find(\"div\", {\"class\":\"lister-list\"})\n",
        "            if not scrape :\n",
        "                return\n",
        "            all_items = scrape.findAll(class_=\"lister-item-header\")\n",
        "            for i in range(len(all_items)):\n",
        "                year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
        "                title_raw = all_items[i].a.text\n",
        "                title = find_title(title_raw, year_raw)      \n",
        "                watched_movies_list.append(title)\n",
        "        info(f\"Scrapped watched movies: {len(watched_movies_list)} movie.\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    \n",
        "def installpippkg(pkg):\n",
        "    with hide:\n",
        "        cmd = f\"pip install {pkg} {NULL_STREAM}\"\n",
        "        o = !$cmd \n",
        "        hide.clear_output()\n",
        "    return True\n",
        "\n",
        "def uninstallpippkg(pkg):\n",
        "    with hide:\n",
        "        cmd = f\"pip uninstall {pkg} -y {NULL_STREAM}\"\n",
        "        o = !$cmd\n",
        "        hide.clear_output()\n",
        "    return True\n",
        "\n",
        "SETUP_TITLE = \"setup_title\"\n",
        "SETUP_LT = \"setup_lt\"\n",
        "DRIVE_AND_PATHES = \"enable_drive\"\n",
        "SCRAPE_WATCHED_LIST = \"scrape_watched_list\"\n",
        "\n",
        "if IS_ENV_COLAB and not 'init' in globals():   \n",
        "    if os.path.exists(\"/content/drive\"):\n",
        "        info(\"Google drive is mounted.\")\n",
        "\n",
        "    info(\"Installing requirments packages.\")\n",
        "    def setup_lt():\n",
        "        if not 'libtorrent' in config.pkgs:\n",
        "            try:\n",
        "                info(\"Installing package 'libtorrent'\")\n",
        "                installpippkg('libtorrent')\n",
        "                config.pkgs.append('libtorrent')\n",
        "            except Exception as e:\n",
        "                error(ex())\n",
        "                updatestatushtml('An error happened while enabling lt.', ERROR_EVENT)\n",
        "        if not 'lt' in globals():  \n",
        "                global  lt\n",
        "                import libtorrent as lt\n",
        "                info(\"Package 'libtorrent' was installed and in imported to environment.\")\n",
        "                enablelt()      \n",
        "        else:\n",
        "            info(\"Package 'lt' is already installed.'\")                    \n",
        "        release()\n",
        "\n",
        "    enable_lt_task = Thread(target= setup_lt)\n",
        "    enable_lt_task.name = SETUP_LT\n",
        "    config.setupthreads.add(enable_lt_task)\n",
        "    enable_lt_task.start()\n",
        "\n",
        "    if not watched_movies_list:\n",
        "        scrape_watchedmovielist_task = Thread(target= scrape_watched_movies_list, args=(1,2))\n",
        "        scrape_watchedmovielist_task.name = SCRAPE_WATCHED_LIST\n",
        "        config.setupthreads.add(scrape_watchedmovielist_task)\n",
        "        scrape_watchedmovielist_task.start()\n",
        "\n",
        "    pathestask = Thread(target= setuppathes)\n",
        "    pathestask.start()\n",
        "\n",
        "def arethreadsworking(threadset: set[Thread], v= False):\n",
        "    alivethreads = set()\n",
        "    for thread in threadset:\n",
        "        if thread.is_alive():\n",
        "            alivethreads.add(thread.name)\n",
        "            if v:\n",
        "                print(f'Alive: {thread.name}')\n",
        "    return alivethreads if alivethreads else False\n",
        "\n",
        "##\n",
        "\n",
        "import urllib\n",
        "import pandas as pd\n",
        "import panel\n",
        "from bokeh.models.widgets.tables import CheckboxEditor\n",
        "panel.extension('tabulator')\n",
        "\n",
        "#### Init / utils\n",
        "\n",
        "def check_pip_pgks_installed(check_pkgs, installmissing = False, v= False):\n",
        "    pkgre = r'^[A-Za-z0-9\\-]+'\n",
        "    for pkg in config.pkgs:\n",
        "        mch = re.search(pkgre, pkg)\n",
        "        res = mch.group()\n",
        "        if res in check_pkgs:\n",
        "            check_pkgs.remove(res)\n",
        "        if len(check_pkgs) == 0:\n",
        "            break\n",
        "    if check_pkgs:\n",
        "        if installmissing:\n",
        "            for pkg in check_pkgs:\n",
        "                installpippkg(pkg)\n",
        "            return True            \n",
        "        else:    \n",
        "            msg = f'Missing packages: {\", \".join(check_pkgs)}'\n",
        "            if v:\n",
        "                print(msg)\n",
        "            return check_pkgs\n",
        "    else:\n",
        "        return True\n",
        "    \n",
        "def getattrs(obj):\n",
        "    attrs = []\n",
        "    for attrs in dir(obj):\n",
        "        if not attrs.startswith(\"__\"):\n",
        "            attrs.append((attrs, getattr(obj, attrs)))\n",
        "    return attrs\n",
        "\n",
        "def getattrstr(obj, filter = True, filter_empty = False, add_line = False):\n",
        "    attrstr = ''\n",
        "    pre = '\\n' if add_line else ', '\n",
        "    i = True\n",
        "    for attrs in dir(obj):\n",
        "        if filter and attrs.startswith(\"__\"):\n",
        "            continue\n",
        "        val = getattr(obj, attrs)\n",
        "        if filter_empty and not val:\n",
        "            continue\n",
        "        if i :\n",
        "            attrstr += \"%s =  %r\" % (attrs, val)\n",
        "            i = False\n",
        "        else:\n",
        "            attrstr += \"%s%s =  %r\" % (pre, attrs, getattr(obj, attrs))\n",
        "    return attrstr\n",
        "\n",
        "def dump(obj, padding = True, filterprefixed = True, types= set(), filtertypes= set()):\n",
        "    pad = \"              \" if padding else \"\"\n",
        "    for attrname in dir(obj):\n",
        "        attrval = getattr(obj, attrname)\n",
        "        if (filterprefixed and attrname.startswith(\"_\")):\n",
        "            continue\n",
        "        if types:\n",
        "            if type(attrval) in types:\n",
        "                print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "            continue\n",
        "        elif filtertypes:\n",
        "            if not (type(attrval) in filtertypes):\n",
        "                print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "        else:\n",
        "            print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "\n",
        "  \n",
        "def list_lines(lines, str = False):\n",
        "    if lines:\n",
        "        if str:\n",
        "            rtn = ''\n",
        "            for r in lines:\n",
        "                if r:\n",
        "                    rtn += (r +'\\n')\n",
        "            return rtn\n",
        "        if not str:  \n",
        "            for line in lines:\n",
        "                print(line)\n",
        "#\n",
        "import string\n",
        "SMALL = r'a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v\\.?|via|vs\\.?'\n",
        "PUNCT = r\"\"\"!\"“#$%&'‘()*+,\\-–‒—―./:;?@[\\\\\\]_`{|}~\"\"\"\n",
        "\n",
        "SMALL_WORDS = re.compile(r'^(%s)$' % SMALL, re.I)\n",
        "SMALL_FIRST = re.compile(r'^([%s]*)(%s)\\b' % (PUNCT, SMALL), re.I)\n",
        "SMALL_LAST = re.compile(r'\\b(%s)[%s]?$' % (SMALL, PUNCT), re.I)\n",
        "SUBPHRASE = re.compile(r'([:.;?!\\-–‒—―][ ])(%s)' % SMALL)\n",
        "MAC_MC = re.compile(r\"^([Mm]c|MC)(\\w.+)\")\n",
        "MR_MRS_MS_DR = re.compile(r\"^((m((rs?)|s))|Dr)$\", re.I)\n",
        "INLINE_PERIOD = re.compile(r'[\\w][.][\\w]', re.I)\n",
        "UC_ELSEWHERE = re.compile(r'[%s]*?[a-zA-Z]+[A-Z]+?' % PUNCT)\n",
        "CAPFIRST = re.compile(r\"^[%s]*?([\\w])\" % PUNCT)\n",
        "APOS_SECOND = re.compile(r\"^[dol]['‘][\\w]+(?:['s]{2})?$\", re.I)\n",
        "UC_INITIALS = re.compile(r\"^(?:[A-Z]\\.|[A-Z]\\.[A-Z])+$\")\n",
        "\n",
        "class Immutable(object):\n",
        "    pass\n",
        "class ImmutableString(str, Immutable):\n",
        "    pass\n",
        "class ImmutableBytes(bytes, Immutable):\n",
        "    pass\n",
        "\n",
        "def _mark_immutable(text):\n",
        "    if isinstance(text, bytes):\n",
        "        return ImmutableBytes(text)\n",
        "    return ImmutableString(text)\n",
        "\n",
        "def set_small_word_list(small=SMALL):\n",
        "    global SMALL_WORDS\n",
        "    global SMALL_FIRST\n",
        "    global SMALL_LAST\n",
        "    global SUBPHRASE\n",
        "    SMALL_WORDS = re.compile(r'^(%s)$' % small, re.I)\n",
        "    SMALL_FIRST = re.compile(r'^([%s]*)(%s)\\b' % (PUNCT, small), re.I)\n",
        "    SMALL_LAST = re.compile(r'\\b(%s)[%s]?$' % (small, PUNCT), re.I)\n",
        "    SUBPHRASE = re.compile(r'([:.;?!][ ])(%s)' % small)\n",
        "\n",
        "def title(text, callback=None, small_first_last=True):\n",
        "    \"\"\"\n",
        "    :param text: Titlecases input text\n",
        "    :param callback: Callback function that returns the title-case version of a specific word\n",
        "    :param small_first_last: Capitalize small words (e.g. 'A') at the beginning; disabled when recursing\n",
        "    :type text: str\n",
        "    :type callback: function\n",
        "    :type small_first_last: bool\n",
        "\n",
        "    This filter changes all words to Title Caps, and attempts to be clever\n",
        "    about *un*capitalizing SMALL words like a/an/the in the input.\n",
        "\n",
        "    The list of \"SMALL words\" which are not capped comes from the New York Times Manual of Style, plus 'vs' and 'v'.\n",
        "\n",
        "    \"\"\"\n",
        "    lines = re.split('[\\r\\n]+', text)\n",
        "    processed = []\n",
        "    for line in lines:\n",
        "        all_caps = line.upper() == line\n",
        "        words = re.split('[\\t ]', line)\n",
        "        tc_line = []\n",
        "        for word in words:\n",
        "            if callback:\n",
        "                new_word = callback(word, all_caps=all_caps)\n",
        "                if new_word:\n",
        "                    # Address #22: If a callback has done something\n",
        "                    # specific, leave this string alone from now on\n",
        "                    tc_line.append(_mark_immutable(new_word))\n",
        "                    continue\n",
        "\n",
        "            if all_caps:\n",
        "                if UC_INITIALS.match(word):\n",
        "                    tc_line.append(word)\n",
        "                    continue\n",
        "\n",
        "            if APOS_SECOND.match(word):\n",
        "                if len(word[0]) == 1 and word[0] not in 'aeiouAEIOU':\n",
        "                    word = word[0].lower() + word[1] + word[2].upper() + word[3:]\n",
        "                else:\n",
        "                    word = word[0].upper() + word[1] + word[2].upper() + word[3:]\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "\n",
        "            match = MAC_MC.match(word)\n",
        "            if match:\n",
        "                tc_line.append(\"%s%s\" % (match.group(1).capitalize(),\n",
        "                                         title(match.group(2), callback, True)))\n",
        "                continue\n",
        "\n",
        "            match = MR_MRS_MS_DR.match(word)\n",
        "            if match:\n",
        "                word = word[0].upper() + word[1:]\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "\n",
        "            if INLINE_PERIOD.search(word) or (not all_caps and UC_ELSEWHERE.match(word)):\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "            if SMALL_WORDS.match(word):\n",
        "                tc_line.append(word.lower())\n",
        "                continue\n",
        "\n",
        "            if \"/\" in word and \"//\" not in word:\n",
        "                slashed = map(\n",
        "                    lambda t: title(t,callback,False),\n",
        "                    word.split('/')\n",
        "                )\n",
        "                tc_line.append(\"/\".join(slashed))\n",
        "                continue\n",
        "\n",
        "            if '-' in word:\n",
        "                hyphenated = map(\n",
        "                    lambda t: title(t, callback, False),\n",
        "                    word.split('-')\n",
        "                )\n",
        "                tc_line.append(\"-\".join(hyphenated))\n",
        "                continue\n",
        "\n",
        "            if all_caps:\n",
        "                word = word.lower()\n",
        "\n",
        "            # A term with all consonants should be considered an acronym.  But if it's\n",
        "            # too short (like \"St\", don't apply this)\n",
        "            CONSONANTS = ''.join(set(string.ascii_lowercase)\n",
        "                                 - {'a', 'e', 'i', 'o', 'u', 'y'})\n",
        "            is_all_consonants = re.search('\\A[' + CONSONANTS + ']+\\Z', word,\n",
        "                                             flags=re.IGNORECASE)\n",
        "            if is_all_consonants and len(word) > 2:\n",
        "                tc_line.append(word.upper())\n",
        "                continue\n",
        "\n",
        "            # Just a normal word that needs to be capitalized\n",
        "            tc_line.append(CAPFIRST.sub(lambda m: m.group(0).upper(), word))\n",
        "\n",
        "        if small_first_last and tc_line:\n",
        "            if not isinstance(tc_line[0], Immutable):\n",
        "                tc_line[0] = SMALL_FIRST.sub(lambda m: '%s%s' % (\n",
        "                    m.group(1),\n",
        "                    m.group(2).capitalize()\n",
        "                ), tc_line[0])\n",
        "\n",
        "            if not isinstance(tc_line[-1], Immutable):\n",
        "                tc_line[-1] = SMALL_LAST.sub(\n",
        "                    lambda m: m.group(0).capitalize(), tc_line[-1]\n",
        "                )\n",
        "\n",
        "        result = \" \".join(tc_line)\n",
        "\n",
        "        result = SUBPHRASE.sub(lambda m: '%s%s' % (\n",
        "            m.group(1),\n",
        "            m.group(2).capitalize()\n",
        "        ), result)\n",
        "\n",
        "        processed.append(result)\n",
        "\n",
        "    result = \"\\n\".join(processed)\n",
        "    return result\n",
        "\n",
        "size_limit = 40000\n",
        "def pathsize(path, string = False):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "      for path, dirs, files in os.walk(path):\n",
        "          for f in files:\n",
        "              fp = os.path.join(path, f)\n",
        "              size += os.path.getsize(fp)\n",
        "    if string:\n",
        "        return data_str(size)\n",
        "    else:\n",
        "        return size\n",
        "\n",
        "def has_size(path, only_check = True):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "        for path, dirs, files in os.walk(path):\n",
        "            for f in files:\n",
        "                fp = os.path.join(path, f)\n",
        "                size += os.path.getsize(fp)\n",
        "                if only_check and size >= size_limit:\n",
        "                    return size\n",
        "    if size >= size_limit:\n",
        "        return size\n",
        "    else:\n",
        "        return 0\n",
        "  \n",
        "def is_hidden(path):\n",
        "    return True if path[0] == '.' else False\n",
        "\n",
        "def filter_checks(dirs):\n",
        "    for dir in dirs:\n",
        "        if dir.endswith('ipynb_checkpoints'):\n",
        "            dirs.remove(dir)\n",
        "    return dirs\n",
        "\n",
        "def print_files(drs, range_start , range_end):\n",
        "    for i in range(range_start, range_end):\n",
        "        print(\"   {0}-  {1}\".format(i+1, drs[i])) \n",
        "\n",
        "def data_str(byte_val):\n",
        "    size = ByteToGB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} GB\".format(size)\n",
        "    size = ByteToMB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} MB\".format(size)\n",
        "    size = ByteToKB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} KB\".format(size)\n",
        "    return \"{:.1f} B\".format(size)\n",
        "\n",
        "def speed_str(byte_val):\n",
        "    size_mb = ByteToMB(byte_val)\n",
        "    if (size_mb >= 1):\n",
        "        return \"{:.1f} MB\".format(size_mb)\n",
        "    else:\n",
        "        return \"{:.1f} KB\".format(ByteToKB(byte_val))\n",
        "    \n",
        "def RoundTo1(n) :\n",
        "    if n < 1 and (n - 0.9765625) >= 0 :\n",
        "        return 1\n",
        "    else: \n",
        "        return n\n",
        "\n",
        "def is_empty(path):  \n",
        "    if os.path.isdir(path):\n",
        "        dircontent = os.listdir(path)\n",
        "        if len(dircontent) == 0 or (len(dircontent) == 1 and contains(checkpoint, dircontent[0])):\n",
        "            return True      \n",
        "    return False\n",
        "\n",
        "def startswith(a: str, b: str):\n",
        "    a = a.strip()\n",
        "    b = b.strip()\n",
        "    if len(a) >= len(b):\n",
        "        a1 = a\n",
        "        b1 = b\n",
        "    else:\n",
        "        a1 = b\n",
        "        b1 = a\n",
        "    if a1.startswith(b1):\n",
        "        return True\n",
        "    return b1.startswith(a1)\n",
        "\n",
        "contains = lambda string, search: search.lower() in string.lower()\n",
        "time_str = lambda sec: time.strftime('%H:%M:%S', time.gmtime(sec))\n",
        "\n",
        "ByteToGB = lambda n: RoundTo1(n / 1073741824)\n",
        "ByteToMB = lambda n: RoundTo1(n/ 1048576)\n",
        "ByteToKB = lambda n: RoundTo1(n/ 1024)\n",
        "\n",
        "class AppState:\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if not AppState._state:\n",
        "            AppState._state = AppState()\n",
        "        return AppState._state\n",
        "    def __init__(self):\n",
        "        if AppState._state:\n",
        "            raise('AppState is singlton.')\n",
        "        AppState._state = self\n",
        "    _state = None\n",
        "    running = False\n",
        "    currentviewcontainer = None\n",
        "    monitorthread: Thread = None\n",
        "    monitoralive= False\n",
        "    addthread: Thread = None\n",
        "    addalive = False\n",
        "    metacheckerthread: Thread = False\n",
        "    metacheckeralive= False\n",
        "    total_wanted = total_up = total_progress = active_down = active_up = completed_up = completed_down = 0\n",
        "    total_downloads= downloadings = deads = transferings = completed = 0\n",
        "    addresults = []\n",
        "    navcontainers = {}\n",
        "    backthreads = {}\n",
        "    clicktasks = []\n",
        "    clicktaskstates = {}\n",
        "    navactions = []\n",
        "\n",
        "appstate = AppState.instance()\n",
        "\n",
        "#### Init / Reqs\n",
        "\n",
        "def setupreqs():\n",
        "    reqs = set()\n",
        "    if config.ftpenabled:\n",
        "        reqs.add('ftputil')\n",
        "        if IS_ENV_COLAB:\n",
        "            !sudo apt-get install lftp $nullout \n",
        "    if config.spotifyenabled:\n",
        "        reqs.add('savify')\n",
        "    if config.ftpenabled:\n",
        "        global ftputil\n",
        "        import ftputil \n",
        "    check_pip_pgks_installed(reqs, True)\n",
        "\n",
        "\n",
        "#### Init / Pathes\n",
        "\n",
        "done_path = \"/content/done\"\n",
        "temp_save=\"/content/d-0\" \n",
        "added_path = \"/content/added\"\n",
        "os.makedirs(done_path, exist_ok = True)\n",
        "os.makedirs(temp_save, exist_ok = True)\n",
        "os.makedirs(added_path, exist_ok = True) \n",
        "\n",
        "path_movie = lambda mv: movies_path + \"/\" + mv\n",
        "path_tvshow = lambda tvshow: tv_path + \"/\" + tvshow\n",
        "path_season = lambda tvshow, season: tv_path + \"/\" + tvshow + \"/\" + season\n",
        "path_episode = lambda tvshow, season, eps: tv_path + \"/\" + tvshow + \"/\" + season + \"/\" + eps\n",
        "joinpath = lambda start, dir: start + \"/\" + dir \n",
        "\n",
        "def getsdbackup(path: str, bakid = \"\", bak_index = 0): #fix backup\n",
        "    return\n",
        "\n",
        "#### API / Consts\n",
        "\n",
        "skip_list = ['.txt','.inf','.info','.nfo','www.yts','rarbg_do_not']\n",
        "this_year = str(date.today().year)\n",
        "\n",
        "GENERAL = 101\n",
        "SOFTWARE = 102\n",
        "GAMES = 103\n",
        "\n",
        "MOVIE = 201\n",
        "TV = 300\n",
        "\n",
        "SHOW = 301\n",
        "SEASON = 302\n",
        "EPISODE = 303\n",
        "\n",
        "MUSIC = 401\n",
        "ALBUM = 402\n",
        "TRACK = 403\n",
        "\n",
        "L337X = '1337x'\n",
        "RARBG = 'rarbg'\n",
        "\n",
        "ALLCATEGORIES = ''\n",
        "MOVIESCATEGORY = \"Movies\"\n",
        "TVCATEGORY = \"TV\"\n",
        "APPSCATEGORY = \"Apps\"\n",
        "GAMESCATEGORY = \"Games\"\n",
        "\n",
        "SEEDERSSORT = \"By Seeders\"\n",
        "TIMESORT = \"By Time\"\n",
        "SIZESORT = \"By Size\"\n",
        "ASCORDER = \"Ascending\"\n",
        "DESCORDER = \"Descending\"\n",
        "\n",
        "HASH_ADDSOURCE = \"download hash\"\n",
        "LOCALFILE_ADDSOURCE = \"local file\"\n",
        "UPLOADFILE_ADDSOURCE = \"uploaded file\"\n",
        "MAGNET_ADDSOURCE = \"magnet\"\n",
        "FILEURL_ADDSOURCE = \"file url\"\n",
        "\n",
        "L337X_TV = \"TV\"\n",
        "L337X_MOVIES = \"Movies\"\n",
        "L337X_APPS = \"Apps\"\n",
        "L337X_GAMES = \"Games\"\n",
        "\n",
        "L337X_SEEDERS = \"seeders/desc\"\n",
        "L337X_SIZE_ASC = \"size/asc\"\n",
        "L337X_SIZE_DESC = \"size/desc\"\n",
        "L337X_TIME_ASC = \"time/asc\"\n",
        "L337X_TIME_DESC = \"time/desc\"\n",
        "\n",
        "RARBG_MOVIE_XVID = 14\n",
        "RARBG_MOVIE_XVID_720P = 48\n",
        "RARBG_MOVIE_H264 = 17\n",
        "RARBG_MOVIE_H264_720P = 45\n",
        "RARBG_MOVIE_H264_1080P = 44\n",
        "RARBG_MOVIE_H264_3D = 47\n",
        "RARBG_MOVIE_H265_1080P = 54\n",
        "RARBG_MOVIE_H264_4K = 50\n",
        "RARBG_MOVIE_H265_4K = 51\n",
        "RARBG_MOVIE_H264_4K_HDR = 52\n",
        "RARBG_MOVIE_H264 = [RARBG_MOVIE_H265_1080P, RARBG_MOVIE_H265_4K,  RARBG_MOVIE_H264_4K_HDR]\n",
        "RARBG_MOVIE_ISOFULL_HD = 42\n",
        "RARBG_MOVIE_HD_REMUX = 46\n",
        "RARBG_TV_EPISODES = 18\n",
        "RARBG_TV_EPISODES_HD = 41\n",
        "RARBG_TV_EPISODES_UHD = 49\n",
        "RARBG_MUSIC_MP3 = 23\n",
        "RARBG_MUSIC_FLAC = 25\n",
        "RARBG_GAMES_PC_ISO = 27\n",
        "RARBG_GAMES_PC_RIP = 28\n",
        "RARBG_GAMES_PS3 = 40\n",
        "RARBG_GAMES_PS4 = 53\n",
        "RARBG_GAMES_XBOX = 32\n",
        "RARBG_SOFTWARE = 33\n",
        "RARBG_EBOOK = 35\n",
        "RARBG_MOVIE = [RARBG_MOVIE_H264] + RARBG_MOVIE_H264\n",
        "RARBG_TV = [RARBG_TV_EPISODES, RARBG_TV_EPISODES_HD, RARBG_TV_EPISODES_UHD]\n",
        "\n",
        "SORTRARBG_SEEDERS = 'seeders'\n",
        "SORTRARBG_TIME = 'last'\n",
        "\n",
        "SORT1337X_SEEDERS_ASC = \"seeders_asc\"\n",
        "SORT1337X_SEEDERS_DESC = \"seeders_desc\"\n",
        "SORT1337X_TIME_ASC = \"time_asc\"\n",
        "SORT1337X_TIME_DESC = \"time_desc\"\n",
        "SORT1337X_SIZE_ASC = \"size_asc\"\n",
        "SORT1337X_SIZE_DESC = \"size_desc\"\n",
        "\n",
        "new_trackers = [\"udp://tracker.opentrackr.org:1337/announce\", \"udp://tracker.internetwarriors.net:1337/announce\", \"udp://exodus.desync.com:6969/announce\", \"udp://tracker.cyberia.is:6969/announce\", \"udp://3rt.tace.ru:60889/announce\", \"http://5rt.tace.ru:60889/announce\", \"udp://explodie.org:6969/announce\", \"udp://47.ip-51-68-199.eu:6969/announce\", \"udp://opentracker.i2p.rocks:6969/announce\", \"http://open.acgnxtracker.com:80/announce\", \"udp://www.torrent.eu.org:451/announce\", \"udp://tracker.torrent.eu.org:451/announce\", \"udp://tracker.tiny-vps.com:6969/announce\", \"udp://tracker.ds.is:6969/announce\", \"udp://retracker.lanta-net.ru:2710/announce\", \"udp://open.stealth.si:80/announce\", \"udp://tracker.moeking.me:6969/announce\", \"udp://ipv4.tracker.harry.lu:80/announce\", \"http://tracker.dler.org:6969/announce\", \"http://rt.tace.ru:80/announce\", \"udp://93.158.213.92:1337/announce\", \"udp://138.255.103.83:1337/announce\", \"udp://208.83.20.20:6969/announce\", \"udp://193.218.118.220:6969/announce\", \"udp://79.111.118.59:60889/announce\", \"http://93.157.234.32:60889/announce\", \"udp://184.105.151.164:6969/announce\", \"udp://51.68.199.47:6969/announce\", \"udp://51.81.46.170:6969/announce\", \"udp://91.216.110.52:451/announce\", \"udp://89.234.156.205:451/announce\", \"udp://5.206.60.196:6969/announce\", \"udp://5.226.148.20:6969/announce\", \"udp://37.235.174.46:2710/announce\", \"udp://185.181.60.67:80/announce\", \"udp://138.201.150.56:6969/announce\", \"udp://51.15.40.114:80/announce\", \"http://168.119.237.9:6969/announce\", \"http://195.201.31.194:80/announce\", \"https://trakx.herokuapp.com:443/announce\", \"https://w.wwwww.wtf:443/announce\", \"https://tracker.tamersunion.org:443/announce\", \"https://tracker.sloppyta.co:443/announce\", \"https://tracker.renfei.net:443/announce\", \"https://tracker.nitrix.me:443/announce\",\n",
        "              \"https://tracker.nanoha.org:443/announce\", \"https://tracker.lelux.fi:443/announce\", \"https://tracker.imgoingto.icu:443/announce\", \"https://tracker.hama3.net:443/announce\", \"https://tracker.foreverpirates.co:443/announce\", \"http://tracker2.wasabii.com.tw:6969/announce\", \"udp://tracker.sktorrent.net:6969/announce\", \"http://www.wareztorrent.com:80/announce\", \"udp://bt.xxx-tracker.com:2710/announce\", \"udp://tracker.eddie4.nl:6969/announce\", \"udp://tracker.grepler.com:6969/announce\", \"udp://tracker.mg64.net:2710/announce\", \"udp://wambo.club:1337/announce\", \"udp://tracker.dutchtracking.com:6969/announce\", \"udp://tc.animereactor.ru:8082/announce\", \"udp://tracker.justseed.it:1337/announce\", \"udp://tracker.leechers-paradise.org:6969/announce\", \"https://open.kickasstracker.com:443/announce\", \"udp://tracker.coppersurfer.tk:6969/announce\", \"http://87.253.152.137/announce\", \"http://91.216.110.47/announce\", \"http://91.217.91.21:3218/announce\", \"http://91.218.230.81:6969/announce\", \"http://93.92.64.5/announce\", \"http://atrack.pow7.com/announce\", \"http://bt.henbt.com:2710/announce\", \"http://bt.pusacg.org:8080/announce\", \"https://tracker.bt-hash.com:443/announce\", \"udp://tracker.leechers-paradise.org:6969\", \"https://182.176.139.129:6969/announce\", \"udp://zephir.monocul.us:6969/announce\", \"https://tracker.dutchtracking.com:80/announce\", \"https://grifon.info:80/announce\", \"udp://tracker.kicks-ass.net:80/announce\", \"udp://p4p.arenabg.com:1337/announce\", \"udp://tracker.aletorrenty.pl:2710/announce\", \"https://tracker.parrotsec.org:443/announce\", \"https://tracker.moxing.party:6969/announce\", \"https://tracker.ipv6tracker.ru:80/announce\", \"https://tracker.fastdownload.xyz:443/announce\", \"https://gwp2-v19.rinet.ru:80/announce\", \"https://tr.kxmp.cf:80/announce\", \"https://explodie.org:6969/announce\"]\n",
        "\n",
        "types = {GENERAL:  \"General\",\n",
        "        SOFTWARE:  \"Software\",\n",
        "        GAMES:  \"Games\",\n",
        "        MOVIE:  \"Movie\",\n",
        "        SHOW:  \"Show\",\n",
        "        SEASON:  \"Season\",\n",
        "        EPISODE:  \"Episode\",\n",
        "        MUSIC : \"Music\",\n",
        "        ALBUM : \"Album\",\n",
        "        TRACK : \"Track\"     \n",
        "}\n",
        "\n",
        "#### API / abstraction \n",
        "\n",
        "url_re = r\"^((http[s]?):\\/\\/)?([^:\\/\\s]+)((\\/\\w+\\/)*\\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?\"\n",
        "sm_re = r\"(?<=Shareddrives\\/)[A-Z]*(?=\\/)\"\n",
        "season_re0 = r\"\\b([S,s]|[S,s]eason([\\s,\\.]?))\\d{1,2}\"\n",
        "featurettes_re = r\"[F,f]eature[a-z]*|[E,e]xtras?\"\n",
        "mf_re = r\"((?<=\\b[S,s])|(?<=[S,s]eason)|(?<=[S,s]eason[\\s,\\.]))([1-9][0-9]?|0?[1-9])\"                       \n",
        "sn2num = r\"[1-9][0-9]?(?=[Xx]\\d{1,2}\\b)\"\n",
        "eps_re = r\"\\b([Ss]\\d{1,2}[Ee]\\d{1,2}|\\d{1,2}[xX]\\d{1,2}|[Ss]n?\\d{1,2}\\s?[Ee](ps?)?\\d{1,2})(?=[\\s\\.])\"\n",
        "check_sn_re = r\"[\\s,\\.]([S,s]\\d{1,2}|[Ss][Ee][Aa][Ss][Oo][Nn]([\\s,\\.]?)\\d{1,2})(?=[\\s,\\.]|e\\d{1,2}-\\d{1,2})(?!\\sto)\"\n",
        "eps2num_re = r\"(?<=\\d{1}[Xx])\\d{1,2}\\b\"\n",
        "year_re = r\"\\d{4}\" \n",
        "re_suf = r\"\\s\\d{1,2}$\"\n",
        "sn_in = r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\"\n",
        "sn_nm = r\"([1-9][0-9]?)\"\n",
        "skip_re = r\"(.txt)|(.i?nfo?)|(www.yts)|(RARBG_DO_NOT|rarbg_do_not)\"\n",
        "del_re = r\"\\.del\\d*\\/\"\n",
        "sd_re = r\"(\\/content\\/drive\\/Shareddrives\\/)[A-Za-z0-9]+(?=\\/)\"\n",
        "\n",
        "class DownloadAttrs:\n",
        "    def __init__(this, type_ = GENERAL, replace = False, backup = True, save_name = \"\", category = \"\", sequential= False, \n",
        "        uncomplete_source = \"\", imdb_name = \"\", imdb_rating = \"\", imdb_votes = \"\", partial = False, name= '', torfile= ''):\n",
        "        this.type_ = type_ \n",
        "        this.replace =  replace\n",
        "        this.backup =  backup\n",
        "        this.category =  category\n",
        "        this.save_name =  save_name\n",
        "        this.sequential = sequential \n",
        "        this.uncomplete_source  =  uncomplete_source\n",
        "        this.imdb_name =  imdb_name\n",
        "        this.imdb_rating =  imdb_rating\n",
        "        this.imdb_votes =  imdb_votes\n",
        "        this.partial = partial\n",
        "        this.name = name\n",
        "        this.torfile = torfile\n",
        "    torfile = \"\"\n",
        "    artist = \"\"\n",
        "    album = \"\"\n",
        "    track = \"\"\n",
        "    partial = False\n",
        "    backup = False\n",
        "    completed = False\n",
        "    replace = False\n",
        "    ready = False\n",
        "    name = \"\"\n",
        "    hash = ''\n",
        "    save_name = \"\"\n",
        "    save_path = \"\"\n",
        "    target_save_dir = \"\"\n",
        "    imdb_name = \"\"\n",
        "    type_ = GENERAL\n",
        "    save_type = 0\n",
        "    sequential = False\n",
        "    download_size = 0\n",
        "    allfiles = 0\n",
        "    selectedfiles = 0\n",
        "    files = None\n",
        "    uncomplete_source = \"\"\n",
        "    show = \"\"\n",
        "    season = \"\"\n",
        "    existing_dir = \"\"\n",
        "    existing_path = \"\"\n",
        "    existing_file = \"\"\n",
        "    baksv = None\n",
        "    year = 0\n",
        "    imdb_rating = \"\"\n",
        "    imdb_votes = \"\"\n",
        "    quality = \"1080\"\n",
        "    category = \"\"\n",
        "    site_source = \"\"\n",
        "    uploader = \"\"\n",
        "    format = \"\"\n",
        "    duration = \"\"\n",
        "    video_width = \"\"\n",
        "    video_height = \"\"\n",
        "    frame_rate = \"\"\n",
        "    bit_rate = \"\"\n",
        "    color_bit_depth = \"\"\n",
        "    video_bit_rate = \"\"\n",
        "    audio_tracks = None\n",
        "    magnet = \"\"\n",
        "    downloaded = None\n",
        "    total_downloaded = 0\n",
        "    verify_download = None\n",
        "    old_files = None\n",
        "    hasmetadata = False\n",
        "    addmethod = None\n",
        "    add_source = ''\n",
        "    def copy(this):\n",
        "        return DownloadAttrs(type_= this.type_,\n",
        "                    replace= this.replace,\n",
        "                    backup= this.backup,\n",
        "                    category= this.category,\n",
        "                    sequential= this.sequential,\n",
        "                    uncomplete_source= this.uncomplete_source,\n",
        "                    imdb_name= this.imdb_name,\n",
        "                    imdb_rating= this.imdb_rating,\n",
        "                    imdb_votes= this.imdb_votes)\n",
        "\n",
        "class DownloadFile():\n",
        "    def __init__(self, index, name, size, selected = True):\n",
        "        self.index = index\n",
        "        self.name = name\n",
        "        self.size = size\n",
        "    index = 0\n",
        "    name = \"\"\n",
        "    size = 0\n",
        "    selected = True\n",
        "\n",
        "class IMDBParams:\n",
        "    def __init__(self, keyword, title_type, s_year, e_year, ratings, min_votes, max_run, lists, labels, imdb_sort, \n",
        "        filter_watched: bool, filter_downloaded, l337x_download, rarbg_download, site_category, download_params, sort, rarbg_auto):\n",
        "        self.keyword = keyword\n",
        "        self.title_type = title_type\n",
        "        self.s_year = s_year\n",
        "        self.e_year = e_year\n",
        "        self.ratings = ratings\n",
        "        self.min_votes = min_votes\n",
        "        self.max_run = max_run\n",
        "        self.lists = lists\n",
        "        self.labels = labels\n",
        "        self.imdb_sort = imdb_sort\n",
        "        self.filter_watched = filter_watched\n",
        "        self.filter_downloaded = filter_downloaded\n",
        "        self.l337x_download = l337x_download\n",
        "        self.rarbg_download = rarbg_download\n",
        "        self.site_category = site_category\n",
        "        self.download_params = download_params\n",
        "        self.sort = sort\n",
        "        self.rarbg_auto = rarbg_auto\n",
        "\n",
        "    keyword = \"\"\n",
        "    title_type = \"\"\n",
        "    s_year = \"\"\n",
        "    e_year = \"\"\n",
        "    ratings = \"\"\n",
        "    min_votes = \"\"\n",
        "    max_run = \"\"\n",
        "    lists = \"\"\n",
        "    labels = \"\"\n",
        "    imdb_sort = \"\"\n",
        "    filter_watched = False\n",
        "    filter_downloaded = False\n",
        "    l337x_download = False\n",
        "    rarbg_download = False\n",
        "    site_category = \"\"\n",
        "    download_params = \"\"\n",
        "    sort = SORT1337X_SEEDERS_DESC\n",
        "    rarbg_auto = True\n",
        "\n",
        "class IMDBTitle:\n",
        "    def __init__(self, title, runtime, genres, rating, votes, director, staring):\n",
        "        self.title = title\n",
        "        self.runtime = runtime\n",
        "        self.rating = rating\n",
        "        self.votes = votes\n",
        "        self.director = director\n",
        "        self.staring = staring\n",
        "        self.genres = genres\n",
        "\n",
        "    title = runtime = rating = votes = director = staring = genres = \"\"\n",
        "    downloaded = watched = False\n",
        "\n",
        "class IMDBResult:\n",
        "    params: IMDBParams = None\n",
        "    titlescount = 0\n",
        "    downloadedcount = 0\n",
        "    watchedcount = 0\n",
        "    titles: list[IMDBTitle] = None\n",
        "    downloadedtitles: list[IMDBTitle] = None\n",
        "    watchedtitles: list[IMDBTitle] = None\n",
        "\n",
        "class DownloadResult:\n",
        "    def __init__(this, title, size = 0, date = \"\", seeders = \"\", leechers = \"\", uploader = \"\", href = \"\", downloaded= False, watched= False):\n",
        "        this.title = title\n",
        "        this.size = size\n",
        "        this.date = date \n",
        "        this.seeders = seeders\n",
        "        this.leechers = leechers\n",
        "        this.uploader = uploader\n",
        "        this.href = href\n",
        "        this.downloaded = downloaded\n",
        "        this.watched = watched\n",
        "    title: str\n",
        "    size = 0\n",
        "    magnet = date = seeders = leechers = uploader = href = \"\"\n",
        "    downloaded = watched = False \n",
        "\n",
        "class SearchResult:\n",
        "    def __init__(self, results = None, resultcount= 0, pagescount= 0, currentpage= 0, nextpage= -1, previouspage= -1, sort= None) -> None:\n",
        "        self.resultcount = resultcount\n",
        "        self.pagescount = pagescount\n",
        "        self.currentpage = currentpage\n",
        "        self.nextpage = nextpage\n",
        "        self.previouspage = previouspage\n",
        "        self.sort = sort\n",
        "        self.results = results\n",
        "\n",
        "    resultcount = 0\n",
        "    pagescount = 0\n",
        "    currentpage = 0\n",
        "    nextpage = -1\n",
        "    previouspage = -1\n",
        "    sort = None\n",
        "    results: list[DownloadResult] = None\n",
        "\n",
        "#### API / Download library management\n",
        "\n",
        "def transstring(name): \n",
        "    if not name:\n",
        "        error('String is empty.')\n",
        "        raise Exception('String is empty.')\n",
        "    table = name.maketrans(\"\",\"\",\" ,.;:!?'&#$%`!@^*_-/\\\\|'\\\"<>())[]{}\")\n",
        "    return name.translate(table).lower()\n",
        "\n",
        "def transtitle(name, show = False): \n",
        "    if not name:\n",
        "        error('Name is empty.')\n",
        "        raise Exception('Trans title,name is empty.')\n",
        "    name = name.replace(\"&\",\"and\")\n",
        "    dgts = re.findall(year_re, name)\n",
        "    year = \"\"\n",
        "    if dgts: \n",
        "        if len(dgts) == 1 :\n",
        "            name = name.split(dgts[0])[0]\n",
        "            year = dgts[0]\n",
        "        else:\n",
        "            name.split(dgts[-1])[0]\n",
        "            year = dgts[-1]\n",
        "    table = name.maketrans(\"\",\"\",\" '(#$%-,.;:!?)\")\n",
        "    return name.translate(table).lower() + year #if not show else name.translate(table).lower()\n",
        "\n",
        "def get_year(name): \n",
        "    dgts = re.findall(year_re, name.split('1080')[0])\n",
        "    if dgts: \n",
        "        return dgts[-1]\n",
        "    else:\n",
        "        return this_year\n",
        "\n",
        "def get_season(name, allow_year = True):\n",
        "    info(f'Retrieving season from: {name}')\n",
        "    lookup = re.search(mf_re, name)\n",
        "    if lookup:\n",
        "        sn = lookup.group()\n",
        "        sn = 'S' + sn if len(sn) != 1 else 'S0' + sn\n",
        "        info(f'Found season: {sn}')\n",
        "        return sn\n",
        "\n",
        "    lookup = re.search(featurettes_re, name)\n",
        "    if lookup:\n",
        "        ft = lookup.group()\n",
        "        info(f'Extra folder: {ft}')\n",
        "        return \"Extras\"\n",
        "\n",
        "    if allow_year:\n",
        "        sn = get_year(name)  \n",
        "        info(f'Season retrieved as a year: {sn}')\n",
        "        return sn\n",
        "    else:\n",
        "        info(f'No season was retrieved.')\n",
        "        return ''\n",
        "\n",
        "def name_movie(name, quality = \"1080\"): \n",
        "    name = name.split(quality)[0]\n",
        "    table = name.maketrans(\".\",\" \",\"()\")\n",
        "    trans = name.translate(table)\n",
        "    dgts = re.findall(year_re, trans)\n",
        "    if dgts and len(dgts) >= 1:\n",
        "         res = f\"{trans.split(dgts[-1])[0].strip()} {dgts[-1]}\"\n",
        "    else:\n",
        "        res = trans.strip()\n",
        "    return title(res)\n",
        "\n",
        "def name_show(name, quality = \"1080\"): \n",
        "    if quality in name:\n",
        "        name = name.split(quality)[0]\n",
        "    elif \"720p\" in name:\n",
        "        name = name.split(\"720p\")[0]    \n",
        "    table = name.maketrans(\".\",\" \",\"'()\")\n",
        "    trans = name.translate(table)\n",
        "    search = re.search(year_re, trans)\n",
        "    if search: \n",
        "        year = search.group()\n",
        "        res = f\"{trans.split(year)[0].strip()} {year}\"\n",
        "    else:\n",
        "        search = re.search(season_re0, trans)\n",
        "        if search: \n",
        "            res = trans.split(search.group())[0].strip()\n",
        "        else: \n",
        "            res = trans.strip()\n",
        "    return title(res)\n",
        "\n",
        "def name_episode(name, quality = \"1080\", keepDot = False):\n",
        "    if quality in name:\n",
        "        name = name.split(quality)[0]\n",
        "    elif \"720p\" in name:\n",
        "        name = name.split(\"720p\")[0]\n",
        "    if keepDot: \n",
        "        r = s = \"\"\n",
        "    else:\n",
        "        r =\".\"\n",
        "        s = \" \"\n",
        "    table = name.maketrans(r, s, \"()\")\n",
        "    name = name.translate(table)\n",
        "    if name[-1] == \".\":\n",
        "        name = name[:-1]\n",
        "    return title(name)\n",
        "\n",
        "def movie_exists(name):\n",
        "    if not name.strip():\n",
        "        error('Movie name is empty')\n",
        "        return           \n",
        "    info(f\"Checking if the movie {name} is downloaded.\")\n",
        "    movies_raw = filter_checks(next(os.walk(movies_path))[1])\n",
        "    name_s = transtitle(name)\n",
        "    for i in range(len(movies_raw)):\n",
        "        targetpath = path_movie(movies_raw[i])\n",
        "        targetname = movies_raw[i]\n",
        "        if name_s == transtitle(movies_raw[i]):\n",
        "            foundfile =  get_movie_file_path(targetpath, targetname)\n",
        "            if foundfile:\n",
        "                info(f\"Found {name} as {targetname}\")\n",
        "                return {'type': 'movie', \"foundname\": targetname, \"foundpath\": targetpath, \"foundshow\": '', 'foundfile': foundfile, \"founddir\": movies_path}\n",
        "    info(f\"{name} is not found\")\n",
        "    return False\n",
        "\n",
        "def show_exists(searchshow: str):\n",
        "    if not searchshow.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "    info(f\"Checking if the show {searchshow} is downloaded\")\n",
        "    shows_raw = filter_checks(next(os.walk(tv_path))[1])\n",
        "    name_trans = transtitle(searchshow, True)\n",
        "    for i in range(len(shows_raw)):\n",
        "        targetpath = path_tvshow(shows_raw[i])\n",
        "        targetname = shows_raw[i]\n",
        "        trans1 = transtitle(shows_raw[i], True)\n",
        "        if startswith(trans1, name_trans) and not is_empty(targetpath):\n",
        "            info(f\"{searchshow} is downloaded as {targetname}\")\n",
        "            return {'type': 'TV show', \"foundname\": targetname, \"foundpath\": targetpath, \"foundshow\": targetname, 'foundfile': '', \"founddir\": tv_path}\n",
        "    info(f\"{searchshow} is not found.\")\n",
        "    return False\n",
        "\n",
        "def season_exists(targetshow, targetseason):\n",
        "    if not targetseason.strip():\n",
        "        error('Season name is empty')\n",
        "        return\n",
        "    if not targetshow.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "\n",
        "    info(f\"Checking if the season {targetseason} of {targetshow} is downloaded\")\n",
        "    showsearch = show_exists(targetshow)\n",
        "    targetpath = \"\"\n",
        "    if showsearch:\n",
        "        targetshow = showsearch['foundname']\n",
        "        showpath = path_tvshow(targetshow)\n",
        "        targetpath = path_season(targetshow, targetseason)\n",
        "        if os.path.exists(targetpath) and not is_empty(targetpath):\n",
        "            info(f\"Season {targetseason} of {targetshow} is downloaded\")\n",
        "            return {'type': 'TV season', \"foundname\": targetseason, \"foundpath\": targetpath, \"foundshow\": targetshow, 'foundfile': '', \"founddir\": showpath}\n",
        "    info(f\"Season {targetseason} of {targetshow} is not downloaded\")\n",
        "    return False\n",
        "\n",
        "def episode_exists(targetshow, season, searchepisode): \n",
        "    info(f\"Checking if the episode: {searchepisode} is downloaded\")\n",
        "    showsearch = show_exists(targetshow)\n",
        "    targetepisode = \"\"\n",
        "    targetpath= \"\"\n",
        "    if showsearch:\n",
        "        targetshow = showsearch['foundname']\n",
        "        seasonpath = path_season(targetshow, season)\n",
        "        if os.path.exists(seasonpath) and not is_empty(seasonpath):\n",
        "            check = re.search(eps_re, searchepisode)\n",
        "            eps = check.group() if check else searchepisode\n",
        "            epses = next(os.walk(seasonpath))[2]\n",
        "            for targetepisode in epses:\n",
        "                splt = os.path.splitext(targetepisode)\n",
        "                if splt[1] == \".mp4\" or splt[1] == \".mkv\": \n",
        "                    if contains(splt[0], eps):\n",
        "                        targetpath = path_episode(targetshow, season, targetepisode)\n",
        "                        info(f\"Episode: {searchepisode} is downloaded as {targetpath}\")\n",
        "                        return {'type': 'TV episode', \"foundname\": targetepisode, \"foundpath\": targetpath, \"foundshow\": targetshow, 'foundfile': targetpath, \"founddir\": seasonpath}\n",
        "    info(f\"Episode: {searchepisode} is not downloaded.\")\n",
        "    return False\n",
        "\n",
        "def check_download(type_, name):\n",
        "    if type_ == MOVIE:\n",
        "        name = name_movie(name)\n",
        "        return movie_exists(name)\n",
        "    if type_ == SHOW:\n",
        "        name = name_show(name)\n",
        "        return show_exists(name)\n",
        "\n",
        "def get_movie_file_path(path, name):\n",
        "    if path and os.path.exists(path):\n",
        "        files = next(os.walk(path))[2]\n",
        "        for file in files:\n",
        "            splt = os.path.splitext(file)\n",
        "            ext = splt[1]\n",
        "            title: str = splt[0].lower()\n",
        "            if (ext == \".mp4\" or ext == \".mkv\" or ext == \".av\" or ext == \".ts\") and name.lower().startswith(title):\n",
        "                return path + \"/\" + file\n",
        "    return \"\"\n",
        "\n",
        "def rename_title(newname):\n",
        "    print(f\"Renaming: {newname}\\nEnter title name for search or proceed:\")\n",
        "    inp = input().lower()\n",
        "    if inp:\n",
        "        words = inp.split()\n",
        "    else:\n",
        "        words: list[str] = newname.split()\n",
        "    check1 = \" \".join(words[:2])\n",
        "    check2 = len(words[0]) > 3\n",
        "    movies = filter_checks(next(os.walk(movies_path))[1])\n",
        "    res = []\n",
        "\n",
        "    for mv in movies:\n",
        "        if mv.startswith(check1) or (check2 and mv.startswith(words[0])) or any(not check3.isdigit() and len(check3) > 3 and contains(mv, check3) for check3  in words):\n",
        "            res.append(mv)\n",
        "    if len(res) == 1:\n",
        "        title = res[0]\n",
        "    elif res:\n",
        "        res.sort()\n",
        "        i = 0\n",
        "        for mv in res:\n",
        "            i += 1\n",
        "            print(f\"{i} {mv}\")       \n",
        "        print(\"\\nChoose a title to rename:\\n\")\n",
        "        c = input()\n",
        "        if c == \"\" or c == \" \" or c == \"q\" or c == \"s\":\n",
        "            print(\"No title was renamed.\\n\")\n",
        "            return\n",
        "        else:\n",
        "            try:\n",
        "                title = res[int(c)-1]\n",
        "            except Exception as e:\n",
        "                print(e)\n",
        "                return\n",
        "    else:\n",
        "        print(\"No title was renamed.\\n\")\n",
        "        return\n",
        "\n",
        "    print(f\"Renaming: {title} to {newname} Confirm?\")\n",
        "    if input() != \"n\":\n",
        "        p0 = movies_path + \"/\" + title\n",
        "        p1 = movies_path + \"/\" + newname\n",
        "        print(f\"Renaming: {p0}\")\n",
        "        !mv \"$p0\" \"$p1\"\n",
        "\n",
        "        for p3 in moviesbackups:\n",
        "            p0 = joinpath(p3, title)\n",
        "            if os.path.exists(p0):\n",
        "                p1 = joinpath(p3, newname) \n",
        "                print(f\"Renaming backup: {p0}\")\n",
        "                !mv \"$p0\" \"$p1\"\n",
        "\n",
        "        print(\".....Rename done......\")\n",
        "    else:\n",
        "        print(\"No title was renamed.\\n\")\n",
        "\n",
        "def replace_download(path):\n",
        "    if path and os.path.exists(path):\n",
        "        parent = os.path.dirname(path)\n",
        "        rp = parent + \"/\" + \".replace\"\n",
        "        os.makedirs(rp, exist_ok=True)\n",
        "        !mv \"$path\" \"$rp\"\n",
        "\n",
        "def get_tv_type(attrs: DownloadAttrs):\n",
        "    search = re.search(eps_re, attrs.name)\n",
        "    if search:\n",
        "        return EPISODE\n",
        "    search = re.search(check_sn_re, attrs.name)\n",
        "    if search:\n",
        "        return SEASON  \n",
        "\n",
        "split_title_re = r\"[\\[\\]\\(]\"\n",
        "\n",
        "def music_title(name: str):\n",
        "    search = re.search(split_title_re, name)\n",
        "    if search:\n",
        "        name = name.split(search.group())[0]\n",
        "    splt = name.split(\"-\")\n",
        "    if splt:\n",
        "        artist = splt[0].strip() \n",
        "        name = splt[1].strip()\n",
        "        title = f\"{artist} - {name}\"\n",
        "    else:\n",
        "        artist = \"\"\n",
        "        name = title = name.strip()\n",
        "    return (artist, name, title)\n",
        "\n",
        "def get_season_backup_pathes(show):\n",
        "    backuppathes = set()\n",
        "    for item in tvbackups:\n",
        "        pt1 = joinpath(item, show)\n",
        "        backuppathes.add(pt1)\n",
        "        os.makedirs(pt1, exist_ok=True)\n",
        "    return backuppathes\n",
        "\n",
        "def get_episode_backup_pathes(show, season):\n",
        "    itemdir = f\"{show}/{season}\"\n",
        "    backuppathes = set()\n",
        "    for item in tvbackups:\n",
        "        pt1 = joinpath(item, itemdir)\n",
        "        backuppathes.add(pt1)\n",
        "        os.makedirs(pt1, exist_ok=True) \n",
        "    return backuppathes\n",
        "\n",
        "def prepare_download(attrs: DownloadAttrs):\n",
        "    info(f\"Preparing {types[attrs.type_]} download info for: {attrs.name}\")\n",
        "    Type = attrs.type_\n",
        "    res= Prepare_Result(attrs)\n",
        "    if Type == MOVIE:\n",
        "        newname = name_movie(attrs.name, attrs.quality)\n",
        "        searchresult = movie_exists(newname)\n",
        "        savepath = movies_path\n",
        "        backuppathes = moviesbackups\n",
        "    elif Type == SHOW:\n",
        "        newname = name_show(attrs.name, attrs.quality)\n",
        "        searchresult = show_exists(newname)\n",
        "        savepath = tv_path\n",
        "        backuppathes = tvbackups\n",
        "        attrs.show = attrs.save_name\n",
        "    elif Type == SEASON:\n",
        "        newname = get_season(attrs.name)\n",
        "        show = name_show(attrs.name, attrs.quality)\n",
        "        searchresult = season_exists(show, newname) \n",
        "        if searchresult:\n",
        "            show = searchresult['foundshow']           \n",
        "        savepath = path_tvshow(show)\n",
        "        backuppathes = get_season_backup_pathes(show)\n",
        "        attrs.show = show\n",
        "        attrs.season = newname\n",
        "    elif Type == EPISODE:\n",
        "        newname = name_episode(attrs.name, attrs.quality)\n",
        "        show = name_show(attrs.name, attrs.quality)\n",
        "        season = get_season(attrs.name)\n",
        "        searchresult = episode_exists(show, season, newname)        \n",
        "        backuppathes = get_episode_backup_pathes(show, season)\n",
        "        if searchresult:\n",
        "            show = searchresult['foundshow']\n",
        "        attrs.show = show\n",
        "        attrs.season = season\n",
        "        attrs.save_path = path_season(show, season)\n",
        "    else:\n",
        "        attrs.save_path = general_path\n",
        "        backuppathes = generalbackups\n",
        "    if searchresult:\n",
        "        res.exists = True\n",
        "        res.typestr = searchresult['type']\n",
        "        res.foundname = searchresult['foundname']\n",
        "        res.foundpath = searchresult['foundpath']\n",
        "        res.foundfile = searchresult['foundfile']\n",
        "        res.founddir = searchresult['founddir']\n",
        "        res.foundshow = searchresult['foundshow']\n",
        "        foundpath = searchresult['foundpath']\n",
        "        attrs.existing_dir = searchresult['founddir']\n",
        "        attrs.existing_path = foundpath\n",
        "        attrs.existing_file = searchresult['foundfile'] \n",
        "    if not attrs.save_name:\n",
        "        attrs.save_name = newname ##\n",
        "    attrs.save_path = savepath\n",
        "    attrs.target_save_dir = attrs.save_path if attrs.type_ == EPISODE else f'{attrs.save_path}/{attrs.save_name}'\n",
        "    if attrs.backup:\n",
        "        attrs.baksv = backuppathes\n",
        "    attrs.ready = True\n",
        "    info(f\"Finished preparing download successfully.\\nDownload attributes: {getattrstr(attrs, filter_empty = True, add_line= True)}\")\n",
        "    return res\n",
        "\n",
        "#### API / Download management\n",
        "\n",
        "ADDSUCCUSS = 100\n",
        "ADDERROR = 101\n",
        "ALREADYADDED = 101\n",
        "\n",
        "class AddResult():\n",
        "    attrs = None\n",
        "    handle = None\n",
        "    status = ADDSUCCUSS\n",
        "    awaiting_decision = False\n",
        "    errormessage = \"\"\n",
        "    succussmessage = \"\"\n",
        "    name = \"\"\n",
        "    savename = \"\"\n",
        "    size = 0\n",
        "    backuppath = \"\"\n",
        "    savepath = \"\"\n",
        "    hash = \"\"\n",
        "    selectedfiles_count = \"\"\n",
        "    files: list[DownloadFile] = None\n",
        "    filetable: panel.widgets.Tabulator = None\n",
        "    filetableoutput: widgets.Output = None\n",
        "    sizehtml: widgets.HTML = None\n",
        "    selectedfileshtml: widgets.HTML = None\n",
        "    hasmetadata = False\n",
        "\n",
        "class Prepare_Result:\n",
        "    def __init__(self, attrs, exists= False, type_= 'general', foundname= '', foundpath= '', foundshow= '', foundfile= '', founddir= ''):\n",
        "        self.attrs = attrs\n",
        "        self.exists = exists\n",
        "        self.typestr     = type_ \n",
        "        self.foundname = foundname \n",
        "        self.foundpath = foundpath \n",
        "        self.foundshow = foundshow \n",
        "        self.foundfile = foundfile \n",
        "        self.founddir  = founddir  \n",
        "    attrs = None\n",
        "    exists = False\n",
        "    typestr = 'general'\n",
        "    foundname = ''\n",
        "    foundpath = ''\n",
        "    foundshow = ''\n",
        "    foundfile = ''\n",
        "    founddir  = ''\n",
        "\n",
        "def get_magnet_name(magnet):\n",
        "    return urllib.parse.unquote(magnet.split(\"dn=\")[1].split(\"&tr=\")[0], encoding='utf-8', errors='replace').replace('+',\".\")\n",
        "\n",
        "def add_local_files(path= '.', files = set(), attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "      attrs = DownloadAttrs()\n",
        "    result = AddResult()\n",
        "    pathinvalid =  path != \".\" and not os.path.isdir(path) and not files\n",
        "    if path.endswith('.torrent'):\n",
        "        files= {path}\n",
        "    elif pathinvalid:\n",
        "        result.status = ADDERROR\n",
        "        result.errormessage = f\"Path {path} isn't a directory or a torrent file.\"\n",
        "        error(result.errormessage)\n",
        "        return result\n",
        "    files = files if files else next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        attrs = attrs.copy()\n",
        "        attrs.torfile = file\n",
        "        attrs.add_source = LOCALFILE_ADDSOURCE\n",
        "        splited = os.path.splitext(file)\n",
        "        if splited[1] == \".torrent\":\n",
        "            info(f\"Found a file to download: {file}\")\n",
        "            return add_download(attrs) # add multi file isn't correct\n",
        "    \n",
        "def add_download(attrs: DownloadAttrs):\n",
        "    if not (attrs.add_source == LOCALFILE_ADDSOURCE or attrs.add_source == MAGNET_ADDSOURCE):\n",
        "        raise(\"add_source should be LOCALFILE_ADDSOURCE or MAGNET_ADDSOURCE\")\n",
        "    result = AddResult() \n",
        "    result.attrs = attrs\n",
        "    appstate.addresults.append(result)  \n",
        "    if attrs.add_source == MAGNET_ADDSOURCE and not attrs.magnet:\n",
        "        err = f\"Magnet is empty. {attrs.name}\"\n",
        "        error(err)\n",
        "        result.status = ADDERROR\n",
        "        result.errormessage = err\n",
        "        return result\n",
        "    if attrs.add_source == LOCALFILE_ADDSOURCE and (not attrs.torfile or not os.path.isfile(attrs.torfile)):\n",
        "        err = f\"Tor file path is empty, or file doesn't exists {attrs.name}\"\n",
        "        error(err)\n",
        "        result.status = ADDERROR\n",
        "        result.errormessage = err\n",
        "        return result\n",
        "    try:\n",
        "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
        "            ti = lt.torrent_info(attrs.torfile)\n",
        "            attrs.name = ti.name()\n",
        "            if not ti.is_valid():\n",
        "                result.status = ADDERROR\n",
        "                result.errormessage = f\"Invalid torrent: {attrs.name}\"\n",
        "                error(result.errormessage)\n",
        "                return result\n",
        "            result.selectedfiles_count = ti.num_files()\n",
        "            params = {\"save_path\": temp_save, \"ti\": ti}\n",
        "        else:\n",
        "            attrs.name = get_magnet_name(attrs.magnet)\n",
        "            params = lt.parse_magnet_uri(attrs.magnet)\n",
        "            params.save_path = temp_save\n",
        "        info(f\"Adding download: {attrs.name} with {attrs.add_source}.\")\n",
        "        if not attrs.ready: \n",
        "            prep: Prepare_Result = prepare_download(attrs)\n",
        "            if prep.exists:\n",
        "                result.awaiting_decision = True\n",
        "                replace_download_decision(prep)\n",
        "                return result\n",
        "    \n",
        "        handle: lt.torrent_handle = ses.add_torrent(params)\n",
        "        handle.name = attrs.name\n",
        "        if not handle.is_valid():\n",
        "            result.status = ADDERROR\n",
        "            result.errormessage = f\"Invalid torrent {attrs.name}\"\n",
        "            error(f\"Invalid torrent {attrs.name}\")\n",
        "            return result\n",
        "        key = str(handle.info_hash())\n",
        "        result.name = attrs.name\n",
        "        result.handle = handle\n",
        "        result.files = [] \n",
        "        info(f\"Download info: {attrs.name}\\nHash: {key}\")\n",
        "        if key in downloads_dict:\n",
        "            result.status = ADDERROR\n",
        "            result.errormessage = f\"{attrs.name} is already added.\"\n",
        "            error(result.errormessage)\n",
        "            return result\n",
        "        result.hash = key\n",
        "        result.savepath = attrs.save_path\n",
        "        result.savename = attrs.save_name\n",
        "        handle.attrs = attrs\n",
        "        downloads_dict[key] = handle\n",
        "        add_trackers(handle)\n",
        "        torrentfile = handle.torrent_file()\n",
        "        if torrentfile:\n",
        "            handle.name = attrs.name = torrentfile.name()\n",
        "            set_download_filtered_files(result)\n",
        "            handle.attrs.hasmetadata = True\n",
        "            result.hasmetadata = True\n",
        "        else:\n",
        "            handle.attrs.hasmetadata = False\n",
        "            result.hasmetadata = False\n",
        "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
        "            !mv \"$attrs.torfile\" \"$added_path\"\n",
        "        result.status = ADDSUCCUSS\n",
        "        result.succussmessage = \"Added Successfully \" + attrs.name\n",
        "        info(f\"{attrs.name} is added succussfully. Save name: {attrs.save_name}\")\n",
        "        return result\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while adding download.', ERROR_EVENT)\n",
        "    result.status = ADDERROR\n",
        "    result.errormessage = f\"Download wasn't added {attrs.name}\"\n",
        "    warning(f\"{attrs.name} wasn't added.\")\n",
        "    return result\n",
        "\n",
        "def add_hash_download(hash, attrs: DownloadAttrs, title = ''):\n",
        "    if not title:\n",
        "        title = hash\n",
        "    download_link = f\"https://itorrents.org/torrent/{hash}.torrent\"\n",
        "    filename = f\"/content/{title}.torrent\"\n",
        "    !wget \"$download_link\" -O \"$filename\" $nullout\n",
        "    attrs.torfile = filename\n",
        "    attrs.add_source = LOCALFILE_ADDSOURCE\n",
        "    return add_download(attrs)\n",
        "\n",
        "def set_download_filtered_files(result: AddResult): \n",
        "    handle = result.handle\n",
        "    files = result.files\n",
        "    info(f\"Filtering download files for: {handle.name}.\")\n",
        "    totalfiles = selectedfiles = total_download = 0\n",
        "    tf = handle.torrent_file()\n",
        "    if tf:\n",
        "        handle.attrs.hasmetadata = True\n",
        "        allfiles = tf.files()\n",
        "        total_download = 0\n",
        "        totalfiles = allfiles.num_files()\n",
        "        selectedfiles = 0\n",
        "\n",
        "        for i in range(totalfiles):\n",
        "            file = DownloadFile(i, allfiles.file_name(i), allfiles.file_size(i))\n",
        "            if any(contains(file.name, check) for check in skip_list):\n",
        "                info(f\"{allfiles.file_name(i)} is filtered.\")\n",
        "                handle.file_priority(i,0)\n",
        "                file.selected = False\n",
        "            else:\n",
        "                selectedfiles += 1\n",
        "                handle.file_priority(i,6)\n",
        "                total_download += file.size\n",
        "                file.selected = True\n",
        "            files.append(file)\n",
        "    else:\n",
        "        info(handle.name + \" has no metadata.\")\n",
        "        handle.attrs.hasmetadata = False\n",
        "    result.size = total_download\n",
        "    result.selectedfiles_count = selectedfiles\n",
        "    handle.selected_files = selectedfiles\n",
        "    handle.attrs.download_size = total_download\n",
        "    handle.attrs.allfiles = totalfiles\n",
        "    handle.attrs.selectedfiles = selectedfiles\n",
        "    handle.attrs.files = files\n",
        "\n",
        "def selectdownloadfiles(handle, files):\n",
        "    if not handle:\n",
        "        return\n",
        "    totaldownload = 0\n",
        "    select_files = 0\n",
        "    for file in files:\n",
        "        if file.selected:\n",
        "            handle.file_priority(file.index, 6)\n",
        "            totaldownload += file.size\n",
        "            select_files += 1\n",
        "        else:\n",
        "            handle.file_priority(file.index, 0)\n",
        "    handle.total_download = totaldownload\n",
        "    handle.selected_files = select_files\n",
        "    return True\n",
        "  \n",
        "def add_trackers(handle):\n",
        "    for x in range(len(new_trackers)):\n",
        "        annouce_entry = {'url': new_trackers[x], 'tier': 2}\n",
        "        handle.add_tracker(annouce_entry) \n",
        " \n",
        "#### API / After Download Operations \n",
        "\n",
        "def shave_download(handle, path, maindir) :\n",
        "    tf = handle.torrent_file()\n",
        "    files = tf.files()\n",
        "    priorities = handle.get_file_priorities()\n",
        "    for i in range(files.num_files()):\n",
        "        file_path = path + \"/\" + files.file_path(i)\n",
        "        if os.path.isfile(file_path) and priorities[i] == 0:\n",
        "            !rm \"$file_path\"\n",
        "            dirpath = os.path.dirname(file_path)\n",
        "            if is_empty(dirpath):\n",
        "                !rm -r \"$dirpath\"\n",
        "    if os.path.isdir(maindir):\n",
        "        dircontent = next(os.walk(maindir))[1]\n",
        "        for path in dircontent:\n",
        "            if is_empty(path):\n",
        "                !rm -r \"$path\"\n",
        "\n",
        "def clean_download(attrs: DownloadAttrs, path):\n",
        "    info(f\"Cleaning type: {types[attrs.type_]} name: {attrs.name}\")\n",
        "    attrs.downloaded = []\n",
        "    if attrs.type_ == MOVIE:\n",
        "        after_shave(path, attrs.save_name, pathitems = attrs.downloaded)\n",
        "    elif attrs.type_ == SHOW:\n",
        "        clean_tvshow(path, pathitems = attrs.downloaded)\n",
        "    elif attrs.type_ == SEASON or attrs.type_ == EPISODE:\n",
        "        path_item =  ('', clean_season(path))\n",
        "        attrs.downloaded.append(path_item)\n",
        "  \n",
        "def after_shave (path, newname, v= False, pathitems = []):\n",
        "    dircontent = next(os.walk(path))[2]\n",
        "    item1 = ('', [])\n",
        "    for file in dircontent:\n",
        "        srt = 0\n",
        "        split = os.path.splitext(file)\n",
        "        ext = split[1]\n",
        "        p1 = path + \"/\" + file\n",
        "        if any(contains(file, check) for check in skip_list):\n",
        "            if v:\n",
        "                print(f\"Deleting: {p1[36:]}\")\n",
        "            !rm \"$p1\"\n",
        "            continue\n",
        "        elif  (ext == \".mp4\" or ext == \".mkv\" or ext == \".srt\" or ext == \".idx\"):\n",
        "            extra = \"\"\n",
        "            if ext == \".srt\": \n",
        "                if re.split(re_suf, split[0])[0] != newname:\n",
        "                    if srt > 0 :\n",
        "                        extra = \" \" + str(srt)\n",
        "                    srt += 1\n",
        "                else:\n",
        "                    item1[1].append(file)\n",
        "                    continue\n",
        "            elif split[0] == newname:\n",
        "                item1[1].append(file)\n",
        "                continue\n",
        "            file = newname + extra + ext\n",
        "            if v:\n",
        "                print(f\"Renaming: {p1[36:]} to {file}\")\n",
        "            p2 = path + \"/\" + file\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            item1[1].append(file)\n",
        "    pathitems.append(item1)\n",
        "    subdir = \"Subs\"\n",
        "    subspath = path + \"/\" + subdir\n",
        "    if not os.path.exists(subspath):\n",
        "        subdir = \"subs\"\n",
        "        subspath = path + \"/\" + subdir\n",
        "        if not os.path.exists(subspath):\n",
        "            return\n",
        "    subs =  next(os.walk(subspath))[2]\n",
        "    count = 0\n",
        "    item2 = (subdir, [])\n",
        "    for sub in subs:\n",
        "        split = os.path.splitext(sub)\n",
        "        ext = split[1]\n",
        "        srtname = f\"{newname} {str(count)}\" if count > 0 else newname\n",
        "        if ext == '.srt' and re.split(re_suf, split[0])[0] != newname:\n",
        "            newsub = srtname + ext \n",
        "            p1 = subspath + \"/\" + sub\n",
        "            p2 = subspath + \"/\" + newsub\n",
        "            if v:\n",
        "                print(f\"Renaming: {p1[36:]} to {newsub}\")\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            count += 1\n",
        "            item2[1].append(newsub)\n",
        "        else:\n",
        "            item2[1].append(sub)\n",
        "        pathitems.append(item2)\n",
        "    return\n",
        "\n",
        "def clean_movies_dir(movie_path = movies_path, v= False, backup = False, delete_empty = False, clean = True) :\n",
        "    dir_content = filter_checks(next(os.walk(movie_path))[1])\n",
        "    path = \"\"\n",
        "    for dir in dir_content :\n",
        "        path = movie_path + \"/\" + dir\n",
        "        if delete_empty:\n",
        "            size = pathsize(path)\n",
        "            if size < size_limit:\n",
        "                !rm -r \"$path\"\n",
        "\n",
        "                if backup and False: #fixbackup\n",
        "                    for mvdir in movies_basenames:\n",
        "                        if not mvdir in movie_path:\n",
        "                            path0 = \"bk path\"\n",
        "                            size = pathsize(path0)\n",
        "                            if size < size_limit:\n",
        "                                if v:\n",
        "                                    print(f\"Deleting: {path0} size: {data_str(size)}\")\n",
        "                                !rm -r \"$path0\" \n",
        "                continue\n",
        "          \n",
        "        if clean:\n",
        "            clean_movie(path, dir, movie_path)\n",
        "\n",
        "def clean_movie(path, name, movie_path = movies_path):\n",
        "    newname = name\n",
        "    search = re.search(r\"\\d{4}$\", name)\n",
        "    if not search:\n",
        "        newname = name_movie(name)\n",
        "        p1 = path\n",
        "        p2 = movie_path + \"/\" + newname\n",
        "        !mv \"$p1\" \"$p2\"\n",
        "        path = p2\n",
        "        print(newname)\n",
        "    after_shave(path, newname)\n",
        "\n",
        "def clean_tvshows(path = \"\"):\n",
        "    if not path:\n",
        "        path = tv_path\n",
        "    shows = next(os.walk(path))[1]\n",
        "    for show in shows:\n",
        "        print(show)\n",
        "        path = path + \"/\" + show\n",
        "        clean_tvshow(path)\n",
        "\n",
        "def clean_tvshow(path, keepChar = \"\", pathitems = []):\n",
        "    dircontent = next(os.walk(path))[1]\n",
        "    if len(dircontent) != 0:\n",
        "        for dir in dircontent:\n",
        "            p0 = path + \"/\" + dir\n",
        "            if not has_size(p0, True):\n",
        "                !rm -r \"$p0\"\n",
        "                continue\n",
        "            newname = get_season(dir, False)\n",
        "            if newname:\n",
        "                if newname != dir:\n",
        "                    p0 =  path + \"/\" + dir\n",
        "                    p1 = path + \"/\" + newname\n",
        "                    !mv \"$p0\" \"$p1\"\n",
        "                    dir = newname\n",
        "            seasonpath = path + \"/\" + dir\n",
        "            files = clean_season(seasonpath, keepChar)\n",
        "            item = (dir, files)\n",
        "            pathitems.append(item)\n",
        "    else:\n",
        "        files = clean_season(path, keepChar)\n",
        "        item = ('', files)\n",
        "        pathitems.append(item)\n",
        "    return\n",
        "\n",
        "def clean_season(path, keepDot = False):\n",
        "    clean = []\n",
        "    info(f'Cleaning show season in path: {path}')\n",
        "    if not os.path.exists(path):\n",
        "        return\n",
        "    files = next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        splitted = os.path.splitext(file)\n",
        "        eps = splitted[0]\n",
        "        ext = splitted[1]\n",
        "        p1 = path + \"/\" + file\n",
        "        if ext == \".mkv\" or ext == \".mp4\" or ext == \".srt\":\n",
        "            newname = name_episode(eps, keepDot= keepDot) + ext\n",
        "            if newname != file:\n",
        "                p2 = path + \"/\" + newname\n",
        "                !mv \"$p1\" \"$p2\" \n",
        "            clean.append(newname)\n",
        "        elif any(contains(file.lower(), check) for check in skip_list):\n",
        "            !rm \"$p1\" \n",
        "    info(f'Cleaned files: {len(clean)}')   \n",
        "    return clean\n",
        "\n",
        "#### API / IMDB \n",
        "\n",
        "def AdvancedIMDBSearch ( params: IMDBParams):\n",
        "    url = f'https://www.imdb.com/search/title/?title={params.keyword}&title_type={params.title_type}&release_date={params.s_year}-01-01,{params.e_year}-12-31&user_rating={params.ratings}&num_votes={params.min_votes},&runtime=,{params.max_run}&my_ratings=exclude&lists={params.lists}&groups={params.labels}&sort={params.imdb_sort}&view=advanced&count=250'\n",
        "    req = requests.get(url, headers = {\"Accept-Language\": \"en-US\"})\n",
        "    if req.status_code == 200:\n",
        "        info(\"\\n IMDB Search Done Successfully...\\n\")\n",
        "        soup = BeautifulSoup(req.text,'html.parser')    \n",
        "        listnode = soup.find(\"div\", {\"class\":\"lister-list\"})\n",
        "        if not listnode :\n",
        "            error(\"AdvancedIMDBSearch: Error: An error occured while performing the web scrapping.\")\n",
        "            return\n",
        "        \n",
        "        titles: list[IMDBTitle]= []\n",
        "        downloaded: list[IMDBTitle]= []\n",
        "        watched: list[IMDBTitle] = []\n",
        "\n",
        "        all_items = listnode.findAll(class_=\"lister-item\")\n",
        "        for i in range(len(all_items)):\n",
        "            year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
        "            title_raw = all_items[i].find(class_=\"lister-item-header\").a.text\n",
        "            titleval = find_title(title_raw, year_raw)\n",
        "            runtime = all_items[i].find(class_=\"runtime\").text\n",
        "            genres = all_items[i].find(class_=\"genre\").text.strip()\n",
        "            rating = all_items[i].find(class_=\"ratings-imdb-rating\")[\"data-value\"]\n",
        "            votes = all_items[i].find(\"span\", {\"name\":\"nv\"}).text\n",
        "            title= IMDBTitle(titleval, runtime, genres, rating, votes, \"\", \"\")\n",
        "            if titleval in watched_movies_list:\n",
        "                title.watched = True\n",
        "                watched.append(title)\n",
        "            if movie_exists(titleval):\n",
        "                downloaded.append(title)\n",
        "                title.downloaded= True\n",
        "                if params.filter_downloaded:\n",
        "                    continue         \n",
        "            titles.append(title)\n",
        "        result = IMDBResult()\n",
        "        result.titles = titles\n",
        "        result.watchedtitles = watched\n",
        "        result.downloadedtitles = downloaded\n",
        "        result.titlescount = len(titles)\n",
        "        result.downloadedcount = len(downloaded)\n",
        "        result.watchedcount = len(watched)\n",
        "        result.params = params\n",
        "        return result\n",
        "    else:\n",
        "        error(f\"AdvancedIMDBSearch: Error accessing the web page. Code error: {req.state_code}\")\n",
        "\n",
        "#### API / rarbg api\n",
        "\n",
        "tokens = {\"TD0\": \"anpfy1ko6z\", \"TD1\": \"b2nuip039q\", \"TD2\": \"84gy57ew3v\", \"TD3\": \"2kjweiogl5\", \"TD4\": \"e0bnj3xucl\", \"TD5\": \"cs4r9hvpkj\", \"TD6\": \"uso5jew6yh\", \"TD7\": \"yc82r5ogws\", \"TD8\": \"fhpkc0ivau\", 'TD9': 'm9ytpnkdxj'}\n",
        "rarbg_api = 'http://torrentapi.org/pubapi_v2.php'\n",
        "token = tokens[td_id]\n",
        "version = '2.6.0'\n",
        "app_id = 'TRD'\n",
        "user_agent = \"TRD/1.5.0 (Linux; c6afa4a080b9; 5.10.133+; #1 SMP Fri Aug 26 08:44:51 UTC 2022; x86_64; x86_64) python 3.7.13\"\n",
        "\n",
        "def get_user_agent():\n",
        "    uname = '; '.join(platform.uname())\n",
        "    pyver = platform.python_version()\n",
        "    return f'{app_id}/{version} ({uname}) python {pyver}'\n",
        "\n",
        "def request(method, url, params=None):\n",
        "    info(f\"Request {method}@{url}\\nParams: {params}\")\n",
        "    if not params:\n",
        "        params = {}\n",
        "    params.update({\n",
        "        'app_id': app_id\n",
        "    })\n",
        "\n",
        "    headers = {\n",
        "        'user-agent': user_agent\n",
        "    }\n",
        "    sess = requests.Session()\n",
        "    req = requests.Request(method, url, params=params, headers=headers)\n",
        "    preq = req.prepare()\n",
        "    res = sess.send(preq)\n",
        "    info(f\"Request status: {res.status_code}\")\n",
        "    res.raise_for_status()\n",
        "    return res\n",
        "\n",
        "def rarbg_token():\n",
        "    info('Refreshing rarbg token.')\n",
        "    params = {\n",
        "        'get_token': 'get_token'\n",
        "    }\n",
        "    res = request('GET', rarbg_api, params)\n",
        "    json_res = res.json() if res and res.status_code == 200 else None\n",
        "    if json_res and 'token' in json_res:\n",
        "        info(\"Rarbg token successfully refreshed.\")\n",
        "        global token, user_agent\n",
        "        token = json_res['token']\n",
        "        user_agent = get_user_agent()\n",
        "        info(f\"New rarbg token: {token} User agent: {user_agent}\")\n",
        "    else:\n",
        "        error(f'Error while getting a rarbg token. status code: {res.status_code()}\\nrequest result: {res}\\nUser agent: {user_agent}')\n",
        "\n",
        "def rarbg_rip(key= '', imdb = '', categories = None, sort = ''):\n",
        "    catstr = 'any' if categories == None else categories\n",
        "    info(f\"Searching for: {key} {imdb} in categories: {catstr}\")\n",
        "    category = ''\n",
        "    params = {'mode': 'search','token': token}\n",
        "\n",
        "    if key:\n",
        "        params['search_string'] = key\n",
        "    elif imdb:\n",
        "        params['search_imdb'] = imdb\n",
        "    else:\n",
        "        return None\n",
        "    \n",
        "    if categories:\n",
        "        category = str(categories[0])\n",
        "        for i in range(1, len(categories)):\n",
        "            category += ';' + str(categories[i])\n",
        "        params['category'] = category \n",
        "\n",
        "    if sort:\n",
        "        params['sort'] = sort\n",
        "    try:\n",
        "        res = request('GET', rarbg_api, params)\n",
        "        json_res = res.json() if res.status_code == 200 else None\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while searching Rarbg.', ERROR_EVENT)\n",
        "        return None\n",
        "    if json_res:\n",
        "        if \"error_code\" in json_res.keys():\n",
        "            if json_res[\"error_code\"] == 20:\n",
        "                info(f\"Searching for {key if key else imdb} got no results. \\nRequest result: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\\nThe API may not be working check the link.\")\n",
        "            else:\n",
        "                error(f\"An error happened while requesting rarbg api. Error: {json_res['error']}. Error code: {json_res['error_code']}.\\nParams: {params}\")     \n",
        "            rarbg_token()\n",
        "            params['token'] = token\n",
        "            time.sleep(1)\n",
        "            info(f\"Retrying search for: {key} {imdb}\")\n",
        "            res = request('GET', rarbg_api, params)\n",
        "            json_res = res.json() if res.status_code == 200 else None  \n",
        "\n",
        "        if json_res and 'torrent_results' in json_res:\n",
        "            results = []\n",
        "            for rs in json_res['torrent_results']:\n",
        "                result: DownloadResult = DownloadResult(rs[\"filename\"])\n",
        "                result.magnet = rs[\"download\"]\n",
        "                results.append(result)\n",
        "            info(f\"Successfully searched: {key} {imdb} in categories: {catstr} {len(results)} results.\")\n",
        "            return results\n",
        "    error(f\"Search for: {key} {imdb} in categories: {catstr} wasn't completed.\\nResult: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\")\n",
        "    return False\n",
        "\n",
        "def Download_Rarbg(search, category = '', sort = SORT1337X_SEEDERS_DESC, rarbg_auto = False, attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    info(f\"Searching for {search} in rarbg.com.\")\n",
        "    print(f\"\\nSearching for:  {search} in rarbg.com.\\n\")\n",
        "    rarbgsort = magnet = name = \"\"\n",
        "\n",
        "    if category == MOVIESCATEGORY:\n",
        "        all_cat = RARBG_MOVIE\n",
        "        categories = RARBG_MOVIE\n",
        "    elif category == TVCATEGORY : \n",
        "        all_cat = RARBG_TV\n",
        "        categories = RARBG_TV\n",
        "    else:\n",
        "        all_cat = None\n",
        "        categories = None\n",
        "\n",
        "    rarbgsort = SORTRARBG_SEEDERS  \n",
        "    if sort == SORT1337X_TIME_DESC:\n",
        "        rarbgsort = SORTRARBG_TIME\n",
        "\n",
        "    results: list[DownloadResult]\n",
        "    state = 1                                 # 1 init, 2 edit & redo search, 0 done, -1 bad search\n",
        "    while state != 0 :\n",
        "\n",
        "        if state == 1:\n",
        "            results = rarbg_rip(key = search, categories = categories, sort = rarbgsort)\n",
        "            if not results and categories and state != 2 :    \n",
        "                results = rarbg_rip(key = search, sort = rarbgsort)\n",
        "            state = 3\n",
        "\n",
        "        elif state == 2:\n",
        "            link = f\"https://rarbgenter.org/torrents.php?search={search.replace(' ', '+')}\"\n",
        "            warning(f\"Searching for {search} in rarbg.com. No results were found. Please check the link to ensure the results.\\n{link}\")\n",
        "            print(f\"No results were found. Please check the link to ensure the results.\\n{link}\\n\\nEnter e:[search] to edit, m:[magnet] to add magnet directly:, i < 7 to exit:\\n\")\n",
        "            newinput = input()\n",
        "\n",
        "            if len (newinput) < 7:\n",
        "                return -1\n",
        "\n",
        "            elif newinput.startswith(\"m:\"):\n",
        "                magnet = newinput[2:]\n",
        "                try:\n",
        "                    name = get_magnet_name(magnet)\n",
        "                except Exception as e:\n",
        "                    name = search\n",
        "                    error(ex())\n",
        "                    error(f\"Magnet name wasn't obtained\")\n",
        "                    updatestatushtml('An error happend while searhcing Rarbg.', ERROR_EVENT)\n",
        "                results = None\n",
        "                state = 4\n",
        "\n",
        "            elif newinput.startswith(\"e:\"):\n",
        "                newinput = newinput[2:]\n",
        "                results = rarbg_rip(key = newinput, sort = rarbgsort)\n",
        "                state = 1\n",
        "\n",
        "        if results: \n",
        "            print(\"\\n     {:<70}{:>10}{:>10}\\n\".format(\"Title\", \"Size\", \"Seeders\"))\n",
        "            for i in range(len(results)):\n",
        "                print(\" {:<2}- {:<70}\".format(i + 1 , results[i].title))\n",
        "            if len(results) == 1 and rarbg_auto:\n",
        "                magnet = results[0].magnet\n",
        "                name = results[0].title\n",
        "                state = 4\n",
        "\n",
        "            else:\n",
        "                print(\"\\nPlease choose one of the results to download             Format [single]     Enter q to exit, e to edit the search:\")\n",
        "                choice = -1\n",
        "                while choice == -1:                   #out of range get input again.\n",
        "                    choice = input().lower()\n",
        "                    if choice == \"\" or choice == \" \" or choice == \"s\" or choice == \"q\": \n",
        "                        return -1\n",
        "                    elif choice == \"e\":\n",
        "                        state = 2\n",
        "                        break\n",
        "                      \n",
        "                    choice = int(choice) - 1\n",
        "                    if choice < 0 or choice >= len(results):\n",
        "                        print(\"\\nChoice out of range.\")\n",
        "                        choice = -1\n",
        "                if state == 2:\n",
        "                    continue\n",
        "                else:\n",
        "                    magnet = results[choice].magnet\n",
        "                    name = results[choice].title\n",
        "                    results = None\n",
        "                    state = 4\n",
        "\n",
        "        if state == 4:      \n",
        "            attrs.site_source = RARBG\n",
        "            attrs.name = name\n",
        "            attrs.magnet = magnet\n",
        "            result: AddResult = None #add_magnet_download(magnet, attrs)\n",
        "            if result.status == ADDSUCCUSS:\n",
        "                state = 0\n",
        "                return 0\n",
        "            else:\n",
        "                return -1\n",
        "        else:\n",
        "            state = 2\n",
        "    return 0\n",
        "\n",
        "#### API / Search \n",
        "\n",
        "def search1337x(search, sort = SORT1337X_SEEDERS_DESC, category = \"\", page = 1, attrs = None):\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    search_s = search.replace(\"'\", \" \").replace(\" \",\"%20\")\n",
        "    sort1337x = L337X_SEEDERS\n",
        "    if sort == SORT1337X_TIME_DESC:\n",
        "        sort1337x = L337X_TIME_DESC\n",
        "    elif sort == SORT1337X_TIME_ASC:\n",
        "        sort1337x = SORT1337X_TIME_ASC    \n",
        "    elif sort == SORT1337X_SIZE_ASC:\n",
        "        sort1337x = L337X_SIZE_ASC    \n",
        "    elif sort == SORT1337X_SIZE_DESC:\n",
        "        sort1337x = L337X_SIZE_DESC   \n",
        "\n",
        "    parameters = f\"sort-category-search/{search_s}/{category}/{sort1337x}/{page}/\" if category else f\"sort-search/{search_s}/{sort1337x}/{page}/\"\n",
        "    url = \"https://www.1337xx.to/\" + parameters\n",
        "    info(f\"Scraping 1337x search for: {search} Page: {page}\\nURL: {url}.\")\n",
        "    download_state = \"downloaded\" if check_download(attrs.type_, search) else \"not downloaded\"\n",
        "    info(f\"{search} is {download_state}.\")\n",
        "    response = requests.get(url, headers= {\"Accept-Language\": \"en-US\"})\n",
        "    if response.status_code == 200 :\n",
        "        soup = BeautifulSoup(response.text, 'html.parser' )\n",
        "        # get pages here\n",
        "        previouspage = 0\n",
        "        nextpage = 0\n",
        "        totalpages = 0\n",
        "        result = SearchResult(previouspage= previouspage, nextpage= nextpage, pagescount= totalpages, sort= sort)\n",
        "        main_element = soup.find(\"tbody\")\n",
        "        if main_element is None:\n",
        "            warning(\"\\nNull search. Enter e to edit the search, q to exit.\\n\")\n",
        "            return -1\n",
        "        all_res = main_element.findAll(\"tr\")\n",
        "        title = size = uploader = seeders = leechers = \"\"\n",
        "        results = [] \n",
        "        if all_res:\n",
        "            info(f\"Results found: {len(all_res)}.\")\n",
        "            for i in  range(len(all_res)):\n",
        "                alldata= all_res[i].findAll(\"td\")\n",
        "                title = alldata[0].findAll(\"a\")[1].text\n",
        "                size = alldata[4].text\n",
        "                date = alldata[3].text\n",
        "                seeders = alldata[1].text\n",
        "                leechers = alldata[2].text\n",
        "                uploader = alldata[5].a.text\n",
        "                href = \"https://www.1337xx.to\" + alldata[0].findAll(\"a\")[1]['href']\n",
        "                res = DownloadResult(title= title, size= size, date= date, seeders= seeders, leechers= leechers, uploader= uploader, href= href)\n",
        "                results.append(res)\n",
        "\n",
        "            result.results = results\n",
        "            return result\n",
        "        else:\n",
        "            info(f\"No results found for {search}.\")\n",
        "    else:\n",
        "        error(f\"An error occured while trying to access 1337x.com  status: {response.status_code}.\")\n",
        "    return -1\n",
        "\n",
        "def download1337x(result: DownloadResult, attrs: DownloadAttrs):\n",
        "    url = result.href\n",
        "    download = requests.get(url)\n",
        "    soup = BeautifulSoup(download.text, \"html.parser\")\n",
        "    attrs.site_source = L337X  \n",
        "    hash = soup.find(class_=\"infohash-box\").span.text.strip()  \n",
        "    return add_hash_download(hash, attrs, result.title)\n",
        "     \n",
        "#### API / File Manager\n",
        "\n",
        "def mv(from_path, to_path, content=None, backup=False, movie_name=False, show_name=False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok=True)\n",
        "        if content:\n",
        "            info(f\"Moving batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to move [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0, len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input().lower().strip()\n",
        "            if inpt == \"q\":\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)\n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))\n",
        "                        if end > len(content) or start < 0:\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Moving: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            rename = \"\"\n",
        "            if movie_name:\n",
        "                rename = \"/\" + name_movie(content[i])\n",
        "            elif show_name:\n",
        "                rename = \"/\" + name_show(content[i])\n",
        "  \n",
        "            p1 = (from_path + \"/\" + content[i]) if content else from_path\n",
        "            p2 = to_path + rename\n",
        "            info(f\"Moving {p1} to: {p2}\")\n",
        "            os.makedirs(to_path, exist_ok=True)\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            if backup and False:  # fixbackup\n",
        "                info(f\"Processing backup.\")\n",
        "                for i in range(1, 4):\n",
        "                    p11bak = \"bk path\"\n",
        "                    tpbak = \"bk path\"\n",
        "                    if not (p11bak[0] in from_path and tpbak[0] in to_path):\n",
        "                        tp = tpbak[1]\n",
        "                        p11 = p11bak[1]\n",
        "                        p21 = tp + rename\n",
        "                        if os.path.exists(p11):\n",
        "                            os.makedirs(tp, exist_ok=True)\n",
        "                            print(f\"Moving {p11} to {p21}\\n\")\n",
        "                            info(f\"Moving {p11} to {p21}\")\n",
        "                            !mv \"$p11\" \"$p21\"\n",
        "                        else:\n",
        "                            print(f\"Backup {p11} Doesn't exist.\\n\")\n",
        "                            warning(f\"Backup {p11} Doesn't exist.\")\n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(\"Moving done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\")\n",
        "        return\n",
        "\n",
        "def cp(from_path, to_path, content = None, backup = False, movie_name = False, show_name = False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok= True)  \n",
        "        if content:\n",
        "            info(f\"Copying batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to copy [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0 ,len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input()\n",
        "            if inpt == \"q\":\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)      \n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))      \n",
        "                        if end > len(content) or start < 0 :\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Copying: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            newname  = \"\"\n",
        "            if movie_name:\n",
        "                newname =  name_movie(items[i])\n",
        "            elif show_name:\n",
        "                newname = name_show(items[i]) \n",
        "  \n",
        "            p1 = from_path + \"/\" + content[i] if content else from_path\n",
        "            if newname:\n",
        "                p2 = from_path + \"/\" +  newname if content else os.path.dirname(from_path) + '/' + newname\n",
        "                print(\"  Renaming:  {} to {}\".format(items[i], newname))\n",
        "                !mv \"p1\" \"$p2\"\n",
        "                p1 = p2\n",
        "  \n",
        "            print(f\"Copying:  {p1} to {to_path}\")\n",
        "            info(f\"Copying:  {p1} to {to_path}\")\n",
        "            !rsync -r --size-only  \"$p1\" \"$to_path\"\n",
        "            if backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    p3bak = \"bk path\"\n",
        "                    if not (p3bak[0]in from_path and p3bak[0] in to_path):\n",
        "                        p3 =  p3bak[1]\n",
        "                        os.makedirs(p3, exist_ok= True)\n",
        "                        print(f\"Copying  {p1} to {p3}\\n\")\n",
        "                        info(f\"Copying:  {p1} to {p3}\")\n",
        "                        !rsync -r --size-only \"$p1\" \"$p3\" \n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(f\"Copying done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\\n\")\n",
        "        return\n",
        "    \n",
        "def rename(path, newpath, backup, content = None):\n",
        "    print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "    !mv \"$path\" \"$newpath\" \n",
        "    if backup and False: #fixbackup\n",
        "        for i in range(1,4):\n",
        "            pathbu = \"bk path\"\n",
        "            newpathbu = \"bk\"\n",
        "            if not pathbu[0] in path and os.path.exists(pathbu[1]):\n",
        "                path = pathbu[1]\n",
        "                newpath = newpathbu[1]    \n",
        "                print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "                !mv \"$path\" \"$newpath\"      \n",
        "\n",
        "        int(\"......................\")\n",
        "    print(\"       Done\")\n",
        "    return  \n",
        "  \n",
        "def rm(delpath, process_backup = False, replace = False, content = None):\n",
        "    if content:\n",
        "        content.sort()\n",
        "        info(f'Deleing files in from: {delpath}\\nProcess backup: {process_backup}')\n",
        "        items: list[int] = []\n",
        "        #print_files(content, 0 ,len(content))\n",
        "        start = end = 0\n",
        "        inpt = input()\n",
        "        if inpt == \"q\":\n",
        "            return\n",
        "        if '.' == inpt:\n",
        "            start = 0\n",
        "            end = len(rng)      \n",
        "        else:\n",
        "            rngs = inpt.split(',')\n",
        "            for rng in rngs:\n",
        "                if '-' in rng:\n",
        "                    rngs = rng.split('-')\n",
        "                    start = int(rngs[0]) - 1\n",
        "                    end = int((rngs[1]))\n",
        "                    items.extend(range(start, end))      \n",
        "                    if end > len(content) or start < 0 :\n",
        "                        print(\"The ranges' ends are out of the directory file range.\")\n",
        "                    continue\n",
        "                else:\n",
        "                    i = int(rng)-1\n",
        "                    items.append(i)\n",
        "  \n",
        "    elif delpath:\n",
        "        info(f'Deleing: {delpath}\\nProcess backup: {process_backup}')\n",
        "        items = [0]\n",
        "    else:\n",
        "        return -1\n",
        "  \n",
        "    if replace:\n",
        "        for i in items:\n",
        "            path = delpath +\"/\"+ content[i] if content else delpath\n",
        "            replace_download(path)\n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt0 = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Moving to .replace:  {pt0}\")\n",
        "                        info(f\"Moving to .replace:  {pt0}\")\n",
        "                        replace_download(pt0)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt0} doesn't exist.\") \n",
        "  \n",
        "    else:\n",
        "        for i in items:\n",
        "            path = delpath + \"/\" + content[i] if content else delpath\n",
        "            info(f'Deleing path: {path}')\n",
        "            if os.path.exists(path):\n",
        "                rt = !rm -r \"$path\"\n",
        "                if rt:\n",
        "                    error(lines = rt)\n",
        "                    list_lines(rt)\n",
        "            else:\n",
        "                error(f\"{path} doesn't exist.\")\n",
        "                continue\n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Deleting path: {pt}\")\n",
        "                        info(f'Deleing file: {pt}')\n",
        "                        rt = !rm -r \"$pt\"\n",
        "                        if rt:\n",
        "                            error(lines = rt)\n",
        "                            list_lines(rt)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt} doesn't exist.\") \n",
        "        return\n",
        "  \n",
        "def is_cp(name):\n",
        "    return True if contains(checkpoint, name) else False\n",
        "\n",
        "def del_cp(path):\n",
        "    p0 = f\"{path}/{checkpoint}\"\n",
        "    if os.path.exists(p0):\n",
        "        !rm -r \"$p0\"\n",
        "\n",
        "def dircontent(path):\n",
        "    del_cp(path)\n",
        "    return os.listdir(path)\n",
        "\n",
        "sizeDiffers = (1,'Size differs')\n",
        "doesntExist = (2,\"Doesn't Exist\")\n",
        "emptySizeLimit = 40000\n",
        "class Sync_Status:\n",
        "    def __init__(self, path, src: int, message = '', name1 = '', name2 = '', size1 = '', size2 = '', status = doesntExist):\n",
        "        self.path = path\n",
        "        self.src = src\n",
        "        self.message = message\n",
        "        self.name1 = name1\n",
        "        self.name2 = name2\n",
        "        self.size1 = size1\n",
        "        self.size2 = size2\n",
        "        self.status = status\n",
        "\n",
        "def compare_dirs(first, second, sync = False, syncNames = False, delEmpty = False):\n",
        "   info(f'Comparing sync status.\\nFirst path: {first}\\nSecond path: {second}')\n",
        "   if first and os.path.exists(first) and second and os.path.exists(second):\n",
        "       del_cp(first)\n",
        "       del_cp(second)\n",
        "       content1 = os.listdir(first)\n",
        "       content2 = os.listdir(second)\n",
        "       content1.sort()\n",
        "       content2.sort()\n",
        "       synced = []\n",
        "       sync_list: list[Sync_Status] = []\n",
        "       emty1 = emty2 = 0\n",
        "       if content1:\n",
        "           ln1 = len(content1)\n",
        "           ln2 = len(content2)\n",
        "           print(\"         {:<74}{:^43} {:^12}{:^12}{:^14}\\n\".format(\"In Dir 1\", \"In Dir 2\", \"Size in 1\",  \"Size in 2\", 'Sync Status'))\n",
        "           for item in content1:\n",
        "               path1 = f\"{first}/{item}\"\n",
        "               path2 = f\"{second}/{item}\"\n",
        "               size1_raw= pathsize(path1)\n",
        "               size1 = data_str(size1_raw)\n",
        "               size2 = \"\"\n",
        "               exists2 = False\n",
        "               status2 = ''\n",
        "               synced_ = 'Synced'\n",
        "               unsynced_ = 'Unsynced'\n",
        "               recheck = ''\n",
        "               if delEmpty and size1_raw <= emptySizeLimit:\n",
        "                   !rm -r \"$path1\"\n",
        "                   ln1 -= 1\n",
        "                   info(f\"Empty directory deleted {path1}\")\n",
        "                   emty1 += 1\n",
        "                   size1 = 0\n",
        "       \n",
        "               if item in content2:        \n",
        "                   exists2 = True \n",
        "                   status2 = \"Exists\"\n",
        "                   content2.remove(item)       \n",
        "               else:\n",
        "                   recheck = research_name(item, content2)\n",
        "                   if recheck:\n",
        "                       exists2 = True\n",
        "                       content2.remove(recheck)\n",
        "                       path2 = f\"{second}/{recheck}\"\n",
        "                       status2 = f'[{recheck}]'\n",
        "                       info(f\"{item} exists as {recheck} in 2.\")\n",
        "       \n",
        "               if exists2:\n",
        "                   size2_raw = pathsize(path2)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       ln2 -= 1\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1            \n",
        "                       continue\n",
        "       \n",
        "                   if recheck and syncNames:\n",
        "                       info(f\"Renaming {recheck} to {item}\")\n",
        "                       p0 = f\"{second}/{recheck}\"\n",
        "                       p1 = f\"{second}/{item}\"\n",
        "                       ot = !mv \"$p0\" \"$p1\"\n",
        "                       if ot:\n",
        "                           error(ot)\n",
        "                       else:\n",
        "                           path2 = p1\n",
        "                           status2 = 'Renamed'\n",
        "                           info(f\"Item {recheck} renamed to {item} in 2.\")\n",
        "       \n",
        "       \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   diff = False if abs(size1_raw - size2_raw) <= 50000 else True\n",
        "                   if not diff:\n",
        "                       msg = \"    {:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, synced_)\n",
        "                       synced.append(msg)\n",
        "                   else: \n",
        "                       s_status = sizeDiffers[1]\n",
        "                       msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status)\n",
        "                       if  size1_raw > size2_raw:\n",
        "                           status = Sync_Status(path= path1, src= 1, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 1: {path1}, size differs in path 2.\")\n",
        "                       else:\n",
        "                           status = Sync_Status(path= path2, src= 2, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 2: {path2}, size differs in path 1.\")\n",
        "                       sync_list.append(status)\n",
        "               else:\n",
        "                   if not size1:\n",
        "                       continue\n",
        "                   status2 = ''\n",
        "                   s_status = doesntExist[1]\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status )\n",
        "                   status = Sync_Status(path= path1, src= 1, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 1: {path1}, doesn't exist in path 2.\")\n",
        "             \n",
        "           if content2:\n",
        "               for item in content2:                    \n",
        "                   path2 = f'{second}/{item}'\n",
        "                   size2_raw =  pathsize(path2, False)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1\n",
        "                       ln2 -= 1\n",
        "                       continue          \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(\"\", item, '', size2, \"Doesn't Exist\")\n",
        "                   status = Sync_Status(path= path2, src= 2, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 2: {path2}, doesn't exist in path 1.\")\n",
        "     \n",
        "           for item in synced:\n",
        "               print(item)\n",
        "               info(item)\n",
        "     \n",
        "           if sync_list:\n",
        "               sync_list.sort(key= lambda obj: obj.status[0])\n",
        "               for i in range(len(sync_list)):\n",
        "                   item = sync_list[i]\n",
        "                   msg = f\"{str(i + 1)+' - ' if sync else '    '}{item.message}\"\n",
        "                   print(msg)\n",
        "                   info(item.message)\n",
        "                    \n",
        "           msg = f\"\\nTotal items in path 1: {ln1}   Total items in path 2:  {ln2}   Unsynced items: {len(sync_list)}.\\n\"\n",
        "           msg += f\"{f'Deleted empty folders in path 1:  {emty1}  ' if emty1 else ''}{f'Deleted empty folders in path 2:  {emty2}' if emty2 else ''}\\n\"\n",
        "           info(msg)\n",
        "           print(msg)\n",
        "           \n",
        "           if sync and sync_list:\n",
        "               print('Enter a selection for the synchronization:  e.g. i1, i2, i1-i5\\n')\n",
        "               inp = input().strip().lower()\n",
        "               if (inp == \"q\" or inp.startswith('n')):\n",
        "                   return\n",
        "               rngs = []  \n",
        "               if inp == '.':\n",
        "                   rngs.extend(range(len(sync_list)))\n",
        "               else:\n",
        "                   selects = inp.split(',')\n",
        "                   for select in selects:\n",
        "                       try:          \n",
        "                           if '-' in select:\n",
        "                               splt = select.split('-')\n",
        "                               s = int(splt[0]) - 1\n",
        "                               e = int(splt[1])\n",
        "                               rngs.extend(range(s, e))\n",
        "                           else:\n",
        "                               rngs.append(int(select) - 1)\n",
        "                       except Exception as e:\n",
        "                           error(str(e))\n",
        "                           continue\n",
        "               msg = f\"Syncing {first} with {second}.\\nTotal copying items: {len(rngs)}\"\n",
        "               info(msg)\n",
        "               print(msg)\n",
        "               for i in rngs:\n",
        "                   p0 = sync_list[i].path\n",
        "                   p1 = second if sync_list[i].src == 1 else first\n",
        "                   print(f\"Copying: {os.path.basename(p0)} to {p1}\")\n",
        "                   info(f\"Copying: {os.path.basename(p0)} to {p1}\")\n",
        "                   !rsync --size-only -P -h -r \"$p0\" \"$p1\"\n",
        "           print(\"\\n.............\\n    Done\\n\")\n",
        "   else:\n",
        "       msg = f\"{first} {'exists' if os.path.exists(first) else 'does not exist'}\\n{second} {'exists' if os.path.exists(second) else 'does not exist'}\"\n",
        "       error(msg)\n",
        "\n",
        "def research_name(key, content2):\n",
        "    key = key.strip()\n",
        "    if key:\n",
        "        key = os.path.splitext(key)[0]\n",
        "        keytrans = transstring(key)\n",
        "        ln = len(keytrans)\n",
        "        if ln >= 15:\n",
        "            for i in range(len(content2)):\n",
        "                trans = transstring(os.path.splitext(content2[i])[0])\n",
        "                ln1 = len(trans)\n",
        "                if ln1 < 15:\n",
        "                    continue\n",
        "                if ln1 <= ln:\n",
        "                    n0 = trans  \n",
        "                    n1 = keytrans\n",
        "                else:\n",
        "                    n0 = keytrans\n",
        "                    n1 = trans\n",
        "                if contains(n1, n0):\n",
        "                    return content2[i]\n",
        "    return False\n",
        "\n",
        "def mt(path, bd = None, ad = None, backup = False, prompt = False):\n",
        "    if not (bd or ad):\n",
        "        return\n",
        "    info(f'Deleing files dated before {datetime.fromtimestamp(bd).strftime(\"%Y-%m-%d\")} in {path}')\n",
        "    files = next(os.walk(path))[2]\n",
        "    check = bd and ad\n",
        "    filter = []\n",
        "    for file in files:\n",
        "        p0 = os.path.join(path, file)\n",
        "        md = os.path.getmtime(p0)\n",
        "        if (check and md <= bd and md >= ad) or (bd and md <= bd) or (ad and md >= ad):\n",
        "            dstr = datetime.fromtimestamp(md).strftime('%Y-%m-%d')\n",
        "            size = data_str(os.path.getsize(p0))\n",
        "            msg = f'{dstr} - {size} {file}'\n",
        "            info(msg)\n",
        "            print(msg)\n",
        "            if prompt:\n",
        "                filter.append(file)\n",
        "                continue         \n",
        "            info(f\"Deleting {p0}..\")\n",
        "            rm(p0, backup, False)\n",
        "    if prompt:\n",
        "        rm(delpath= path, process_backup= backup, content= filter)\n",
        "    print('..... Done .....\\n')\n",
        "\n",
        "def check_sd_base(path):\n",
        "  lookup = re.search(sd_re, path)\n",
        "  if lookup:\n",
        "      p0 = lookup.group()  \n",
        "      if os.path.exists(p0):\n",
        "          return p0\n",
        "  return False\n",
        "\n",
        "def makedirs(path, backup = False):\n",
        "    if path:\n",
        "        info(f\"Creating dir: {path}\")\n",
        "        os.makedirs(path, exist_ok = True)\n",
        "    if backup and False: #fixbackup\n",
        "        for i in range(1, 4):\n",
        "            nd = \"bk path\"\n",
        "            np = nd[1]\n",
        "            check = check_sd_base(np)\n",
        "            if check:\n",
        "                info(f\"Creating backup dir: {np}\")\n",
        "                os.makedirs(nd, exist_ok = True)\n",
        "            else:\n",
        "                warning(f\"{nd[0]} doesn't exist.\")\n",
        "\n",
        "def clean_general(Type) :\n",
        "    dirs = next(os.walk(general_path))[1]\n",
        "    if checkpoint in dirs: dirs.remove(checkpoint)\n",
        "    for name in dirs:\n",
        "        newname = \"\"\n",
        "        p1 = general_path + \"/\" + name\n",
        "        p0 = general_path\n",
        "        if not os.path.isdir(p1):\n",
        "            p0 = general_path + \"/\" + os.path.splitext(name)[0]\n",
        "            os.makedirs(p0, exist_ok= True)\n",
        "            !mv \"$p1\" \"$p0\"\n",
        "            p1 = p0\n",
        "\n",
        "        if Type == MOVIE:\n",
        "            newname = name_movie(name)\n",
        "            save_path = movies_path\n",
        "            after_shave(p1, newname)\n",
        "        elif Type == SHOW:\n",
        "            newname = name_show(name)\n",
        "            clean_tvshow(p1)\n",
        "            save_path = tv_path\n",
        "            check = save_path + \"/\" + newname\n",
        "        elif Type == SEASON:\n",
        "            newname = get_season(name)\n",
        "            if not newname:\n",
        "                newname = name\n",
        "            show = name_show(name)\n",
        "            clean_season(p1)\n",
        "            save_path= path_tvshow(show)\n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        elif Type == EPISODE:\n",
        "            newname = name_episode(name)\n",
        "            show = name_show(name)\n",
        "            season= get_season(name)\n",
        "            if not season:\n",
        "                season = name\n",
        "            save_path= path_season(show, season) \n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        else:\n",
        "            save_path = general_path\n",
        "        if newname:\n",
        "            p2 = general_path + \"/\" + newname\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "        else:\n",
        "            p2 = p2 + name\n",
        "\n",
        "        if Type == EPISODE and os.path.isdir(p2):\n",
        "            clean_season(p2)\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\" \n",
        "\n",
        "        if Type == SHOW and os.path.isdir(check):\n",
        "            save_path = check\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\"\n",
        "\n",
        "        !mv \"$p2\"* \"$save_path\"\n",
        "        if p02 and os.path.exists(p02): \n",
        "            !rm -r \"$p02\"\n",
        "      \n",
        "def clean_path(type_, path, process_backup = False, keepdot = False, multi = False, delete_empty = False, clean = True):\n",
        "    if multi:\n",
        "        if type_ == MOVIE:\n",
        "            if path :\n",
        "                print(f\"Cleaning movie library path: {path}\")  \n",
        "                clean_movies_dir(path, backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "            else:\n",
        "                clean_movies_dir(backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "\n",
        "        elif type_ == SHOW:\n",
        "            print(f\"Cleaning TV library path: {tv_path}\")\n",
        "            clean_tvshows()\n",
        "            if process_backup:\n",
        "                for pt in tvbackups:\n",
        "                    print(f\"Cleaning backup TV library path: {pt}\")\n",
        "                    clean_tvshows(pt)\n",
        "\n",
        "    else:\n",
        "            if type_ == MOVIE:\n",
        "                if path and os.path.exists(path):\n",
        "                        name = path.split(\"/\")[-1]\n",
        "                        print(f\"Cleaning movie: {path}\")\n",
        "                        clean_movie(path, name)\n",
        "\n",
        "                        if process_backup and False: #fixbackup\n",
        "                            for dir in movies_basenames:\n",
        "                                path = \"bk path\"\n",
        "                                if os.path.exists(path):\n",
        "                                    print(f\"Cleaning movie: {path}\")\n",
        "                                    clean_movie(path, name)\n",
        "                                else: \n",
        "                                    warning(f\"Backup path: {path} doesn't exist.\")\n",
        "                                    print(f\"Backup path: {path} doesn't exist.\")\n",
        "\n",
        "            elif type_ == SHOW:\n",
        "                if path and os.path.exists(path):\n",
        "                        print(f\"Cleaning show path: {path}\")\n",
        "                        clean_tvshow(path, keepdot)\n",
        "                        if process_backup and False: #fixbackup\n",
        "                            for dir in tv_basenames:\n",
        "                                    path = \"bk path\"\n",
        "                                    if os.path.exists(path):          \n",
        "                                        print(f\"Cleaning backup Show path: {path}\")\n",
        "                                        clean_tvshow(path, keepdot)\n",
        "                                    else:\n",
        "                                        warning(f\"Backup path: {path} doesn't exist.\")\n",
        "                                        print(f\"Backup path: {path} doesn't exist.\")              \n",
        "\n",
        "#### API / Download files utils\n",
        "\n",
        "def clean_download_destination(attrs: DownloadAttrs):\n",
        "    info(f'Cleaning distination for: {attrs.save_name}')\n",
        "    attrs.old_files = set()\n",
        "    delstr = '.del' + nowstr()\n",
        "    if 1 <= attrs.type_/TV < 1.1 :\n",
        "        for file in attrs.downloaded:\n",
        "            lookup1 = episode_exists(attrs.show, get_season(file[0]), file[0])\n",
        "            if lookup1:\n",
        "                p0 = lookup1['foundpath']\n",
        "                p1 = os.path.dirname(p0) + '/' + delstr\n",
        "                if not os.path.isdir(p1):\n",
        "                    os.makedirs(p1)\n",
        "                info(f'Moving: {p0} to {p1}')\n",
        "                rt = !mv \"$p0\" \"$p1\"\n",
        "                if rt:\n",
        "                    error(lines = rt)\n",
        "                list_lines(rt)          \n",
        "                attrs.old_files.add(p1)\n",
        "                info(f'Old file added: {lookup1[\"foundname\"]}')\n",
        "                if attrs.backup and False: #fixbackup\n",
        "                    for i in range(1,4):\n",
        "                        p01 =\"bk\"\n",
        "                        if os.path.exists(p0):\n",
        "                            p11 = \"bk\"\n",
        "                            if not os.path.isdir(p11):\n",
        "                                os.makedirs(p11)\n",
        "                            info(f'Moving: {p01} to {p11}')\n",
        "                            rt = !mv \"$p01\" \"$p11\" \n",
        "                            if rt:\n",
        "                                info(lines = rt)\n",
        "                                list_lines(rt) \n",
        "\n",
        "    elif attrs.type_ == MOVIE:\n",
        "        p0 = attrs.existing_file \n",
        "        p1 = attrs.existing_dir + '/' + delstr\n",
        "        os.makedirs(p1, exist_ok = True)\n",
        "        info(f'Moving: {p0} to {p1}')\n",
        "        rt = !mv \"$p0\" \"$p1\"\n",
        "        if rt:\n",
        "            info(lines = rt)\n",
        "            list_lines(rt)\n",
        "        attrs.old_files.add(p1)\n",
        "        info(f'Old file added: {attrs.existing_file}')\n",
        "        if attrs.backup and False: #fixbackup\n",
        "            for i in range(1,4):\n",
        "                p01 = \"bk\"\n",
        "                if os.path.exists(p0):\n",
        "                    p11 = \"bk\"\n",
        "                    if not os.path.isdir(p11):\n",
        "                        os.makedirs(p11)\n",
        "                    info(f'Moving: {p01} to {p11}')\n",
        "                    rt = !mv \"$p01\" \"$p11\" \n",
        "                    if rt:\n",
        "                        info(lines = rt)\n",
        "                        list_lines(rt)\n",
        "    else:\n",
        "        return  \n",
        "    info('Cleaning distination done.')\n",
        "    \n",
        "def pre_download_transfer(attrs: DownloadAttrs, path):\n",
        "    attrs.verify_download = []\n",
        "    info(f\"Preparing transfer for: {path}\\nSave dir: {attrs.target_save_dir}\")\n",
        "    size = 0 \n",
        "    info(\"File transfer verification items.\")\n",
        "    itemstr = \"\"\n",
        "    for item in attrs.downloaded:\n",
        "        p01 = '/' + item[0] if item[0] else ''\n",
        "        base = path + p01\n",
        "        to_base = attrs.target_save_dir + p01\n",
        "        itemstr += f\"In dir:  .{base}/\"\n",
        "        for file in item[1]:\n",
        "            p02 = base + '/' + file\n",
        "            s01 = pathsize(p02)\n",
        "            size += s01\n",
        "            p03 = to_base + '/' + file\n",
        "            attrs.verify_download.append((p02, p03))\n",
        "            sizestr = data_str(s01)\n",
        "            itemstr += f'({sizestr}) {p02}\\n{len(sizestr) * \" \"} {p03}'\n",
        "    info(itemstr)\n",
        "    DownloadAttrs.total_downloaded = size \n",
        "\n",
        "def verify_saving_download(attrs: DownloadAttrs):\n",
        "    fails = []\n",
        "    info(f\"Verifying downloaded files for: {DownloadAttrs.save_name}\\nTotal downloaded: {data_str(attrs.total_downloaded)}\")\n",
        "    for i in range(len(attrs.verify_download)):\n",
        "        item = attrs.verify_download[i]\n",
        "        s1 = has_size(item[0], False)\n",
        "        s2 = has_size(item[1], False)\n",
        "        info(f\"Verifying: ({'Does not exist.' if s1 == -1 else s1}) {item[0]}\\n       To: ({'Does not exist.' if s2 == -1 else s2}) {item[1]}\")\n",
        "        if s2 != -1 and abs(s2-s1) <= size_limit:\n",
        "            info('Successfully transfered.')\n",
        "        else:\n",
        "            info('Not transfered.')\n",
        "            fails.append(item[1])\n",
        "    if len(fails) == 0:\n",
        "        info(f\"Successful transfer verification.\")\n",
        "        return True\n",
        "    else:\n",
        "        error(f\"Verification failed.\\nFailed items: {len(fails)}\\n{list_lines(fails, str = True)}\")\n",
        "    return False\n",
        "\n",
        "def revert_download_file_transfer(delpaths, backup):\n",
        "    info('Reverting transfered files.')\n",
        "    for path in delpaths:\n",
        "        path0 = path + '/*'\n",
        "        path1 = re.sub(del_re, '', path)\n",
        "        mv(path0, path1, backup = backup)\n",
        "    return\n",
        "\n",
        "def transfer_download_files(handle, copy = False):\n",
        "    handle.pause()\n",
        "    attrs: DownloadAttrs = handle.attrs\n",
        "    status = handle.status()\n",
        "    name = status.name\n",
        "    p1 = status.save_path + \"/\" + name\n",
        "    p0 = status.save_path\n",
        "    info(f'Transfering files for: {name}\\nNewname: {attrs.save_name}')\n",
        "    p2 = done_path + \"/\" + attrs.save_name\n",
        "    if os.path.exists(p1):\n",
        "        single = not os.path.isdir(p1)\n",
        "        if single:\n",
        "            info(f'The download is a single file without a directory\\nMoving the download into a directory with the same name.')\n",
        "            p0 = status.save_path + \"/\" + os.path.splitext(name)[0]\n",
        "            os.makedirs(p0, exist_ok = True)\n",
        "            if not copy:\n",
        "                info(f'Moving {p1} to {p0}')\n",
        "                !mv \"$p1\" \"$p0\"\n",
        "            else:\n",
        "                info(f'Copying {p1} to {p0}')\n",
        "                !cp \"$p1\" \"$p0\"\n",
        "            p1 = p0 \n",
        "        shave_download(handle, p0, p1)\n",
        "        clean_download(attrs, path = p1)\n",
        "        if (not copy) or single:\n",
        "            info(f'Moving to done path with the new name\\n {p1} to {p2}')\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "        else:\n",
        "            info(f'Copying to done path with the new name\\n {p1} to {p2}')  \n",
        "            !cp -r \"$p1\" \"$p2\"\n",
        "    else:\n",
        "        m = f\"Download dir or file is missing {p1} \"\n",
        "        error(m)\n",
        "        release()\n",
        "    if not attrs.save_name:\n",
        "        attrs.save_name = name\n",
        "        p2 = p2 + attrs.save_name \n",
        "\n",
        "    pre_download_transfer(attrs, p2)  \n",
        "    if attrs.type_ == EPISODE and os.path.isdir(p2):\n",
        "        p2 = p2 + \"/\"     \n",
        "    if os.path.exists(p2):\n",
        "        if attrs.replace and attrs.downloaded:\n",
        "            clean_download_destination(attrs) \n",
        "\n",
        "        info(f'Saving {attrs.save_name} to: {attrs.save_path}')\n",
        "        msg = !rsync --size-only -r \"$p2\" \"$attrs.save_path\"\n",
        "        if msg:\n",
        "            error(lines = msg)\n",
        "            list_lines(msg)\n",
        "            main_verification = False\n",
        "        else:\n",
        "            main_verification = verify_saving_download(attrs)   \n",
        "        if attrs.backup:\n",
        "            for bk in attrs.baksv:\n",
        "                info(f'Copying {attrs.save_name} to: {bk}')\n",
        "                msg = !rsync --size-only -r \"$p2\" \"$bk\"\n",
        "                if msg:\n",
        "                    error(lines = msg)\n",
        "                    list_lines(msg) \n",
        "        if main_verification:\n",
        "            info(f'Deleting {p2}')\n",
        "            !rm -r \"$p2\"    \n",
        "            if attrs.uncomplete_source and os.path.exists(attrs.uncomplete_source):\n",
        "                info(f'Deleting uncompleted source: {attrs.uncomplete_source}')\n",
        "                !rm -r \"$attrs.uncomplete_source\"  \n",
        "            if attrs.replace and attrs.old_files:\n",
        "                info('Deleting replaced files.')\n",
        "                for p in attrs.old_files:\n",
        "                    rm(p, process_backup = attrs.backup) \n",
        "\n",
        "            info(f'Done saving {attrs.save_name}.')\n",
        "            return True   \n",
        "        else:\n",
        "            print(\"Transfer verification failed.\")\n",
        "            if attrs.replace and attrs.old_files:\n",
        "                revert_download_file_transfer(attrs.old_files, attrs.backup)\n",
        "            return False\n",
        "    else:\n",
        "        error(f\"Files for: {attrs.save_name} were not transfered.\")\n",
        "        return False\n",
        "\n",
        "def save_download_progress(handle, savepath):\n",
        "    status = handle.status()\n",
        "    name = status.name\n",
        "    info(f\"Saving download progress for {name}\")\n",
        "    os.makedirs(savepath, exist_ok = True)\n",
        "    p0 = temp_save +\"/\"+ name\n",
        "    p1 = f\"{savepath}/{name}\"\n",
        "    if os.path.exists(p1):\n",
        "        name2 = name + \"@SAVE2\"\n",
        "        p1 = f\"{savepath}/{name2}\"\n",
        "    print(\"\\nSaving {0} into    {1}\\n\".format(name, p1))\n",
        "    !cp -r \"$p0\" \"$p1\"\n",
        "    info(f\"Done saving download progress for {name}.\")\n",
        "  \n",
        "def save_downloads_progress(savepath):\n",
        "    if active:\n",
        "        print(\" Choose a download to save progress , q to exit:\\n\")\n",
        "        for i in range(len(active)):\n",
        "            print(\"   {0}-  {1}\".format(i+1, active[i].name))\n",
        "        print()\n",
        "        inpt =  input().lower()\n",
        "        if inpt == '' or inpt == \" \" or inpt == 'q' or inpt == \"s\":\n",
        "            return\n",
        "        if \",\" in inpt:\n",
        "            choices = inpt .split(\",\")\n",
        "        else:\n",
        "            choices = [inpt]    \n",
        "        for choice in choices:\n",
        "            try:\n",
        "                choice = int(choice) - 1\n",
        "            except Exception as e:\n",
        "                error(ex())\n",
        "                updatestatushtml('An error happend while saving download.', ERROR_EVENT)\n",
        "                continue\n",
        "            if(choice >= len(active) or choice < 0):\n",
        "                print(\"\\nThe choice is out of range.\\n\")\n",
        "            else:\n",
        "                save_download_progress(active[choice], savepath)\n",
        "            print(\"..................\")\n",
        "            print(\"      Done\\n\")\n",
        "\n",
        "def load_uncompleted(path, type_ = MOVIE, local = False):\n",
        "    (path, files, dirs) = next(os.walk(path))\n",
        "    content = filter_checks(dirs) + files\n",
        "    if content:\n",
        "        print(\" Choose a directory or a file to load:\")\n",
        "        for i in range(len(content)):\n",
        "            p00 = f\"{path}/{content[i]}\"\n",
        "            size = pathsize(p00, True)\n",
        "            print(\"   {}- {:<90}{}\".format(i+1, content[i], size))\n",
        "        print()\n",
        "        choice = input().lower()\n",
        "        if \"\" == choice or \" \" == choice or  \"q\" == choice or \"s\" == choice:\n",
        "            return\n",
        "        elif \",\" in choice:\n",
        "            choices = choice.split(\",\")\n",
        "        else:\n",
        "            choices = [choice]\n",
        "        for select in choices:\n",
        "            select = int(select) - 1\n",
        "            if select >= len(content) or select < 0 :\n",
        "                print(\"\\nThe choice is out of range.\\n\")\n",
        "            else:\n",
        "                name = content[select]\n",
        "                if not local:\n",
        "                    p0 = f\"{path}/{name}\"\n",
        "                    if content[select].endswith(\"@SAVE2\"):\n",
        "                        name = content[select].split(\"@SAVE2\")[0]\n",
        "                    p1 = f\"{temp_save}/{name}\"\n",
        "                    info(f\"Loading uncompleted download: {content[select]} to {p1}\")\n",
        "                    print(\"Loading into {}\\n\".format(p1))\n",
        "                    !cp -r \"$p0\" \"$p1\"\n",
        "                    print(\"{0} is Loaded\\n\".format(content[select]))\n",
        "                    info(f\"Uncompleted download: {content[select]} loaded to {p1}\")\n",
        "                attrs = DownloadAttrs(type_= type_, name = name)\n",
        "                r = resume_uncomplete_download(name) \n",
        "                if r == -2:\n",
        "                    break\n",
        "                print(\"\\n   ...................\\n          Done\\n\")\n",
        "    else:\n",
        "        error(\"Uncomplete directory is empty.\")\n",
        "\n",
        "def resume_uncomplete_download(attrs):\n",
        "    info(f\"Resuming download {attrs.name}\")\n",
        "    lookup = name_movie(attrs.name)\n",
        "    print(f\"Downloading: {lookup}\\nSelect a source:\\n 1 - 1337x\\n 2 - rarbg\\n\")\n",
        "    select = input().lower()\n",
        "    if select == \"s\" or select == \"\":\n",
        "        return -1\n",
        "    elif select == \"q\" or select == \" \":\n",
        "        return -2\n",
        "    elif select == \"1\":\n",
        "        attrs.site_source = L337X\n",
        "        search((L337X, True), search = lookup,  attrs= attrs)\n",
        "    elif select == \"2\":\n",
        "        attrs.site_source = RARBG\n",
        "        search((RARBG, True), search = lookup,  attrs= attrs,  rarbg_auto = True)\n",
        "    return 0\n",
        "\n",
        "def pause_resume_session(b= None):\n",
        "    try:\n",
        "        paused = ses.is_paused()\n",
        "        if appstate.running or not paused:\n",
        "            ses.pause()\n",
        "            for i in range(len(active)):\n",
        "                #active[i].progress_bar.bar_style = 'warning'\n",
        "                active[i].control_btn.disabled = True\n",
        "            appstate.running = False\n",
        "            startpause_btn.description = \"Start\"\n",
        "            info(f\"Session has been paused.\")\n",
        "        elif active or paused:\n",
        "            ses.resume()\n",
        "            for i in range(len(active)):\n",
        "                #if not active[i].paused: active[i].progress_bar.bar_style = 'info'\n",
        "                active[i].control_btn.disabled = False\n",
        "            appstate.running = True\n",
        "            startpause_btn.description = \"Pause\"\n",
        "            startmonitor()\n",
        "            info(f\"Session has been resumed.\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while pausing session.', ERROR_EVENT)\n",
        "    release()\n",
        "\n",
        "def pause_start_download(handle, btn):\n",
        "    paused = handle.status().paused\n",
        "    if paused or handle.paused:\n",
        "        with hide:\n",
        "            handle.auto_managed(True)\n",
        "        handle.resume()\n",
        "        handle.paused = False\n",
        "        handle.progress_bar.bar_style = 'info'\n",
        "        btn.description = \"||\"\n",
        "        startmonitor()\n",
        "        info(f\"Download '{handle.name}' has been resumed.\")\n",
        "    else:\n",
        "        with hide:\n",
        "            handle.auto_managed(False)\n",
        "        handle.pause()\n",
        "        handle.paused = True\n",
        "        handle.progress_bar.bar_style = 'warning'\n",
        "        btn.description = \"▷\"\n",
        "        info(f\"Download '{handle.name}' has been paused.\")\n",
        "\n",
        "def remove_download(view):\n",
        "    stopmonitor()\n",
        "    try:\n",
        "        handle = view.handle\n",
        "        hash = str(handle.info_hash())\n",
        "        remove_active_view(view)        \n",
        "        status = handle.status()\n",
        "        handle.pause()\n",
        "\n",
        "        if handle in active:\n",
        "            active.remove(handle)\n",
        "        elif handle in completed:\n",
        "            completed.remove(handle)\n",
        "\n",
        "        ses.remove_torrent(handle)\n",
        "        del downloads_dict[hash]\n",
        "        if handle.done:\n",
        "            appstate.completed -= 1\n",
        "            appstate.completed_down -= status.total_wanted\n",
        "        elif handle.dead:\n",
        "            appstate.deads -= 1\n",
        "        appstate.total_wanted -= status.total_wanted\n",
        "        info(f'{handle.name} was removed succussfully.')\n",
        "    except Exception as e:\n",
        "        error(f\"An error happened while removing {handle.name}\")\n",
        "        error(ex())\n",
        "        updatestatushtml(\"An error happened while removing download.\", ERROR_EVENT)\n",
        "    startmonitor()\n",
        "    release()\n",
        "\n",
        "### UI API\n",
        "\n",
        "CONFIG_TAB = 'configuration'\n",
        "SEARCH_TAB = 'search'\n",
        "IMDBSEARCH_TAB = 'IMDB search'\n",
        "ADD_TAB = 'adding'\n",
        "MONITOR_TAB = 'monitor'\n",
        "\n",
        "REPLACE_DOWNLOAD_DECISION = 'REPLACE'\n",
        "CANCEL_DOWNLOAD_DECISION = 'CANCEL'\n",
        "RENAME_DOWNLOAD_DECISION = 'RENAME'\n",
        "\n",
        "class AlreadyDownloadedDecision:\n",
        "    def __init__(self, action, newname = ''):\n",
        "        self.action = action\n",
        "        self.newname = newname\n",
        "    action = None\n",
        "    newname = None\n",
        "\n",
        "gethtmltitle = lambda text, titlenumber, style=\"\": f'<h{titlenumber} style=\"{style}; font-family: {FONTFAMILY_GLOBAL}\">{text}</h{titlenumber}>'\n",
        "\n",
        "def hideview(obj):\n",
        "    obj.layout.display = 'none'\n",
        "    u(obj)\n",
        "\n",
        "def showview(obj):\n",
        "    obj.layout.display = 'flex'\n",
        "\n",
        "def setviewelements(tab, container, initialview, backbtn, navprocess):\n",
        "    tab.maincontainer = container\n",
        "    container.tabname = tab.name\n",
        "    container.back_button = backbtn\n",
        "    container.viewstack = [initialview]\n",
        "    backbtn.on_click(lambda b: switchview(container))\n",
        "    appstate.navcontainers[navprocess] = container\n",
        "\n",
        "def navcontainer(key):\n",
        "    return appstate.navcontainers[key]\n",
        "  \n",
        "\n",
        "def switchview(container, nextview= None, temp= False, allowback= True, remove_on_tab_change= False, expires= 0):\n",
        "    try:\n",
        "        if container == None:\n",
        "            error(\"The sent container is None.\")\n",
        "            release()\n",
        "            return\n",
        "        \n",
        "        if hasattr(container, 'viewstack'):\n",
        "            if nextview: \n",
        "                info(f\"Switched view in container: {container.tabname.lower()}. Next view {nextview.name}.\")\n",
        "                if temp:\n",
        "                    nextview.temp = True\n",
        "                else:\n",
        "                    nextview.temp = False\n",
        "                    container.viewstack.append(nextview)\n",
        "                container.children = (nextview,)\n",
        "\n",
        "                if allowback:\n",
        "                    container.back_button.disabled = False\n",
        "                else:\n",
        "                    container.back_button.disabled = True\n",
        "                if remove_on_tab_change:\n",
        "                    appstate.navactions.append((switchview, (container,)))\n",
        "\n",
        "            elif len(container.viewstack) >= 1:\n",
        "                info(f\"Switched view in container: {container.tabname.lower()} to back.\")\n",
        "                if len(container.viewstack) > 1 and not container.children[0].temp:\n",
        "                    container.viewstack.pop(-1)\n",
        "                    \n",
        "                container.children = (container.viewstack[-1],)\n",
        "                if len(container.viewstack) == 1:\n",
        "                    container.back_button.disabled = True\n",
        "        else:\n",
        "            error(\"The container viewstack is undefined\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "\n",
        "def already_downloaded_handler(userdecision: AlreadyDownloadedDecision, attrs: DownloadAttrs):\n",
        "    try:\n",
        "        if userdecision.action == REPLACE_DOWNLOAD_DECISION:\n",
        "            attrs.replace = True\n",
        "            switchview(navcontainer(ADD_TAB), getloadingview(f'Adding download with {attrs.add_source}, and replace original'), temp= True)\n",
        "        if userdecision.action == RENAME_DOWNLOAD_DECISION and userdecision.newname: \n",
        "            attrs.save_name = userdecision.newname\n",
        "            switchview(navcontainer(ADD_TAB), getloadingview(f'Adding download with {attrs.add_source} with new name.'), temp= True)\n",
        "        elif userdecision.action == CANCEL_DOWNLOAD_DECISION:\n",
        "            switchview(navcontainer(ADD_TAB))\n",
        "            return False\n",
        "        process_adddownload_result(add_download(attrs))\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "def validateconfig():\n",
        "    return True\n",
        "\n",
        "def saveuploadedfiles():\n",
        "    os.makedirs('uploadedfiles', exist_ok= True)\n",
        "    files= set()\n",
        "    try:\n",
        "        for filename in t4source_file.value:\n",
        "            content= t4source_file.value[filename]['content']\n",
        "            filepath= f'/content/uploadedfiles/{filename}'\n",
        "            with open(filepath, 'wb') as savefile:\n",
        "                savefile.write(content)\n",
        "                files.add(filepath)\n",
        "    except Exception as e:\n",
        "        error(e)\n",
        "        print(e)\n",
        "    return files\n",
        "\n",
        "def selectallfiles(files: list[DownloadFile]):\n",
        "    doselect = False\n",
        "    for file in files:\n",
        "        if not file.selected:\n",
        "            doselect = True\n",
        "            break\n",
        "    if doselect:\n",
        "        for file in files: file.selected = True\n",
        "    else:\n",
        "        for file in files: file.selected = False\n",
        "    \n",
        "sn_in = r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\"\n",
        "sn_nm = r\"([1-9][0-9]?)\"\n",
        "\n",
        "def getfileselectionwithstr(files: list[DownloadFile], selectionstr = \"\"):\n",
        "    if not selectionstr:\n",
        "        return False\n",
        "    includerange = []\n",
        "    excluderange = []\n",
        "    seasonselectionstr = \"\"\n",
        "    if ',' in selectionstr:\n",
        "        inputs = selectionstr.split(',')\n",
        "    else:\n",
        "        inputs = [selectionstr]   \n",
        "    try: \n",
        "        for i  in inputs:\n",
        "            i = i.strip()\n",
        "            if i[0] == 's' or i[0] == 'S':\n",
        "                lookup = re.search(sn_in, i)\n",
        "                if lookup:\n",
        "                    if '-' in i:\n",
        "                        rng = i.split('-')\n",
        "                        lookup1 = re.search(sn_nm, rng[0])\n",
        "                        start = lookup1.group() if lookup1 else ''\n",
        "                        lookup1 = re.search(sn_nm, rng[1])\n",
        "                        end = lookup1.group() if lookup1 else ''\n",
        "                        if not (start or end):\n",
        "                            continue\n",
        "                        elif start and end:\n",
        "                            add = list(range(int(start), int(end) + 1))\n",
        "                        elif start:\n",
        "                            add = [int(start)]\n",
        "                        else:\n",
        "                            add = [int(end)]\n",
        "                    else:\n",
        "                        lookup1 = re.search(sn_nm, i)\n",
        "                        if lookup1:\n",
        "                            add = [int(lookup1.group())]\n",
        "                    si2 = 0\n",
        "                    if seasonselectionstr:\n",
        "                        seasonselectionstr += '|'\n",
        "                    for item in add:\n",
        "                        sep = '|' if 0 < si2 < len(add) else ''\n",
        "                        zero = '0?' if item < 10 else '' \n",
        "                        seasonselectionstr += f'{sep}({zero}{item})' \n",
        "                        si2 += 1                      \n",
        "\n",
        "            elif i.lower().startswith('n:'):\n",
        "                i = i[2:]\n",
        "                if '-' in i:\n",
        "                    rng = i.split('-')\n",
        "                    excluderange.extend(range(int(rng[0])-1, int(rng[1])))\n",
        "                else:\n",
        "                    excluderange[0].append(int(i))\n",
        "\n",
        "            else:\n",
        "                if '-' in i :\n",
        "                    rng = i.split('-')\n",
        "                    includerange.extend(range(int(rng[0])-1, int(rng[1])))          \n",
        "                else:\n",
        "                    includerange[0].append(int(i))\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        " \n",
        "    seasonselectionstr =  r\"\\b\" + f\"[Ss]({seasonselectionstr})\" + r\"(?=[Ee]|\\s|\\.)\" if seasonselectionstr else \"\"\n",
        "    includes = True if len(includerange) >= 1 or seasonselectionstr else False \n",
        "    excludes = True if len(excluderange) >= 1 else False \n",
        "    for file in files:\n",
        "        i = file.index\n",
        "        if excludes and (i in excluderange):\n",
        "            file.selected = False\n",
        "        elif includes:\n",
        "            if (seasonselectionstr and re.search(seasonselectionstr, file.name)) or (i in includerange):\n",
        "                file.selected = True\n",
        "            else:\n",
        "                file.selected = False\n",
        "\n",
        "def process_adddownload_result(result):\n",
        "    try:     \n",
        "        propertiesview =  widgets.VBox(layout= downloadproperties_layout)\n",
        "        propertiesview.name = \"Download Properties.\"\n",
        "        resultview = getaddinfosubview(result)\n",
        "        if result.status == ADDSUCCUSS: \n",
        "            info('Getting result view and files.')\n",
        "            propertiesview.titleview = resultview.titleview\n",
        "            result.handle.propertiesview = propertiesview\n",
        "            propertiesview.children = (resultview, getfileselectionsubview(result))\n",
        "\n",
        "            status = result.handle.status()\n",
        "            if status.total_wanted_done < 50000:\n",
        "                info(f\"Dead download: {result.handle.name}\")\n",
        "                appstate.deads += 1\n",
        "                result.handle.dead = True\n",
        "            else:\n",
        "                info(f\"Live download: {result.handle.name}\")\n",
        "                result.handle.dead = False\n",
        "            if result.hasmetadata:\n",
        "                setfilesandsizeinfoview(result)\n",
        "                setwantedbytes(result.handle)\n",
        "            else:\n",
        "                appstate.metacheckerthread = Thread(target= metadata_watcher, args= (result,))\n",
        "                appstate.metacheckerthread.start()\n",
        "\n",
        "            info('Launching view')  \n",
        "            create_active_download_view(result.handle)\n",
        "            active.append(result.handle)\n",
        "            if not appstate.monitoralive or not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
        "                if ses.is_paused():\n",
        "                    info(\"Resuming session\") \n",
        "                    ses.resume()\n",
        "                info(\"Launching monitor\")\n",
        "                startmonitor()\n",
        "            updatestatushtml(result.succussmessage, SUCCUSS_EVENT)\n",
        "        else:\n",
        "            propertiesview.children = (resultview,)\n",
        "        switchview(navcontainer(ADD_TAB), propertiesview, remove_on_tab_change= True)\n",
        "        release()\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while adding Download.', ERROR_EVENT)\n",
        "        release()\n",
        "\n",
        "def saveconfighandler(button):\n",
        "    switchview(t1_vbox.maincontainer, getloadingview(f'Setting up requirments'), temp= True, allowback= False)\n",
        "    config.activedownloads = view1r1v1activedownload_numeric.value\n",
        "    config.ftpenabled = view1r1v2ftptoggle_checkbox.value\n",
        "    if config.ftpenabled:\n",
        "        config.ftphost = view1r1v3ftphost_text.value \n",
        "        config.ftpuser = view1r1v3ftpuser_text.value \n",
        "        config.ftppassword = view1r1v3ftppass_text.value \n",
        "    config.gdriveenabled = view1r1v2gdrivetoggle_checkbox.value\n",
        "    if config.gdriveenabled and IS_ENV_COLAB :\n",
        "        enablegdrive()\n",
        "    #\n",
        "    config.localdownloadbase = view1r2v1localbase_text.value.strip()\n",
        "    config.remotedownloadbase = view1r2v1remotebase_text.value.strip()\n",
        "\n",
        "    global general_path, movies_path, tv_path, music_path\n",
        "    general_path = view1r2v2generallib_text.value.strip()\n",
        "    movies_path = view1r2v3movielib_text.value.strip()\n",
        "    tv_path = view1r2v3tvlib_text.value.strip()\n",
        "    music_path = view1r2v2musiclib_text.value.strip()\n",
        "    #\n",
        "    bkgeneral = view1r3v2bkgenerallib_text.value.strip()\n",
        "    if bkgeneral: generalbackups.add(bkgeneral)\n",
        "\n",
        "    bkmovie = view1r3v3bkmovielib_text.value.strip()\n",
        "    if bkmovie: moviesbackups.add(bkmovie)\n",
        "\n",
        "    bktv = view1r3v3bktvlib_text.value.strip()\n",
        "    if bktv: tvbackups.add(bktv)\n",
        "\n",
        "    bkmusic = view1r3v2bkmusiclib_text.value.strip()\n",
        "    if bkmusic: musicbackups.add(bkmusic)\n",
        "    \n",
        "    if validateconfig():\n",
        "        view1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved.\", fontsize='14px', style= saveconfstyle) \n",
        "    switchview(t1_vbox.maincontainer)\n",
        "\n",
        "def saveconffilehandler(button):\n",
        "    view1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved to file.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "def loadconffilehandler(button):\n",
        "    view1r5saveconfoutput_html.value = gethtmltext(\"Configuration loaded.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "def search_process(site, search, attrs, category= '', sort= SORT1337X_SEEDERS_DESC, page= 1):\n",
        "    info(f\"Searching for {search} in sites {', '.join(site)}\")\n",
        "    if site == L337X:\n",
        "        result = search1337x(search, sort= sort, category= category, page= page, attrs= attrs)\n",
        "\n",
        "# Add handlers\n",
        "\n",
        "def addsource_change(obj):\n",
        "    newval = t4addsourcetype_dropdown.value\n",
        "    if newval == UPLOADFILE_ADDSOURCE:\n",
        "        t4source_text.layout.display = \"none\"\n",
        "        t4source_file.layout.display = \"flex\"\n",
        "        t4sourcefile_labelhbox.layout.display = \"flex\"\n",
        "        return\n",
        "    if t4source_text.layout.display == \"none\":\n",
        "        t4source_text.layout.display = \"flex\"\n",
        "        t4source_file.layout.display = \"none\"\n",
        "        t4sourcefile_labelhbox.layout.display = \"none\"\n",
        "    if newval == MAGNET_ADDSOURCE:\n",
        "        t4source_text.description = \"Download magnet\"\n",
        "    elif newval == HASH_ADDSOURCE:\n",
        "        t4source_text.description = \"Download hash\"\n",
        "    elif newval == LOCALFILE_ADDSOURCE:\n",
        "        t4source_text.description = \"Local file path\"\n",
        "    elif newval == FILEURL_ADDSOURCE:\n",
        "        t4source_text.description = \"Download file URL\"\n",
        "\n",
        "def addinput_change(val):\n",
        "    if len(t4source_text.value.strip()) > 0:\n",
        "        if t4add_button.disabled:\n",
        "            t4add_button.disabled = False\n",
        "    else:\n",
        "        if not t4add_button.disabled:\n",
        "            t4add_button.disabled = True\n",
        "\n",
        "def addfile_change(val):\n",
        "    t4add_button.disabled = False\n",
        "\n",
        "def adddownload_handler(obj): \n",
        "    addsource = t4addsourcetype_dropdown.value\n",
        "    switchview(navcontainer(ADD_TAB), getloadingview(f'Adding download with {addsource}'), temp= True)\n",
        "    input_ = t4source_text.value\n",
        "    type_ = t4type_dropdown.value\n",
        "    backup = t4backup_checkbox.value\n",
        "    partial = t4partial_checkbox.value\n",
        "    replace = t4replace_checkbox.value\n",
        "    customname = t4customname_text.value\n",
        "    attrs = DownloadAttrs(type_ = type_, replace= replace, backup = backup, partial= partial, save_name= customname)\n",
        "    try:    \n",
        "        if addsource == LOCALFILE_ADDSOURCE:\n",
        "            result: AddResult = add_local_files(path= input_, attrs=  attrs)\n",
        "        elif addsource == UPLOADFILE_ADDSOURCE:\n",
        "            if t4source_file.value:\n",
        "                files= saveuploadedfiles()\n",
        "                if files:\n",
        "                    result: AddResult = add_local_files(files= files, attrs= attrs)\n",
        "                else:\n",
        "                    return 0\n",
        "            else:\n",
        "                return\n",
        "        elif addsource == HASH_ADDSOURCE and input_:\n",
        "            result: AddResult = add_hash_download(hash= input_, attrs= attrs)\n",
        "        elif addsource == MAGNET_ADDSOURCE and input_:\n",
        "            attrs.magnet = input_\n",
        "            attrs.add_source = addsource\n",
        "            result: AddResult = add_download(attrs)  \n",
        "    except Exception as e:\n",
        "        error(ex())     \n",
        "    if not result.awaiting_decision:\n",
        "            process_adddownload_result(result)\n",
        "\n",
        "def search_handler(obj):\n",
        "    Type = SEASON \n",
        "    Site = L337X \n",
        "    Search = \"\" \n",
        "    Page = 1 \n",
        "    Category = \"\" \n",
        "    Sort = \"\"  \n",
        "    Order = \"\" \n",
        "    Save_Name = \"\" \n",
        "    Replace = False \n",
        "    sort = SORT1337X_SEEDERS_DESC\n",
        "    if Sort == \"By Time\":\n",
        "        if Order == \"Descending\":\n",
        "            sort = SORT1337X_TIME_DESC\n",
        "        else:\n",
        "            sort = SORT1337X_TIME_ASC\n",
        "    elif Sort == \"By Size\":\n",
        "        if Order == \"Descending\":\n",
        "            sort = SORT1337X_SIZE_DESC\n",
        "        else:\n",
        "            sort = SORT1337X_SIZE_ASC\n",
        "    category = \"\" if Category == \"All\" else Category\n",
        "\n",
        "    attrs = DownloadAttrs(type_= Type, save_name = Save_Name, replace= Replace, )\n",
        "    try:\n",
        "        if Search:\n",
        "            search(sites = (Site, False), search = Search, category = category, attrs = attrs, sort = sort, page = Page, rarbg_auto = False)\n",
        "        release()\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "\n",
        "def imdb_handler(obj):\n",
        "    pass\n",
        "\n",
        "### Monitor\n",
        "\n",
        "monitoractivedownload_views = []\n",
        "monitorcompleted_views = []\n",
        "\n",
        "#stat = get_completed_stats() completed_down = stat[0] completed_up = stat[1] update_download_stats_labels(completed_down, completed_up)\n",
        "\n",
        "def get_eta(status):\n",
        "    remaining_bytes = status.total_wanted - status.total_wanted_done\n",
        "    if remaining_bytes >= 0 and status.download_rate > 0:\n",
        "        eta_sec = remaining_bytes/status.download_rate \n",
        "        eta_sec = eta_sec + 1.5 if remaining_bytes else 0\n",
        "        return f\"Estimated: {time_str(eta_sec)}\"\n",
        "    return \"\"\n",
        "\n",
        "def update_download_view(status, handle):\n",
        "    downloadvbox = handle.view\n",
        "    totalupload = status.all_time_upload\n",
        "    if totalupload == 0:\n",
        "        totalupload = status.total_upload \n",
        "    if handle.done or handle.transfering:\n",
        "        downloadvbox.progress_bar.value = 100\n",
        "        downloadvbox.progress_label.value = \"100%\"\n",
        "        downloadvbox.control_btn.disabled = True\n",
        "        downloadvbox.control_btn.description = \"▷\"\n",
        "        downloadvbox.remove_btn.disabled = True\n",
        "        if handle.transfering:\n",
        "            downloadvbox.progress_bar.bar_style = 'warning'\n",
        "            downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(0)}{whitespace3}↑ {speed_str(0)}\"\n",
        "            downloadvbox.transfer_label = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted)}{whitespace3}↑ {data_str(totalupload)}\" \n",
        "            downloadvbox.status_label.value = \"Transfering files\"\n",
        "            downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(0)} / {data_str(status.total_wanted)}\"\n",
        "            downloadvbox.eta_label.value = f\"Estimated {time_str(0)}\"\n",
        "        elif handle.done:\n",
        "            downloadvbox.progress_bar.bar_style = 'success'\n",
        "            downloadvbox.speed_label.value = f\"Completed at {whitespace3}{time.strftime('%I:%M:%S %p', time.localtime(status.completed_time))}\"\n",
        "            downloadvbox.transfer_label = \"Total time:{}{:.2f} m\".format(whitespace3, status.active_time/60)\n",
        "            downloadvbox.status_label.value = \"Completed\"\n",
        "            downloadvbox.remaining_label.value = f\"Downloaded {whitespace3}{data_str(status.total_wanted)} / {data_str(status.total_wanted)}\"\n",
        "            downloadvbox.eta_label.value = f\"Uploaded {whitespace3}{data_str(totalupload)}\"\n",
        "    else:\n",
        "        if handle.paused:\n",
        "            downloadvbox.status_label.value = 'Paused'\n",
        "            downloadvbox.control_btn.description = \"▷\"\n",
        "            downloadvbox.progress_bar.bar_style = 'warning'\n",
        "        else:\n",
        "            downloadvbox.status_label.value = downloadmonitorstatestrings[status.state]\n",
        "            downloadvbox.control_btn.description = \"||\"\n",
        "            downloadvbox.progress_bar.bar_style = 'info'\n",
        "        downloadvbox.progress_bar.value = status.progress*100\n",
        "        downloadvbox.progress_label.value = \"{:.2f}%\".format(status.progress*100)\n",
        "        downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\"\n",
        "        downloadvbox.transfer_label.value = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(totalupload)}\"\n",
        "        downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\"\n",
        "        downloadvbox.eta_label.value = get_eta(status)\n",
        "\n",
        "def u(widget):\n",
        "    widget.notify_change({'name': 'value', 'type':'update'}) \n",
        "\n",
        "def update_download_stats_labels(_download, _upload):\n",
        "    if appstate.total_wanted == 0:\n",
        "        appstate.total_progress = 0\n",
        "    else:\n",
        "        appstate.total_progress = (100*_download) / appstate.total_wanted \n",
        "    t5view1totaltorrents_label.value = f\"Total downloads:  {appstate.total_downloads}\"  \n",
        "    t5view1completed_label.value = f\"Completed: {appstate.completed}\"\n",
        "    t5view1active_label.value = f\"Active: {appstate.total_downloads-appstate.deads}\"\n",
        "    t5view1dead_label.value = f\"Dead: {appstate.deads}\"\n",
        "    t5view1totaldownload_label.value = f\"Session download:  {data_str(_download)} / {data_str(appstate.total_wanted)}\"\n",
        "    t5view1totalprogress_label.value = f\"{whitespace4}{round(appstate.total_progress,2)}%\"\n",
        "    t5view1totalupload_label.value = f\"Session upload:  {data_str(_upload)}\"\n",
        "\n",
        "def remove_active_view(view):\n",
        "    hideview(view)\n",
        "    if view in monitoractivedownload_views:\n",
        "        monitoractivedownload_views.remove(view)\n",
        "    elif view in monitorcompleted_views:\n",
        "        monitorcompleted_views.remove(view)\n",
        "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "\n",
        "def complete_active_view(view):\n",
        "    monitorcompleted_views.append(view)\n",
        "    monitoractivedownload_views.remove(view)\n",
        "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "\n",
        "def setwantedbytes(handle):\n",
        "    status = handle.status() \n",
        "    appstate.total_wanted += status.total_wanted\n",
        "    handle.progress = status.progress\n",
        "\n",
        "def create_active_download_view(handle):\n",
        "    info(f\"Creating active download view for {handle.name}\")\n",
        "    if startpause_btn.disabled:\n",
        "        startpause_btn.disabled = False  \n",
        "        startpause_btn.description = \"Pause\"\n",
        "    appstate.running = True\n",
        "    handle.transfering = False\n",
        "    handle.paused = False\n",
        "    handle.done = False\n",
        "    get_download_view(handle)\n",
        "    monitordownloadscontainer_vbox.children = monitoractivedownload_views\n",
        "    info(f\"Active download view created for {handle.name}\")\n",
        "\n",
        "def process_completed_download(handle, status):\n",
        "    try:\n",
        "        info(f'{handle.name} finished downloading.')\n",
        "        clicktask(updatestatushtml, (f\"Saving {handle.attrs.save_name} to: {handle.attrs.save_path}\", INFO_EVENT, True, False))\n",
        "        appstate.transferings += 1\n",
        "        transfer_download_files(handle, copy= False)\n",
        "        handle.done = True\n",
        "        appstate.transferings -= 1\n",
        "        stopmonitor()\n",
        "        clicktask(update_download_view, (status, handle))  \n",
        "        clicktask(complete_active_view, (handle.view,))\n",
        "        clicktask(updatestatushtml)\n",
        "        active.remove(handle)\n",
        "        completed.append(handle)\n",
        "        startmonitor()\n",
        "        handle.transfering = False\n",
        "        handle.done = True\n",
        "        handle.pause()\n",
        "        if len(active) == 0:\n",
        "            appstate.running = False\n",
        "    except Exception:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "def update_completed_stats(downloaded, uploaded):\n",
        "    appstate.completed_down += downloaded\n",
        "    appstate.completed_up += uploaded\n",
        "\n",
        "def sort_download_views():\n",
        "    monitoractivedownload_views.sort(key = lambda obj: obj.handle.progress, reverse= True)\n",
        "    sortchanged = False\n",
        "    for i, view in enumerate(monitoractivedownload_views):\n",
        "        if view.index != i:\n",
        "            sortchanged = True\n",
        "            break\n",
        "    if sortchanged:\n",
        "        monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "    \n",
        "def monitoractivedownloads():\n",
        "    appstate.monitoralive = True\n",
        "    info('Monitor thread has started.')\n",
        "    try:\n",
        "        total_download = total_up = 0\n",
        "        appstate.total_downloads = len(active)\n",
        "        clicktask(update_download_stats_labels,(total_download, total_up))\n",
        "        sleeptime = 0.4\n",
        "        while appstate.monitoralive and active:\n",
        "            if ses.is_paused(): \n",
        "                info(\"session is paused.\")\n",
        "                appstate.monitoralive = False\n",
        "                release()\n",
        "                break            \n",
        "            clicktask(sort_download_views, wait= .2)\n",
        "            active_down = active_up = active_wanted = 0\n",
        "            for index in range(len(monitoractivedownload_views)):\n",
        "                handle = monitoractivedownload_views[index].handle\n",
        "                handle.view.index = index\n",
        "                if not handle.transfering:\n",
        "                    status = handle.status()\n",
        "                    donebytes = status.total_wanted_done\n",
        "                    wantedbytes = status.total_wanted\n",
        "                    uploadedbytes = status.total_upload\n",
        "                    handle.progress = status.progress\n",
        "                    if handle.dead and donebytes > 50000:\n",
        "                        appstate.deads -= 1\n",
        "                        handle.dead = False\n",
        "                        info(f\"Download is live: {handle.name}\")\n",
        "                    clicktask(update_download_view, (status, handle))\n",
        "                    if status.is_finished or (wantedbytes > 10000 and donebytes == wantedbytes):\n",
        "                        info(f\"{handle.name} finished downloading\")\n",
        "                        handle.transfering = True\n",
        "                        appstate.completed -= 1\n",
        "                        clicktask(update_completed_stats,(wantedbytes, uploadedbytes))\n",
        "                        appstate.filetransferthread = Thread(target= process_completed_download, args= (handle, status))\n",
        "                        appstate.filetransferthread.start()\n",
        "                        if len(active) == 1:\n",
        "                            appstate.monitoralive = False\n",
        "                        break #\n",
        "                    else:\n",
        "                        active_up += uploadedbytes\n",
        "                        active_down += donebytes\n",
        "                        active_wanted += wantedbytes\n",
        "            total_download = appstate.completed_down + active_down \n",
        "            total_up = active_up + appstate.completed_up\n",
        "            appstate.total_downloads = len(active)\n",
        "            clicktask(update_download_stats_labels,(total_download, total_up))\n",
        "            release()\n",
        "            if appstate.monitoralive:\n",
        "                time.sleep(sleeptime)\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend in download monitor.', ERROR_EVENT)\n",
        "    info('Monitor thread has ended.')\n",
        "    release()\n",
        "\n",
        "def startmonitor():\n",
        "    if appstate.monitorthread == None or not appstate.monitorthread.is_alive():\n",
        "        appstate.monitorthread = Thread(target= monitoractivedownloads)\n",
        "        appstate.monitorthread.start()\n",
        "\n",
        "def stopmonitor():\n",
        "    appstate.monitoralive= False\n",
        "    while appstate.monitorthread.is_alive():\n",
        "        time.sleep(.01)\n",
        "\n",
        "### UI    \n",
        "### general style\n",
        "\n",
        "layout_15 ={'width':'auto', 'flex':'15 1 0%', 'align_items':\"center\"}\n",
        "layout_10 ={'width':'auto', 'flex':'10 1 0%', 'align_items':\"center\"}\n",
        "layout_8 ={'width':'auto', 'flex':'8 1 0%', 'align_items':\"center\"}\n",
        "layout_7 ={'width':'auto', 'flex':'7 1 0%', 'align_items':\"center\"}\n",
        "layout_5 ={'width':'auto', 'flex':'5 1 0%', 'align_items':\"center\"}\n",
        "layout_4 ={'width':'auto', 'flex':'4 1 0%', 'align_items':\"center\"}\n",
        "layout_3 ={'width':'auto', 'flex':'3 1 0%', 'align_items':\"center\"}\n",
        "layout_2 ={'width':'auto', 'flex':'2 1 0%', 'align_items':\"center\"}\n",
        "layout_1 ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"center\"}\n",
        "layout_1E ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"flex-start\"}\n",
        "\n",
        "col4layout = {'width':'%25','flex':'3 1 0%', 'align_items':\"center\"}\n",
        "col3layout = {'width':'%33','flex':'2 1 0%', 'align_items':\"center\"}\n",
        "col2layout = {'width':'%50','flex':'1 1 0%', 'align_items':\"center\"}\n",
        "\n",
        "empty_label_1 = widgets.Label(value = \"\", layout = layout_1)\n",
        "empty_label_2 = widgets.Label(value = \"\", layout = layout_2)\n",
        "empty_label_3 = widgets.Label(value = \"\", layout = layout_3)\n",
        "empty_label_4 = widgets.Label(value = \"\", layout = layout_4)\n",
        "empty_label_5 = widgets.Label(value = \"\", layout = layout_5)\n",
        "\n",
        "whitespace1 = ' '\n",
        "whitespace2 = '  '\n",
        "whitespace3 = '   '\n",
        "whitespace4 = '    '\n",
        "whitespace5 = '     '\n",
        "\n",
        "### UI Elements\n",
        "\n",
        "rowlayout = {'flex_flow':'row', 'align_items':'center', 'width':'90%', 'height':'160px', 'justify_content':'center'}\n",
        "saverowlayout = { 'flex_flow':'row', 'align_items':'center', 'width':'80%', 'justify_content':'center' }\n",
        "input_style = {\"description_width\":\"160px\"}\n",
        "samplestyle = {\"padding\":\"0 200px 0 200px\"}\n",
        "conflabelstyle = {\"padding\":\"0 0 0 150px\"}\n",
        "mainbox_layout = { 'height': MAINBOX_HEIGHT, 'width': '100%', 'margin':'0 0 20px 0' , 'border': f'1px solid {ACCENT_COLOR}', 'display': 'flex'}\n",
        "tabtitlerow_layout = widgets.Layout(height= '100px', width= '100%', padding= '10px 100px', align_items=  'center')\n",
        "formcontent_layout = {'height':'100%', 'width':'100%', 'padding':'40px 30% 0 0'}\n",
        "downloadproperties_layout = {'height':'100%', 'width':'100%', 'padding':'20px 50px'}\n",
        "viewcontainer_layout = widgets.Layout(height= '100%', width= '100%')\n",
        "t_formrow_layout = widgets.Layout(align_items= 'center', height= '50px', width= '100%', justify_content= 'center', padding= '0')\n",
        "tab_title_layout = widgets.Layout( width= \"200px\")\n",
        "t2labels_layout = {'width':'35%', 'justify_content': 'flex-end'}\n",
        "t2labels_style = {'font_size': '18px'}\n",
        "t2checkboxs_layout = {'margin':'5px 0 0 10px', 'justify_items': 'flex-start','justify_content': 'flex-start','align_content': 'flex-start',}\n",
        "t2controls_layout = {'margin':'0 0 0 10px', 'width':'400px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
        "t2controls_style = {'font_size': '16px', 'description_width':'150px'}\n",
        "bigbtn_style = {'font_size':'16px', 'font_weight':'600'}\n",
        "bigbtn_layout = {'width':'120px', 'height':'50px', 'margin': '0 0 8px 0'}\n",
        "top_btn_layout = {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'}\n",
        "\n",
        "\n",
        "startpause_btn = widgets.Button(disabled= True, description=\"Start\", style= bigbtn_style, layout= top_btn_layout)\n",
        "startpause_btn.layout.margin =  '0 0 0 25px'\n",
        "startpause_btn.on_click(pause_resume_session)\n",
        "\n",
        "status_html = widgets.HTML(layout= {'with': '50%', 'margin': '0 0 0 20px'})\n",
        "status_html.temp = True\n",
        "\n",
        "### Tab 1: Configuration\n",
        "### r1\n",
        "\n",
        "t1title_html = widgets.HTML(gethtmltitle('Configurations', 1), layout= tab_title_layout)\n",
        "t1back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "t1r1_hbox = widgets.HBox((t1title_html, t1back_btn, startpause_btn, status_html), layout= tabtitlerow_layout)\n",
        "\n",
        "### view1r1v1\n",
        "\n",
        "view1r1v1activedownload_numeric = widgets.BoundedIntText(value=5, min=1, max=25, step=1, description='Active Downloads', disabled=False, style=input_style)\n",
        "view1r1v1_vbox = widgets.VBox((view1r1v1activedownload_numeric,), layout= col4layout)\n",
        "\n",
        "### view1r1v2\n",
        "\n",
        "view1r1v2ftptoggle_checkbox = widgets.Checkbox(description= \"Enable FTP\", value= False, disabled= False)\n",
        "view1r1v2gdrivetoggle_checkbox = widgets.Checkbox(description= \"Enable Google Dirve\", value= True)\n",
        "view1v2vbox = widgets.VBox((view1r1v2ftptoggle_checkbox, view1r1v2gdrivetoggle_checkbox), layout= col4layout)\n",
        "\n",
        "### t1r1v3\n",
        "\n",
        "view1r1v3ftphost_text = widgets.Text(placeholder= \"FTP host address\", description= \"FTP Host\", style= input_style)\n",
        "view1r1v3ftpuser_text = widgets.Text(placeholder= \"FTP account username\", description= \"FTP Username\", style= input_style)\n",
        "view1r1v3ftppass_text = widgets.Password(placeholder= \"FTP account Password\", description=\"FTP Password\", style= input_style)\n",
        "view1r1v3_vbox = widgets.VBox((view1r1v3ftphost_text, view1r1v3ftpuser_text, view1r1v3ftppass_text), layout= col4layout)\n",
        "\n",
        "view1r1_hbox = widgets.HBox((view1r1v1_vbox, view1v2vbox, view1r1v3_vbox), layout= rowlayout)\n",
        "\n",
        "### view1r2v1\n",
        "\n",
        "view1r2v1localbase_text = widgets.Text(placeholder= \"Local Base\", description= \"Local Base\", value= LOCALBASE_DEFAULT, style= input_style)\n",
        "view1r2v1remotebase_text = widgets.Text(placeholder= \"Remote Base\", description=\"Remote Base\", value= REMOTEBASE_DEFAULT, style= input_style)\n",
        "view1r2v1_vbox = widgets.VBox((view1r2v1localbase_text, view1r2v1remotebase_text), layout= col3layout)\n",
        "\n",
        "### t1r2v2\n",
        "\n",
        "view1r2v2generallib_text = widgets.Text(placeholder= \"Downloads Path\", description= \"Downloads Path\", value= GENERAL_DRIVE_PATH_DEFAULT, style= input_style)\n",
        "view1r2v2musiclib_text = widgets.Text(placeholder= \"Music Library\", description= \"Music Library\", value= MUSIC_DRIVE_PATH_DEFAULT, style= input_style)\n",
        "view1r2v2_vbox = widgets.VBox((view1r2v2generallib_text, view1r2v2musiclib_text), layout= col3layout)\n",
        "\n",
        "### t1r2v3\n",
        "\n",
        "view1r2v3movielib_text = widgets.Text(placeholder= \"Movies Library\", description= \"Movies Library\", value= MOVIES_DRIVE_PATH_DEFAULT, style= input_style)\n",
        "view1r2v3tvlib_text = widgets.Text(placeholder= \"TV Library\", description= \"TV Library\", value= TV_DRIVE_PATH_DEFAULT, style= input_style)\n",
        "view1r2v3_vbox = widgets.VBox((view1r2v3movielib_text, view1r2v3tvlib_text), layout= col3layout)\n",
        "view1r2_hbox = widgets.HBox((view1r2v1_vbox, view1r2v2_vbox, view1r2v3_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r3v1\n",
        "\n",
        "view1r3v1_vbox = widgets.VBox(layout= col3layout)\n",
        "\n",
        "### t1r3v2\n",
        "\n",
        "view1r3v2bkgenerallib_text = widgets.Text(placeholder= \"Backup General Library\", description= \"Backup General Library\", value= '', style= input_style)\n",
        "view1r3v2bkmusiclib_text = widgets.Text(placeholder= \"Backup Music Library\", description= \"Backup Music Library\", value= '', style= input_style)\n",
        "view1r3v2_vbox = widgets.VBox((view1r3v2bkgenerallib_text, view1r3v2bkmusiclib_text), layout= col3layout)\n",
        "\n",
        "### t1r3v3\n",
        "\n",
        "view1r3v3bkmovielib_text = widgets.Text(placeholder= \"Backup Movie Library\", description= \"Backup Movie Library\", value= '', style= input_style)\n",
        "view1r3v3bktvlib_text = widgets.Text(placeholder= \"Backup TV Library\", description= \"Backup TV Library\", value= '', style= input_style)\n",
        "view1r3v3_vbox = widgets.VBox((view1r3v3bkmovielib_text, view1r3v3bktvlib_text), layout= col3layout)\n",
        "\n",
        "view1r3_hbox = widgets.HBox((view1r3v1_vbox, view1r3v2_vbox, view1r3v3_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r4v1\n",
        "\n",
        "view1r4v1_vbox = widgets.VBox(layout= col2layout)\n",
        "\n",
        "### t1r4v2\n",
        "\n",
        "view1r4v2conffile_text = widgets.Text(placeholder= \"Configuration File\", description= \"Configuration File\", value= '', style= input_style)\n",
        "view1r4v2saveconffile_button = widgets.Button(description= \"Export Configuration\",)\n",
        "view1r4v2saveconffile_button.on_click(saveconffilehandler)\n",
        "\n",
        "view1r4v2loadconffile_button = widgets.Button(description= \"Load Configuration\",)\n",
        "view1r4v2loadconffile_button.on_click(loadconffilehandler)\n",
        "view1r4v2conffile_hbox = widgets.HBox((view1r4v2saveconffile_button, view1r4v2loadconffile_button), layout= {\"width\":\"auto\",\"justify-content\":\"space-around\"})\n",
        "view1r4v2_vbox = widgets.VBox((view1r4v2conffile_text, view1r4v2conffile_hbox), layout= col2layout)\n",
        "\n",
        "view1r4_hbox = widgets.HBox((view1r4v1_vbox, view1r4v2_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r5\n",
        "\n",
        "saveconfstyle = f\"color:{SUCCESS_COLOR}\"\n",
        "view1r5saveconf_button = widgets.Button(description= \"Save Configuration\",)\n",
        "view1r5saveconf_button.on_click(saveconfighandler)\n",
        "view1r5saveconfoutput_html = widgets.HTML(layout= layout_4)\n",
        "view1r5saveconfig_Box = widgets.Box((empty_label_3 ,view1r5saveconf_button, empty_label_1, view1r5saveconfoutput_html), layout= saverowlayout)\n",
        "view1r5_hbox = widgets.HBox((view1r5saveconfig_Box,), layout= rowlayout)\n",
        "\n",
        "t1view1_vbox = widgets.VBox((view1r1_hbox, view1r2_hbox, view1r3_hbox, view1r4_hbox, view1r5_hbox), )\n",
        "t1r2container_vbox = widgets.VBox((t1view1_vbox,), layout= viewcontainer_layout)\n",
        "t1_vbox = widgets.VBox((t1r1_hbox, t1r2container_vbox), layout= mainbox_layout)\n",
        "t1_vbox.name = \"Config Tab\"\n",
        "setviewelements(t1_vbox, t1r2container_vbox, t1view1_vbox, t1back_btn, CONFIG_TAB)\n",
        "\n",
        "### Tab 2: Search\n",
        "## Row 1: Title\n",
        "\n",
        "t2title_html = widgets.HTML(gethtmltitle('Search', 1), layout= tab_title_layout)\n",
        "t2back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "t2r1_hbox = widgets.HBox((t2title_html, t2back_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## Row 2: Main Content\n",
        "# View 1: Search\n",
        "\n",
        "t2search_text = widgets.Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t2search_hbox = widgets.HBox((t2search_text,),layout= t_formrow_layout)\n",
        "\n",
        "t2type_dropdown = widgets.Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2type_hbox = widgets.HBox((t2type_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t2site_dropdown = widgets.Dropdown(description= \"Site\", value= L337X, options = [('1337x', L337X)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2site_hbox = widgets.HBox((t2site_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2page_int = widgets.IntText(description= \"Page\", value= 0, layout= t2controls_layout, style= t2controls_style)\n",
        "t2page_hbox = widgets.HBox((t2page_int,),layout= t_formrow_layout)\n",
        "\n",
        "t2searchcategory_dropdown = widgets.Dropdown(description= \"Search Category\", value= ALLCATEGORIES, options = [('All', ALLCATEGORIES), ('Movies', MOVIESCATEGORY), ('TV', TVCATEGORY), ('Apps', APPSCATEGORY), ('Games', GAMESCATEGORY)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2searchcategory_hbox = widgets.HBox((t2searchcategory_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2sort_dropdown = widgets.Dropdown(description= \"Results Sorting\", value= SEEDERSSORT, options = [('By Seeders', SEEDERSSORT), ('By Time', TIMESORT), ('By Size', SIZESORT)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2sort_hbox = widgets.HBox((t2sort_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2order_dropdown = widgets.Dropdown(description= \"Results Order\", value= DESCORDER, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2order_hbox = widgets.HBox((t2order_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t2replace_checkbox = widgets.Checkbox(description= \"Replace Existing\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2replace_hbox = widgets.HBox((t2replace_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2backup_checkbox = widgets.Checkbox(description= \"Save Backup\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2backup_hbox = widgets.HBox((t2backup_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2partial_checkbox = widgets.Checkbox(description= \"Partial Download\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2partial_hbox = widgets.HBox((t2partial_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2customname_text = widgets.Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t2customname_hbox = widgets.HBox((t2customname_text,),layout= t_formrow_layout)\n",
        "\n",
        "t2search_button = widgets.Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
        "t2search_button.layout.align_self = \"center\"\n",
        "\n",
        "t2view1_search_vbox= widgets.VBox((t2search_hbox, t2type_hbox, t2site_hbox,\n",
        "                                   t2page_hbox, t2searchcategory_hbox,\n",
        "                                   t2sort_hbox, t2order_hbox, t2replace_hbox,\n",
        "                                   t2backup_hbox, t2partial_hbox,\n",
        "                                    t2customname_hbox, t2search_button), layout= formcontent_layout)\n",
        "\n",
        "t2r2viewcontainer_vbox = widgets.VBox((t2view1_search_vbox, ), layout= viewcontainer_layout)\n",
        "t2_vbox = widgets.VBox((t2r1_hbox, t2r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t2_vbox.name = \"Search Tab\"\n",
        "setviewelements(t2_vbox, t2r2viewcontainer_vbox, t2view1_search_vbox, t2back_btn, SEARCH_TAB)\n",
        "\n",
        "### Tab 3: IMDB Search\n",
        "## Row 1: Title\n",
        "\n",
        "t3title_html = widgets.HTML(gethtmltitle('IMDB Search', 1), layout= tab_title_layout)\n",
        "t3back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "\n",
        "t3r1_hbox = widgets.HBox((t3title_html, t3back_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "t3r2imdbsearchview_vbox = widgets.VBox(layout= formcontent_layout)\n",
        "t3r2viewcontainer_vbox = widgets.VBox((t3r2imdbsearchview_vbox,), layout= viewcontainer_layout)\n",
        "t3_vbox = widgets.VBox((t3r1_hbox, t3r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t3_vbox.name = \"IMDB Search Tab\"\n",
        "setviewelements(t3_vbox, t3r2viewcontainer_vbox, t3r2imdbsearchview_vbox, t3back_btn, IMDBSEARCH_TAB)\n",
        "\n",
        "### Tab 4: Adding Downloads\n",
        "## R1: Title\n",
        "\n",
        "t4title_html = widgets.HTML(gethtmltitle('Add Downloads', 1), layout= tab_title_layout)\n",
        "t4back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "\n",
        "t4r1_hbox = widgets.HBox((t4title_html, t4back_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## R2: Main Content\n",
        "\n",
        "t4addsourcetype_dropdown = widgets.Dropdown(description= \"Download Type\", value= MAGNET_ADDSOURCE, \n",
        "                                         options= [('Magnet', MAGNET_ADDSOURCE), ('Hash', HASH_ADDSOURCE),\n",
        "                                        ('Upload File', UPLOADFILE_ADDSOURCE), ('Local File', LOCALFILE_ADDSOURCE), ('File URL', FILEURL_ADDSOURCE)],\n",
        "                                         layout= t2controls_layout, style= t2controls_style)\n",
        "t4addsourcetype_hbox = widgets.HBox((t4addsourcetype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t4source_text = widgets.Text(description= \"Magnet\", layout= t2controls_layout, style= t2controls_style)\n",
        "\n",
        "t4sourcefile_labelhbox = widgets.HBox((widgets.Label(value= \"Torrent File\", layout= {\"width\":'auto'}),),\n",
        "                                      layout= {'height':'auto', 'display':'none', 'width':'170px', 'margin': '0 11px 0 0'})\n",
        "t4sourcefile_labelhbox.layout.justify_content= 'flex-end'\n",
        "t4sourcefile_labelhbox.layout.align_items = 'center'\n",
        "\n",
        "t4source_file = widgets.FileUpload(description= \"Upload File\", layout= {'width':'240px', 'align-items': 'center','justify-content':'flex-start'})\n",
        "t4source_file.layout.display = 'none'\n",
        "t4source_file.layout.align_items = 'center'\n",
        "\n",
        "t4source_hbox = widgets.HBox((t4source_text, t4sourcefile_labelhbox, t4source_file), layout= t_formrow_layout)\n",
        "\n",
        "t4type_dropdown = widgets.Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK)], layout= t2controls_layout, style= t2controls_style)\n",
        "t4type_hbox = widgets.HBox((t4type_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t4replace_checkbox = widgets.Checkbox(description= \"Replace Existing\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4replace_hbox = widgets.HBox((t4replace_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4backup_checkbox = widgets.Checkbox(description= \"Save Backup\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4backup_hbox = widgets.HBox((t4backup_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4partial_checkbox = widgets.Checkbox(description= \"Partial Download\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4partial_hbox = widgets.HBox((t4partial_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4customname_text = widgets.Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t4customname_hbox = widgets.HBox((t4customname_text,),layout= t_formrow_layout)\n",
        "\n",
        "t4add_button = widgets.Button(description= \"Add\", disabled= True, layout= bigbtn_layout, style= bigbtn_style)\n",
        "t4add_button.layout.align_self = \"center\"\n",
        "\n",
        "t4r2view1_adddownload_vbox= widgets.VBox((t4addsourcetype_hbox, t4source_hbox, t4type_hbox, t4replace_hbox, t4backup_hbox, t4partial_hbox, t4customname_hbox, t4add_button), layout= formcontent_layout)\n",
        "t4r2viewcontainer_vbox = widgets.VBox((t4r2view1_adddownload_vbox,), layout= viewcontainer_layout)\n",
        "\n",
        "t4_vbox = widgets.VBox((t4r1_hbox, t4r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t4_vbox.name = \"Add Tab\"\n",
        "setviewelements(t4_vbox, t4r2viewcontainer_vbox, t4r2view1_adddownload_vbox, t4back_btn, ADD_TAB)\n",
        "\n",
        "### Tab 5: Downloads Monitor\n",
        "## Row 1: Title\n",
        "\n",
        "t5title_html = widgets.HTML(gethtmltitle('Downloads', 1), layout= tab_title_layout)\n",
        "t5back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "t5r1_hbox = widgets.HBox((t5title_html, t5back_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## Row 2: Monitor view\n",
        "\n",
        "downloadtransferstate = 9\n",
        "downloadmonitorstatestrings = [\"Queued\",\"Checking\",\"Downloading metadata\",\"Downloading\",\"Finished\",\"Seeding\",\"Allocating\",\"Checking resume files\", \"Transfering files\"]\n",
        "\n",
        "t5view1container_layout = {'width':'100%', 'height':'100%'}\n",
        "t5view1r1_layout = {'flex_flow':'row','align_items':'center', 'height':'40px', 'width':'100%','justify_content':'space-around'}\n",
        "t5view1r2manage_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','height':'50px','justify_content':'flex-start'}\n",
        "t5view1r3_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','justify_content':'space-around'}\n",
        "t5view1column_layout = {'width':'95%','align_items':'center','border':'solid #d9dbda 1px'}\n",
        "t5view1download_layout = {'flex_flow':'row','align_items':'center','width':'95%','justify_content':'space-around'}\n",
        "\n",
        "t5view1sessionstatus_label = widgets.Label(layout= layout_3)\n",
        "t5view1totaltorrents_label = widgets.Label(value= \"Total downloads:  0\", layout= layout_3)\n",
        "t5view1active_label = widgets.Label(value= \"Active:  0\", layout= layout_3)\n",
        "t5view1dead_label = widgets.Label(value= \"Dead:  0\", layout= layout_3)\n",
        "\n",
        "t5view1completed_label = widgets.Label(value= \"Completed:  0\", layout= layout_3)\n",
        "t5view1totaldownload_label=widgets.Label(value= \"Session download:  0 MB\", layout= layout_5)\n",
        "t5view1totalprogress_label=widgets.Label(value= \"\", layout= layout_3)\n",
        "t5view1totalupload_label=widgets.Label(value= \"Session upload:  0 MB\", layout= layout_5)   \n",
        "\n",
        "t5view1r2stats_box = widgets.Box([t5view1sessionstatus_label, t5view1totaltorrents_label, t5view1active_label, t5view1completed_label, t5view1dead_label, t5view1totaldownload_label, t5view1totalprogress_label, t5view1totalupload_label, empty_label_3], layout= t5view1r1_layout)\n",
        "monitordownloadscontainer_vbox = widgets.VBox(layout= {'align_items': \"center\", 'width':'99.8%', 'height':'100%', 'margin': '22px 0 0 0'})\n",
        "monitordownload_layout = {'width':'95%','align_items':'center','border':'solid #d9dbda 1px', 'margin': \"0 0 7px 0\"}\n",
        "t5view1downloadmonitor_vbox = widgets.VBox((t5view1r2stats_box, monitordownloadscontainer_vbox), layout= {'width':'100%', 'height':'100%'})\n",
        "t5r2viewcontainer_vbox = widgets.VBox((t5view1downloadmonitor_vbox,), layout= viewcontainer_layout)\n",
        "\n",
        "t5_vbox = widgets.VBox((t5r1_hbox, t5r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t5_vbox.name = \"Monitor Tab\"\n",
        "setviewelements(t5_vbox, t5r2viewcontainer_vbox, t5view1downloadmonitor_vbox, t5back_btn, MONITOR_TAB)\n",
        "\n",
        "###\n",
        "\n",
        "def tabchanged_handler(change):\n",
        "    appstate.currentviewcontainer = main_tabs.children[change['new']].maincontainer\n",
        "    if status_html.temp:\n",
        "        status_html.value = ''\n",
        "    if appstate.navactions:\n",
        "        try:\n",
        "            actions = appstate.navactions.copy()\n",
        "            appstate.navactions.clear()\n",
        "            info(f\"Completing navigation actions. Action count: {len(actions)}.\")\n",
        "            for action in actions:\n",
        "                action[0](*action[1])\n",
        "        except Exception as e:\n",
        "            error(ex())\n",
        "        release()\n",
        "\n",
        "main_tabs = widgets.Tab([t1_vbox, t2_vbox, t3_vbox, t4_vbox, t5_vbox])\n",
        "main_tabs.observe(tabchanged_handler, 'selected_index')\n",
        "\n",
        "main_tabs.set_title(0, 'Configuration')\n",
        "main_tabs.set_title(1, 'Search')\n",
        "main_tabs.set_title(2, 'IMDB Search')\n",
        "main_tabs.set_title(3, 'Add Downloads')\n",
        "main_tabs.set_title(4, 'Downloads')\n",
        "\n",
        "### Dynamic views\n",
        "\n",
        "addresultlayout =  {'height': '330px', 'width': '100%'}\n",
        "addresultrowlayout = {}\n",
        "addrestitlefont = '22px'\n",
        "addrestitlestyle = ' display: inline-block; margin: 0 0 10px 40px'\n",
        "addresultlabelfontsize = '18px'\n",
        "addresultvaluefontsize = '16px'\n",
        "addreslabelstyle = 'width:180px; display: inline-block; text-align: end; margin: 0 40px 0 0'\n",
        "\n",
        "fileselectionlayout =  {'height': '470px', 'width': '100%'}\n",
        "fileselectiontitlestyle = ' display: inline-block; margin: 0 20px 10px 40px'\n",
        "fileselectionbuttonlayout = {'width': '100px', 'height': '30px'}\n",
        "filerowfontsize = '16px'\n",
        "filetableformatters = {'Download': {'type': 'tickCross'},}\n",
        "filetableeditors = {'No': None, 'Download': CheckboxEditor(), 'Size': None,'Name': None, }\n",
        "filetablecolumnwidths={'No': '8%', 'Download': '15%', 'Size': '12%', 'Name': '65%'}\n",
        "\n",
        "def getmessageview(text):\n",
        "    t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    message_container = f'<div style=\"height: {MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text , style=t1style)} </div>'\n",
        "    return widgets.HTML(message_container)\n",
        "\n",
        "def gettorrentsearchresultsview():\n",
        "    return None\n",
        "\n",
        "def getimdbsearchresultsview():\n",
        "    return None\n",
        "\n",
        "def setfilesandsizeinfoview(result: AddResult):\n",
        "    result.sizehtml.value = gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( data_str(result.size), fontsize= addresultvaluefontsize)\n",
        "    result.selectedfileshtml.value = gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.selectedfiles_count, fontsize= addresultvaluefontsize)\n",
        "\n",
        "def getaddinfosubview(result: AddResult):\n",
        "    if result.status == ADDSUCCUSS:\n",
        "        resulttitlehtml = widgets.HTML(gethtmltext(\"Download Properties\", fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        namehtml = widgets.HTML(gethtmltext(\"Download name:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext(result.name, fontsize= addresultvaluefontsize))\n",
        "        savenamehtml = widgets.HTML(gethtmltext(\"Save as:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savename,fontsize= addresultvaluefontsize))\n",
        "        sizehtml = widgets.HTML(gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
        "        fileshtml = widgets.HTML(gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
        "        hashhtml = widgets.HTML(gethtmltext(\"Hash:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.hash, fontsize= addresultvaluefontsize))\n",
        "        savepathhtml = widgets.HTML(gethtmltext(\"Save path:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savepath, fontsize= addresultvaluefontsize))\n",
        "        children = (resulttitlehtml, namehtml, savenamehtml, sizehtml, fileshtml, hashhtml, savepathhtml)\n",
        "        result.sizehtml = sizehtml\n",
        "        result.selectedfileshtml = fileshtml\n",
        "    else:\n",
        "        resulttitlehtml = widgets.HTML(gethtmltext(result.errormessage, fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        children = (resulttitlehtml,)\n",
        "    downloadinfoview = widgets.VBox(children, layout= addresultlayout)\n",
        "    downloadinfoview.titleview = resulttitlehtml\n",
        "    return downloadinfoview\n",
        "\n",
        "def getdownloadsdataframe(files: list[DownloadFile]):\n",
        "    filetablesource = {\"No\": [], \"Download\":[], \"Size\": [], \"Name\": []}\n",
        "    for item in files:\n",
        "        filetablesource['No'].append(item.index + 1)\n",
        "        filetablesource['Download'].append(item.selected)\n",
        "        filetablesource['Size'].append(data_str(item.size))\n",
        "        filetablesource['Name'].append(item.name)\n",
        "    return pd.DataFrame(filetablesource)\n",
        "\n",
        "def makefiletable(files: list[DownloadFile]):\n",
        "    dataframe = getdownloadsdataframe(files)\n",
        "    filetable = panel.widgets.Tabulator(dataframe, sizing_mode='stretch_width', widths= filetablecolumnwidths, disabled= False, show_index= False, pagination= None, editors= filetableeditors ,formatters=filetableformatters) \n",
        "    def editfiles(e):\n",
        "        files[e.row].selected = e.value\n",
        "    filetable.on_edit(editfiles)\n",
        "    return filetable\n",
        "\n",
        "def getfileselectionsubview(result: AddResult, fileselectionview_vbox= None):\n",
        "    if not fileselectionview_vbox:\n",
        "        fileselectionview_vbox = widgets.VBox(layout= fileselectionlayout)\n",
        "    if result.status == ADDSUCCUSS:\n",
        "        handle = result.handle\n",
        "        files: list[DownloadFile] = result.files\n",
        "        fileselectiontitle = widgets.HTML(gethtmltext(\"Select files\", fontsize= addrestitlefont, style= fileselectiontitlestyle))\n",
        "        selectall_button = widgets.Button(description= \"All\", layout= fileselectionbuttonlayout)\n",
        "        selectall_button.layout.margin = f'2px 0 20px'\n",
        "        selectall_button.layout.width = '60px'\n",
        "        selectintervals_text = widgets.Text(description= 'Intervals', placeholder= 'Start-end, single, n:start-end, s01-s03..', layout= {'width':'400px', 'margin': \"3px 0 0 0\"})\n",
        "        selectintervals_button = widgets.Button(description= \"Select\", layout= fileselectionbuttonlayout)\n",
        "        selectintervals_button.layout.margin = '2px 0 0 16px'\n",
        "        savefiles_button = widgets.Button(description= \"Save\", layout= fileselectionbuttonlayout)\n",
        "        savefiles_button.layout.margin = '2px 0 0 12px'\n",
        "        selectstatus_html = widgets.HTML(layout= {\"margin\": \"0 0 0 20px\", 'padding': '4px 0 0 0'})\n",
        "        toprow_hbox = widgets.HBox((fileselectiontitle, selectall_button, selectintervals_text, selectintervals_button, savefiles_button, selectstatus_html), layout= {'width': '100%', 'height':'60px'})\n",
        "\n",
        "        filetable = makefiletable(files)\n",
        "        filetableoutput = widgets.Output()\n",
        "        result.filetable = filetable\n",
        "        result.filetableoutput = filetableoutput\n",
        "        with filetableoutput:\n",
        "            display(filetable)\n",
        "        filetable_vbox = widgets.VBox((filetableoutput,), layout= {'width': '100%', 'height': '400px'})\n",
        "        filetable_vbox.layout.border = '1px solid #ababab'\n",
        "        fileselectionview_vbox.children = (toprow_hbox, filetable_vbox)\n",
        "        fileselectionview_vbox.filetable = filetable\n",
        "        fileselectionview_vbox.filetableoutput = filetableoutput\n",
        "\n",
        "        def selectallandpatch(b):\n",
        "            selectallfiles(files)\n",
        "            patchfiletableandinfo(result)\n",
        "            \n",
        "        def selectseasonintervalandpatch(b):\n",
        "            selection = selectintervals_text.value.strip()\n",
        "            if selection:\n",
        "                getfileselectionwithstr(files, selection)\n",
        "                patchfiletableandinfo(result)\n",
        "\n",
        "        def handlefileselection(b):\n",
        "            status = selectdownloadfiles(handle, files)\n",
        "            if status:\n",
        "                color = SUCCESS_COLOR\n",
        "                statusstr = \"Files selected successfully.\"\n",
        "                result.selectedfiles_count = handle.selected_files\n",
        "                result.size = handle.total_download\n",
        "                setfilesandsizeinfoview(result)\n",
        "            else:\n",
        "                color = FAIL_COLOR\n",
        "                statusstr = 'Files selection failed.'\n",
        "            selectstatus_html.value = gethtmltext(statusstr, fontsize= '16px', color= color)\n",
        "\n",
        "        selectall_button.on_click(selectallandpatch)\n",
        "        selectintervals_button.on_click(selectseasonintervalandpatch)\n",
        "        savefiles_button.on_click(handlefileselection)\n",
        "    return fileselectionview_vbox \n",
        "\n",
        "def metadata_watcher(result: AddResult):\n",
        "    try:\n",
        "        appstate.metacheckeralive = True\n",
        "        while  appstate.metacheckeralive:\n",
        "            torrentfile = result.handle.torrent_file()\n",
        "            if torrentfile:\n",
        "                result.hasmetadata = True\n",
        "                setwantedbytes(result.handle)\n",
        "                set_download_filtered_files(result)\n",
        "                clicktask(updatedownloadproperties, (result,))\n",
        "                appstate.metacheckeralive = False\n",
        "                break\n",
        "            time.sleep(0.2)\n",
        "        appstate.metacheckeralive = False\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while checking download metadata', ERROR_EVENT)\n",
        "    release()\n",
        "\n",
        "def updatedownloadproperties(result: AddResult):\n",
        "    dataframe = getdownloadsdataframe(result.files)\n",
        "    result.filetable.value = dataframe\n",
        "    setfilesandsizeinfoview(result)\n",
        "    result.filetableoutput.clear_output()\n",
        "    with result.filetableoutput:\n",
        "        display(result.filetable)\n",
        "\n",
        "def patchfiletableandinfo(result: AddResult): \n",
        "    patch = {\"Download\": []}\n",
        "    for i in range(len(result.files)):\n",
        "        patch[\"Download\"].append((i, result.files[i].selected))\n",
        "    result.filetable.patch(patch)\n",
        "\n",
        "def replace_download_decision(prep_res: Prepare_Result):\n",
        "    userinput_layout = {'width':'600px', 'height':'350px', 'align_items': 'center', 'justify_content': 'flex-start', 'padding': '50px 20px 0 20px', 'border': f'2px solid {GREYCOLOR}'}\n",
        "    userinputbtn_layout = {'width': '130px', 'height':'50px'}\n",
        "    message_html = widgets.HTML(gethtmltext(f'The {prep_res.typestr} \"{prep_res.attrs.name}\" is already downloaded and saved as: {prep_res.foundpath}<br>Do you want to replace old file or rename new download?', fontsize= '16px', color= DARKGERYCOLOR))\n",
        "    row1userinput_box = widgets.Box((message_html,), layout= {'width':'99%', 'height':'auto', 'padding':'0 30px', 'margin':'0 0 20px 0'})\n",
        "    replaceoption_btn = widgets.Button(description= \"Replace Download\", layout= userinputbtn_layout)\n",
        "    canceloption_btn = widgets.Button(description= \"Cancel Download\", layout= userinputbtn_layout)\n",
        "    rename_btn = widgets.Button(description= \"Rename New File\", layout= userinputbtn_layout)\n",
        "    row2userinput_hbox = widgets.HBox((replaceoption_btn, canceloption_btn, rename_btn), layout= {'justify_content':'space-around','padding':'0 50px', 'margin':'0 0 15px 0', 'width':'100%', 'align_items': 'center'})\n",
        "\n",
        "    newname_text = widgets.Text(description= \"New file name: \",style={'description_width': '100px'}, layout= {'width':'350px ', 'description_width':'120px'})\n",
        "    savename_btn = widgets.Button(description= \"OK\", disabled= True, layout= {'height':'30px', 'width':'60px'})\n",
        "    row3userinput_hbox = widgets.HBox((newname_text, savename_btn), layout= {'display':'none','justify_content':'space-around','padding':'0 60px','width':'100%', 'align_items': 'center'})\n",
        "    rename_btn.on_click(lambda b: showview(row3userinput_hbox))\n",
        "\n",
        "    def handletextinputchange(change):\n",
        "        newval = newname_text.value.strip()\n",
        "        if newval:\n",
        "            savename_btn.disabled = False\n",
        "        else: savename_btn.disabled = True\n",
        "    \n",
        "    def renamedownloadaction(b):\n",
        "        newname = newname_text.value.strip()\n",
        "        return already_downloaded_handler(AlreadyDownloadedDecision(RENAME_DOWNLOAD_DECISION, newname), prep_res.attrs)\n",
        "          \n",
        "    newname_text.observe(handletextinputchange, 'value')\n",
        "    replaceoption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(REPLACE_DOWNLOAD_DECISION), prep_res.attrs))\n",
        "    canceloption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(CANCEL_DOWNLOAD_DECISION), prep_res.attrs))\n",
        "    savename_btn.on_click(renamedownloadaction)\n",
        "\n",
        "    userinput_vbox = widgets.VBox((row1userinput_box, row2userinput_hbox, row3userinput_hbox), layout= userinput_layout)\n",
        "    userinputview_vbox = widgets.VBox((userinput_vbox,), layout= {'width':'100%', 'height':'100%','align_items': 'center', 'padding':'120px 0 0 0'})\n",
        "    userinputview_vbox.name = \"User Decision.\"\n",
        "    switchview(navcontainer(ADD_TAB), nextview= userinputview_vbox, temp= True)\n",
        "    return \n",
        "\n",
        "def updatestatushtml(message: str= '' , event= INFO_EVENT, animated= False, temp= True):\n",
        "    if not message:\n",
        "        status_html.value = ''\n",
        "    else:   \n",
        "        status_html.temp = temp\n",
        "        if event == ERROR_EVENT:\n",
        "            color = LOADING_COLOR\n",
        "        elif event == SUCCUSS_EVENT:\n",
        "            color = SUCCESS_COLOR\n",
        "        else: color = ACCENT_COLOR\n",
        "        status_html.value = gethtmltext(message, fontsize= '16px', color= color, animated= animated)\n",
        "\n",
        "### Monitor\n",
        "\n",
        "def setpatheshtml():\n",
        "    t5view1r1pathes_html = widgets.HTML(layout= {'height':'35px', 'width':'99.8%'})\n",
        "    pathstr = \"<style>.path-str{margin: 0 0 0 80px; font-size: 14px}</style>\"\n",
        "    if general_path:\n",
        "        pathstr += f'<span class=\"path-str\">Downloads: {general_path}</span>'     \n",
        "    if movies_path:\n",
        "        pathstr += f'<span class=\"path-str\">Movies: {movies_path}</span>'\n",
        "    if tv_path:\n",
        "        pathstr += f'<span class=\"path-str\">TV: {tv_path}</span>'\n",
        "    if music_path:\n",
        "        pathstr += f'<span class=\"path-str\">Music: {music_path}</span>'        \n",
        "    t5view1r1pathes_html.value = pathstr\n",
        "    info(\"Pathes html status is set.\")\n",
        "\n",
        "def get_download_view(handle):\n",
        "    status = handle.status()\n",
        "    title_label = widgets.Label(value= handle.attrs.name, layout= layout_10)\n",
        "    progress_label = widgets.Label(value= \"{:.2f}%\".format(status.progress*100), layout= layout_1)\n",
        "    progress_bar = widgets.FloatProgress(value= status.progress*100, min= 0, max= 100, step= 0.2, bar_style= 'info', orientation= 'horizontal', layout= layout_15)\n",
        "    control_btn = widgets.Button(description= \"∣∣\", layout= {'width':'25px', 'height':'28px', 'padding': '0px 1px 2px 2px', 'margin': '0 6px 0 18px'})\n",
        "    info_btn = widgets.Button(description= \"i\", layout= {'width':'25px', 'height':'27px', 'padding': '0px 2px 2px', 'margin': '0 5px 0 0'})\n",
        "    remove_btn = widgets.Button(description= \"✕\", layout= {'width':'25px', 'height':'27px', 'padding': '0px 2px 2px', 'margin': '0 20px 0 0'})\n",
        "\n",
        "    status_label = widgets.Label(value= \"Downloading\", layout= layout_2)\n",
        "    type_label = widgets.Label(value= types[handle.attrs.type_], layout= layout_2)\n",
        "    speed_label = widgets.Label(value= f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\", layout= layout_4)\n",
        "    transfered_label = widgets.Label(value= f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(status.total_upload)}\", layout= layout_4)\n",
        "    remaining_label = widgets.Label(value= f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\" , layout= layout_4)\n",
        "    eta_label = widgets.Label(value= get_eta(status), layout= layout_2)\n",
        "\n",
        "    downloadrow1box = widgets.Box((title_label, progress_label, progress_bar, empty_label_1), layout = t5view1r3_layout)\n",
        "    downloadrow2box = widgets.Box((control_btn, info_btn, remove_btn, status_label, type_label, speed_label, transfered_label, remaining_label, eta_label), layout= t5view1r3_layout)\n",
        "\n",
        "    downloadvbox = widgets.VBox((downloadrow1box,downloadrow2box), layout= monitordownload_layout)\n",
        "    downloadvbox.title_label = title_label\n",
        "    downloadvbox.progress_label = progress_label\n",
        "    downloadvbox.progress_bar = progress_bar\n",
        "    downloadvbox.control_btn = control_btn\n",
        "    downloadvbox.info_btn = info_btn\n",
        "    downloadvbox.remove_btn = remove_btn\n",
        "    downloadvbox.status_label = status_label\n",
        "    downloadvbox.type_label = type_label\n",
        "    downloadvbox.speed_label = speed_label\n",
        "    downloadvbox.transfer_label = transfered_label\n",
        "    downloadvbox.remaining_label =  remaining_label\n",
        "    downloadvbox.eta_label = eta_label\n",
        "    downloadvbox.handle = handle\n",
        "    handle.view = downloadvbox\n",
        "    handle.view.index = len(active)\n",
        "    handle.progress_bar = progress_bar \n",
        "    handle.control_btn = control_btn \n",
        "    control_btn.on_click(lambda btn: pause_start_download(downloadvbox.handle, btn))\n",
        "    info_btn.on_click(lambda btn: switchview(navcontainer(MONITOR_TAB), downloadvbox.handle.propertiesview))\n",
        "    remove_btn.on_click(lambda btn: remove_download(downloadvbox))\n",
        "    monitoractivedownload_views.append(downloadvbox)\n",
        "    info(f'Download view created for: {handle.name}')\n",
        "    return downloadvbox\n",
        "\n",
        "### Handling\n",
        "\n",
        "t4addsourcetype_dropdown.observe(addsource_change, names= \"value\")\n",
        "t4source_text.observe(addinput_change, 'value')\n",
        "t4source_file.observe(addfile_change, names= 'value')\n",
        "t4add_button.on_click(adddownload_handler)\n",
        "\n",
        "def makeclickjs(btn_desc, interval= 0, use_evaljs= False, enable_console= False, getstr= False):\n",
        "    info(f\"Creating click js for bottun discription: {btn_desc}\")\n",
        "    if IS_ENV_COLAB:\n",
        "        if interval > 0:\n",
        "            funcname= f\"pyfunc{nowstr()}\"\n",
        "            funcstart =  f\"function {funcname}() {{\"\n",
        "            funcendrepeat = f\"}} setInterval({funcname}, {interval});\"\n",
        "        else:\n",
        "            funcname = funcstart = funcendrepeat = \"\"\n",
        "        if enable_console:\n",
        "            contrue = f\"console.info('Click made to {btn_desc} button.');\"\n",
        "            confalse = f'console.info(\"{btn_desc} wasn\\'t found\");'\n",
        "        else:\n",
        "            contrue = confalse = \"\"\n",
        "        clickjs = f\"\"\"{funcstart}\n",
        "        els = Array.prototype.slice.call(document.getElementsByTagName('button')).filter(el => el.textContent.startsWith('{btn_desc}'));\n",
        "        if (els.length > 0) {{els[0].click(); {contrue}}} else {{{confalse}}} {funcendrepeat} \"\"\"\n",
        "        if getstr:\n",
        "            return clickjs\n",
        "        if use_evaljs:\n",
        "            js(clickjs, ignore_result= True)\n",
        "            info(f\"Click js for bottun {btn_desc} was sent with eval_js.\")\n",
        "        else:\n",
        "            display(Javascript(clickjs))\n",
        "            info(f\"Click js for bottun {btn_desc} was sent with display javascript.\")\n",
        "\n",
        "def clicktask(task, args= (), wait= 0):\n",
        "    appstate.clicktasks.append((task, args))\n",
        "    if wait:\n",
        "        time.sleep(wait)\n",
        "    \n",
        "def clicktaskshandler(btn= None):\n",
        "    t5r2viewcontainer_vbox.notify_change({'name': 'value', 'type':'update'}) \n",
        "    if appstate.clicktasks:\n",
        "        worktasks = appstate.clicktasks.copy()\n",
        "        appstate.clicktasks.clear()\n",
        "        try:\n",
        "            for task in worktasks:\n",
        "                task[0](*task[1])\n",
        "        except Exception as e:\n",
        "            error(ex())\n",
        "            release()\n",
        "    \n",
        "uiclicker_btn = widgets.Button(description= UICLICKER_RUN, layout= {'display':'none'})\n",
        "\n",
        "def run_uiclicker():\n",
        "    uiclicker_btn.description = UICLICKER_RUN\n",
        "def stop_uiclicker():\n",
        "    uiclicker_btn.description = UICLICKER_STOP\n",
        "\n",
        "uiclicker_btn.on_click(clicktaskshandler)\n",
        "\n",
        "##\n",
        "\n",
        "if IS_ENV_COLAB:\n",
        "    unmount = drive.flush_and_unmount\n",
        "\n",
        "def resetapp(delinit= False, delfiles= False):\n",
        "    if active:\n",
        "        for i in range(len(active)): \n",
        "            ses.remove_torrent(active[i])\n",
        "        active.clear()\n",
        "    if downloads_dict:\n",
        "        downloads_dict.clear()\n",
        "    if completed:\n",
        "        completed.clear()\n",
        "    monitoractivedownload_views.clear()\n",
        "    monitordownloadscontainer_vbox.children = ()\n",
        "    appstate.total_downloads = 0\n",
        "    appstate.completed = 0\n",
        "    appstate.deads = 0\n",
        "    appstate.total_progress = 0\n",
        "    appstate.total_wanted = 0\n",
        "    appstate.running = False\n",
        "    update_download_stats_labels(0,0)\n",
        "    if delfiles:\n",
        "        !rm -r '/content/d-0/'*\n",
        "    if delinit and 'init' in globals():\n",
        "        global init\n",
        "        del init\n",
        "\n",
        "def restart():\n",
        "    if IS_ENV_COLAB:\n",
        "        unmount()\n",
        "        get_ipython().kernel.do_shutdown(True)\n",
        "\n",
        "##\n",
        "\n",
        "css_html = widgets.HTML(\"\"\"\n",
        "    <style>\n",
        "        input, .progress-bar {\n",
        "            border-radius: 5px;\n",
        "        }\n",
        "        .progress-bar-info {\n",
        "            background-color: #02afc5;\n",
        "            animation: info-progress 2s infinite;\n",
        "            box-shadow: 1px 1px 6px 3px rgb(3 182 204 / 30%);\n",
        "        }\n",
        "        .progress-bar-info::before{\n",
        "            content: '';\n",
        "            border-radius: 5px;\n",
        "            background:  linear-gradient(90deg, rgba(2,175,197,0) 0%, rgb(3 211 237) 42%,rgb(3 211 237) 57%,rgba(2,175,197,0) 100%);\n",
        "            width:30%;\n",
        "            height: 100%;\n",
        "            position: absolute;\n",
        "            left: 75%;\n",
        "            animation: info-overlay 3s infinite;\n",
        "        }\n",
        "        .progress-bar-warning {\n",
        "            background: #ff9800;\n",
        "                animation: warning-progress 2s infinite;\n",
        "            box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "        } \n",
        "        .progress-bar-success {\n",
        "            box-shadow: 1px 1px 8px 2px rgb(76 175 80 / 50%) ;\n",
        "        }   \n",
        "        .widget-box, .widget-hbox, .widget-vbox, .widget-tab-content\n",
        "        {\n",
        "            border-radius: 40px !important;\n",
        "            overflow-x: hidden !important; \n",
        "            transition: .3s;\n",
        "        }\n",
        "        .p-Panel.p-TabPanel-tabContents.widget-tab-contents {\n",
        "            border-radius: 8px;\n",
        "        }\n",
        "        .jupyter-button{\n",
        "            border-radius: 6px !important;\n",
        "            transition: .4s;\n",
        "            background-color: #a9a9a93b;\n",
        "            border: 1px solid #c2c2c2a8;\n",
        "        }\n",
        "        .jupyter-button:hover:enabled, .jupyter-button:focus:enabled {\n",
        "            box-shadow: 0px 0px 5px 1px rgb(28 142 133 / 36%) !important;\n",
        "        }\n",
        "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab {\n",
        "            border-radius: 3px;\n",
        "        }   \n",
        "                                    \n",
        "        @keyframes info-progress {\n",
        "            0% {\n",
        "                background-color: #03b6cc;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "            }\n",
        "\n",
        "            50% {\n",
        "                background-color:\n",
        "                    #00bcd4db;\n",
        "                box-shadow: 1px 1px 7px 3px rgb(5 153 204 / 35%);\n",
        "            }\n",
        "\n",
        "            100% {\n",
        "                background-color: #03b6cc;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "            }\n",
        "        }\n",
        "        @keyframes warning-progress {\n",
        "            0% {\n",
        "                background-color: #ff9800;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
        "            }\n",
        "\n",
        "            50% {\n",
        "                background-color:\n",
        "                    #ff9800c9;\n",
        "                box-shadow: 1px 1px 7px 3px rgb(255 152 0 / 41%);\n",
        "            }\n",
        "\n",
        "            100% {\n",
        "                background-color: #ff9800;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
        "            }\n",
        "        }\n",
        "        @keyframes info-overlay {\n",
        "            0% {\n",
        "                left: -2%;\n",
        "                opacity: .2\n",
        "            }\n",
        "            40% {\n",
        "                opacity: .8\n",
        "            }\n",
        "\n",
        "            100%{\n",
        "                left: 75%;\n",
        "                opacity: 0.5\n",
        "            }\n",
        "        }\n",
        "    </style>\"\"\")\n",
        "\n",
        "def backthreadchecker(threadset):\n",
        "    try:\n",
        "        at = arethreadsworking(threadset)\n",
        "        while at: \n",
        "            info(f\"Active tasks: {', '.join(at)}\")\n",
        "            time.sleep(0.5)\n",
        "            at = arethreadsworking(threadset)\n",
        "            if not at:\n",
        "                info(\"Threads have finished working.\") \n",
        "                switchview(t1_vbox.maincontainer) \n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "ct = lambda: arethreadsworking(config.setupthreads)\n",
        "if arethreadsworking(config.setupthreads):\n",
        "    enable_lt_task.join()\n",
        "    scrape_watchedmovielist_task.join()\n",
        "\n",
        "makeclickjs(UICLICKER_RUN, 200, use_evaljs= True, enable_console= False) \n",
        "\n",
        "init = True\n",
        "info(\"Cell execution done.\")\n",
        "release()\n",
        "\n",
        "output.clear()\n",
        "display(main_tabs, uiclicker_btn, css_html)"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "include_colab_link": true,
      "name": "Hydraulic",
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3.9.7 64-bit",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.11"
    },
    "vscode": {
      "interpreter": {
        "hash": "c347c8f9a7ef94e4c9e03b4513be7835ed18f45b99a2a817fb579f408b867b16"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
