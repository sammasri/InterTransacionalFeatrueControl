{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "cellView": "form",
        "id": "6mYSH1yDOwvw"
      },
      "outputs": [],
      "source": [
        "\n",
        "#@title { form-width: \"2%\" }\n",
        "#@markdown \n",
        "\n",
        "import sys, os, time, re, platform, urllib, platform, unicodedata, pytz, threading, traceback\n",
        "from datetime import date, datetime\n",
        "from IPython.display import display\n",
        "import ipywidgets as widgets\n",
        "import pandas as pd\n",
        "import panel\n",
        "from bokeh.models.widgets.tables import CheckboxEditor\n",
        "panel.extension('tabulator')\n",
        "pytz.timezone('Turkey')\n",
        "\n",
        "#### Init\n",
        "\n",
        "td_id = \"TD1\"\n",
        "td_email = \"default@mail.tr\"\n",
        "tz = pytz.timezone('Turkey')\n",
        "os.environ['TZ'] = 'Turkey'\n",
        "\n",
        "env_colab = 'google.colab' in sys.modules\n",
        "if env_colab:\n",
        "    time.tzset()\n",
        "    from google.colab import output, drive, files\n",
        "\n",
        "env_os = platform.uname().system\n",
        "if env_os == 'Windows':\n",
        "    nullout =  ' > NUL' \n",
        "elif env_os == 'Linux':\n",
        "    nullout = ' > /dev/null 2>&1' \n",
        "\n",
        "log_local = '/content/td_logs'\n",
        "log_file = \"/content/td_logs/td_log.txt\"\n",
        "log_info = \"Info\"\n",
        "log_warning = \"Warning\"\n",
        "log_error = \"Error\"\n",
        "main = \"Main\"\n",
        "os.makedirs(log_local, exist_ok = True)\n",
        "\n",
        "if env_colab and os.path.exists(\"/content/sample_data\"): \n",
        "    !rm -r \"/content/sample_data\"\n",
        "\n",
        "#### Init / logging \n",
        "\n",
        "def append_lines(filename,  line = '', lines = None):\n",
        "    if lines or line:\n",
        "        with open(filename, \"a+\") as file:\n",
        "            file.seek(0)\n",
        "            data = file.read(100)\n",
        "            if len(data) > 0:\n",
        "                file.write(\"\\n\")\n",
        "\n",
        "            if line:\n",
        "                file.write(line + \"\\n\")\n",
        "\n",
        "            if lines:\n",
        "                for i in range(len(lines)):\n",
        "                    file.write(lines[i])\n",
        "                    if i < len(lines) - 1:\n",
        "                        file.write(\"\\n\")\n",
        "        return True\n",
        "    return False \n",
        "  \n",
        "class Logger: \n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def getInstance():\n",
        "        if Logger._instance == None:\n",
        "            Logger()\n",
        "        return Logger._instance\n",
        "\n",
        "    def __init__(self):\n",
        "        if Logger._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")\n",
        "        else:\n",
        "            Logger._instance = self\n",
        "\n",
        "    logs = []\n",
        "    log_drv = \"\"\n",
        "    def init(self, hold = False):\n",
        "        if hold:\n",
        "            self.logs.append(self.makelog('Log started.', log_info, main))\n",
        "        else:\n",
        "            self.log( 'Log started.', log_info,  main)\n",
        "\n",
        "    def makelog(self, text: str, log_type: str = 'Info', source: str = main) -> str:\n",
        "        now = datetime.now(tz).strftime(\"%y:%m:%d:%H:%M:%S\")\n",
        "        source = source.replace('_', ' ').title()\n",
        "        start = \"{} {:^7} {}:\". format(now, log_type, source)\n",
        "        text = text.replace(\"\\n\", f\"\\n{start} \")\n",
        "        lg = f\"{start} {text}\"\n",
        "        return lg\n",
        "\n",
        "    def queue(self, text: str, log_type: str = 'Info', source = main):\n",
        "        self.logs.append(self.makelog(text, log_type = log_type, source = source))\n",
        "\n",
        "    def info(self, text: str = \"\", lines = None, v = False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = main\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "                self.queue(line, log_info, src)\n",
        "        if text:\n",
        "            self.queue(text, log_info, src)\n",
        "\n",
        "    def warning(self, text: str = \"\", lines = None, v = False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = main\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "              self.queue(line, log_warning, src)\n",
        "        if text:\n",
        "            self.queue(text, log_warning, src)  \n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def error(self, text: str = \"\", lines = None, v = False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = main\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "                self.queue(line, log_error, src)\n",
        "        if text:\n",
        "            self.queue(text, log_error, src)\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def release(self):\n",
        "        if (self.logs):\n",
        "            if self.log(logs = self.logs):\n",
        "                self.logs.clear()\n",
        "            else:\n",
        "                print(\"Logger: An error happend while trying to write log. logs are preserved.\")\n",
        "\n",
        "    def log(self, text = '', log_type= log_info,  source = main, logs = None): \n",
        "        if not logs and not text:\n",
        "            return True\n",
        "        res = False\n",
        "        if text:\n",
        "            text = self.makelog(text, log_type, source)\n",
        "        res = append_lines(filename = log_file, line = text, lines = logs)\n",
        "\n",
        "        if res:\n",
        "            #self.save_log()\n",
        "            return True\n",
        "        else:\n",
        "            print(\"Logger: log: An error happened while trying to write log.\")\n",
        "            return False\n",
        "\n",
        "    def save_log(self):\n",
        "        if self.log_drv and os.path.exists(self.log_drv) and os.path.isfile(log_file):\n",
        "            !rsync -I \"$log_file\" \"$log_drv_file\"\n",
        "\n",
        "logger = Logger.getInstance()   \n",
        "info = logger.info\n",
        "error = logger.error\n",
        "warning = logger.warning\n",
        "release = logger.release\n",
        "\n",
        "if not os.path.isfile(log_file):\n",
        "    logger.init(True)\n",
        "    info(f\"New Session.\")\n",
        "\n",
        "#### Init / utils\n",
        "\n",
        "nowstr = lambda separete = False: datetime.now(tz).strftime(\"%y-%m-%d-%H-%M-%S\") if separete else str(round(time.time()))\n",
        "\n",
        "skip = lambda c: True if c == \"\" or c == \"s\" else False\n",
        "def ext (c):\n",
        "    c = c.lower()\n",
        "    return True if c == \" \" or c == \"q\" else False\n",
        "\n",
        "def no(c):\n",
        "    c = c.lower()\n",
        "    return True if c == \"n\" else False\n",
        "\n",
        "def getattrs(obj):\n",
        "    attrs = []\n",
        "    for attrs in dir(obj):\n",
        "        if not attrs.startswith(\"__\"):\n",
        "            attrs.append((attrs, getattr(obj, attrs)))\n",
        "    return attrs\n",
        "\n",
        "def dump(obj, padding = True, filterprefixed = True, types= set(), filtertypes= set()):\n",
        "    pad = \"              \" if padding else \"\"\n",
        "    for attrname in dir(obj):\n",
        "        attrval = getattr(obj, attrname)\n",
        "        if (filterprefixed and attrname.startswith(\"_\")):\n",
        "            continue\n",
        "        if types:\n",
        "            if type(attrval) in types:\n",
        "                print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "            continue\n",
        "        elif filtertypes:\n",
        "            if not (type(attrval) in filtertypes):\n",
        "                print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "        else:\n",
        "            print(\"%s%s =  %r\" % (pad, attrname, attrval))\n",
        "\n",
        "def getattrstr(obj, filter = True, filter_empty = False, add_line = False):\n",
        "    attrstr = ''\n",
        "    pre = '\\n' if add_line else ', '\n",
        "    i = True\n",
        "    for attrs in dir(obj):\n",
        "        if filter and attrs.startswith(\"__\"):\n",
        "            continue\n",
        "        val = getattr(obj, attrs)\n",
        "        if filter_empty and not val:\n",
        "            continue\n",
        "        if i :\n",
        "            attrstr += \"%s =  %r\" % (attrs, val)\n",
        "            i = False\n",
        "        else:\n",
        "            attrstr += \"%s%s =  %r\" % (pre, attrs, getattr(obj, attrs))\n",
        "    return attrstr\n",
        "  \n",
        "def list_lines(lines, str = False):\n",
        "    if lines:\n",
        "        if str:\n",
        "            rtn = ''\n",
        "            for r in lines:\n",
        "                if r:\n",
        "                    rtn += (r +'\\n')\n",
        "            return rtn\n",
        "        if not str:  \n",
        "            for line in lines:\n",
        "                print(line)\n",
        "\n",
        "size_limit = 40000\n",
        "def pathsize(path, string = False):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "      for path, dirs, files in os.walk(path):\n",
        "          for f in files:\n",
        "              fp = os.path.join(path, f)\n",
        "              size += os.path.getsize(fp)\n",
        "    if string:\n",
        "        return data_str(size)\n",
        "    else:\n",
        "        return size\n",
        "\n",
        "def has_size(path, only_check = True):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "        for path, dirs, files in os.walk(path):\n",
        "            for f in files:\n",
        "                fp = os.path.join(path, f)\n",
        "                size += os.path.getsize(fp)\n",
        "                if only_check and size >= size_limit:\n",
        "                    return size\n",
        "    if size >= size_limit:\n",
        "        return size\n",
        "    else:\n",
        "        return 0\n",
        "  \n",
        "def is_hidden(path):\n",
        "    return True if path[0] == '.' else False\n",
        "\n",
        "def filter_checks(dirs):\n",
        "    for dir in dirs:\n",
        "        if dir.endswith('ipynb_checkpoints'):\n",
        "            dirs.remove(dir)\n",
        "    return dirs\n",
        "\n",
        "def print_files(drs, range_start , range_end):\n",
        "    for i in range(range_start, range_end):\n",
        "        print(\"   {0}-  {1}\".format(i+1, drs[i])) \n",
        "\n",
        "def data_str(byte_val):\n",
        "    size = ByteToGB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} GB\".format(size)\n",
        "    size = ByteToMB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} MB\".format(size)\n",
        "    size = ByteToKB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} KB\".format(size)\n",
        "    return \"{:.1f} B\".format(size)\n",
        "\n",
        "def speed_str(byte_val):\n",
        "    size_mb = ByteToMB(byte_val)\n",
        "    if (size_mb >= 1):\n",
        "        return \"{:.1f} MB\".format(size_mb)\n",
        "    else:\n",
        "        return \"{:.1f} KB\".format(ByteToKB(byte_val))\n",
        "    \n",
        "def RoundTo1(n) :\n",
        "    if n < 1 and (n - 0.9765625) >= 0 :\n",
        "        return 1\n",
        "    else: \n",
        "        return n\n",
        "\n",
        "ByteToGB = lambda n: RoundTo1(n / 1073741824)\n",
        "ByteToMB = lambda n: RoundTo1(n/ 1048576)\n",
        "ByteToKB = lambda n: RoundTo1(n/ 1024)\n",
        "contains = lambda string, search: search.lower() in string.lower()\n",
        "time_str = lambda sec: time.strftime('%H:%M:%S', time.gmtime(sec))\n",
        "\n",
        "def title(s: str):\n",
        "    return titlecase(s.title()).strip()\n",
        "\n",
        "def is_empty(path):  \n",
        "    if os.path.isdir(path):\n",
        "        dircontent = os.listdir(path)\n",
        "        if len(dircontent) == 0 or (len(dircontent) == 1 and contains(checkpoint, dircontent[0])):\n",
        "            return True      \n",
        "    return False\n",
        "\n",
        "def normalizestring(input_str):\n",
        "    nfkd_form = unicodedata.normalize('NFKD', input_str)\n",
        "    return u\"\".join([c for c in nfkd_form if not unicodedata.combining(c)])\n",
        "\n",
        "#### Init / Config\n",
        "\n",
        "checkpoint = '.ipynb_checkpoints'\n",
        "savetodrive = 'Save to Google Drive'\n",
        "savetoftp = 'Save to FTP'\n",
        "\n",
        "class SystemConfig():\n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if SystemConfig._instance == None:\n",
        "            SystemConfig()\n",
        "        return SystemConfig._instance\n",
        "    def __init__(self):\n",
        "        if SystemConfig._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")            \n",
        "        else:\n",
        "            SystemConfig._instance = self\n",
        "\n",
        "    savetoftpconst = 1\n",
        "    savetogdriveconst = 2\n",
        "\n",
        "    savetoftp = True\n",
        "    savetogdrive = False\n",
        "\n",
        "    ltenabled = True\n",
        "    activedownloads = 5\n",
        "    spotifyenabled = False\n",
        "    \n",
        "    gdriveenabled = False\n",
        "    ftpenabled = True\n",
        "    backupenabled = False\n",
        "    \n",
        "    ftpuser = \"\"\n",
        "    ftppassword = \"\"\n",
        "    ftphost = \"\"\n",
        "\n",
        "    localdownloadbase = \"/content/Downloads\"\n",
        "    remotedownloadbase = \"\"\n",
        "\n",
        "    generallibrarypath = \"\"\n",
        "    musiclibrarypath = \"\"\n",
        "    movieslibrarypath = \"\"\n",
        "    tvlibrarypath = \"\"\n",
        "\n",
        "class AppState:\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if not AppState._state:\n",
        "            AppState._state = AppState()\n",
        "        return AppState._state\n",
        "    def __init__(self):\n",
        "        if AppState._state:\n",
        "            raise('AppState is singlton.')\n",
        "        AppState._state = self\n",
        "    _state = None\n",
        "    monitorthread = None\n",
        "    monitoralive= False\n",
        "    addthread = None\n",
        "    addalive = False\n",
        "    metacheckerthread = False\n",
        "    metacheckeralive= False\n",
        "    addresults = []\n",
        "\n",
        "appstate = AppState.instance()\n",
        "\n",
        "general_path = \"\"\n",
        "movies_path = \"\"\n",
        "tv_path = \"\"\n",
        "music_path = \"\"\n",
        "\n",
        "config = SystemConfig.instance()\n",
        "moviesbackups = set()\n",
        "tvbackups = set()\n",
        "musicbackups = set()\n",
        "generalbackups = set()\n",
        "uncompleted_sources = set()\n",
        "\n",
        "#### Init / Reqs\n",
        "\n",
        "def enablegdrive():\n",
        "    if env_colab and not os.path.exists(\"/content/drive\") and config.gdriveenabled:\n",
        "        drive.mount('/content/drive')\n",
        "        if os.path.exists(\"/content/drive\"):\n",
        "            info(\"Google drive is mounted.\")\n",
        "\n",
        "def installpippkg(pkg):\n",
        "    cmd = f\"pip install {pkg}\"\n",
        "    output = !$cmd\n",
        "    return True\n",
        "\n",
        "def uninstallpippkg(pkg):\n",
        "    cmd = f\"pip uninstall {pkg} -y\"\n",
        "    output = !$cmd\n",
        "    return True\n",
        "    \n",
        "def check_pip_pgks_installed(chkpkgs, installmissing = False, v= False):\n",
        "    installedpkgs = set()\n",
        "    pkgre = r'^[A-Za-z0-9\\-]+'\n",
        "    rawpkgs = !pip list\n",
        "    rawpkgs.pop(0)\n",
        "    rawpkgs.pop(0)\n",
        "    for pkg in rawpkgs:\n",
        "        mch = re.search(pkgre, pkg)\n",
        "        res = mch.group()\n",
        "        if res in chkpkgs:\n",
        "            chkpkgs.remove(res)\n",
        "            installedpkgs.add(res)\n",
        "    missings = chkpkgs-installedpkgs\n",
        "    if missings:\n",
        "        if installmissing:\n",
        "            status = True\n",
        "            for pkg in missings:\n",
        "                if v:\n",
        "                    print(f\"Installing {pkg}.\") \n",
        "                if installpippkg(pkg):\n",
        "                    if v:\n",
        "                        print(f\"{pkg} is successfully installed.\\n\")\n",
        "                else:\n",
        "                    if v:\n",
        "                        print(f\"Faild installing {pkg}.\\n\")\n",
        "                    status = False\n",
        "            return status            \n",
        "        else:    \n",
        "            msg = f'Missing packages: '\n",
        "            i = 1\n",
        "            for pkg in missings:\n",
        "                msg += f\"{pkg}.\" if i == len(missings) else f\"{pkg}, \"\n",
        "                i+=1\n",
        "            print(msg)\n",
        "            return missings\n",
        "    else:\n",
        "        return True\n",
        "\n",
        "def setupreqs(v= False):\n",
        "    if v:\n",
        "        print('Installing requirments')\n",
        "    info('Installing requirments')\n",
        "    reqs = set()\n",
        "    reqs.add('titlecase')\n",
        "    reqs.add('requests')\n",
        "    reqs.add('beautifulsoup4')\n",
        "    if config.ftpenabled:\n",
        "        reqs.add('ftputil')\n",
        "        if env_colab:\n",
        "            !sudo apt-get install lftp $nullout \n",
        "    if config.spotifyenabled:\n",
        "        reqs.add('savify')\n",
        "\n",
        "    if config.ltenabled:\n",
        "        reqs.add('libtorrent')\n",
        "    check_pip_pgks_installed(reqs, True)\n",
        "    global requests, BeautifulSoup, titlecase\n",
        "    import requests\n",
        "    from bs4 import BeautifulSoup\n",
        "    from titlecase import titlecase \n",
        "    if config.ftpenabled:\n",
        "        global ftputil\n",
        "        import ftputil \n",
        "    if config.ltenabled:\n",
        "        global lt\n",
        "        import libtorrent as lt\n",
        "\n",
        "#### Init / Pathes\n",
        "\n",
        "def setuppathes():\n",
        "    global general_path, movies_path, tv_path, music_path\n",
        "    if os.path.exists(\"/content/drive\"):\n",
        "        if general_path:\n",
        "            if not os.path.exists(general_path):\n",
        "                os.makedirs(general_path)     \n",
        "            info(f\"General saving path: {general_path}\")\n",
        "        else:\n",
        "            error(f\"General saving path isn't set.\")\n",
        "\n",
        "        if movies_path:\n",
        "            if not os.path.exists(movies_path):\n",
        "                os.makedirs(movies_path)   \n",
        "            info(f\"Movies saving path: {movies_path}\")\n",
        "        else:\n",
        "            error(f\"Movies saving path isn't set.\")\n",
        "\n",
        "        if tv_path:\n",
        "            if not os.path.exists(tv_path):\n",
        "                os.makedirs(tv_path)    \n",
        "            info(f\"TV saving path: {tv_path}\")\n",
        "        else:\n",
        "            error(f\"TV saving path isn't set\")\n",
        "\n",
        "        if music_path:\n",
        "            if not os.path.exists(music_path):\n",
        "                os.makedirs(music_path)  \n",
        "            info(f\"Music saving path: {music_path}\")\n",
        "        else:\n",
        "            error(f\"Music saving path isn't set\")\n",
        "    else:\n",
        "        general_path = f\"{config.localdownloadbase}/Downloads\"\n",
        "        movies_path = f\"{config.localdownloadbase}/Movies\"\n",
        "        tv_path = f\"{config.localdownloadbase}/TV Shows\"\n",
        "        music_path = f\"{config.localdownloadbase}/Music\"\n",
        "        os.makedirs(general_path, exist_ok = True)\n",
        "        os.makedirs(movies_path, exist_ok = True)\n",
        "        os.makedirs(tv_path, exist_ok = True)\n",
        "        os.makedirs(music_path, exist_ok = True)\n",
        "        info(f\"Downloads base is set to: {config.localdownloadbase}\")\n",
        " \n",
        "def checkuncompletesources():\n",
        "    info(f\"Checking uncomplete downloads sources in: {general_path}/.uncomplete\")\n",
        "    p0 = general_path + \"/\" + \".uncomplete\"\n",
        "    if os.path.exists(p0):\n",
        "        if is_empty(p0):\n",
        "            !rm -r \"$p0\"\n",
        "        else:\n",
        "            info(f\"Adding uncomplete downloads sources: {p0}\")\n",
        "            uncompleted_sources.append(p0)\n",
        "\n",
        "done_path = \"/content/done\"\n",
        "temp_save=\"/content/d-0\" \n",
        "added_path = \"/content/added\"\n",
        "os.makedirs(done_path, exist_ok = True)\n",
        "os.makedirs(temp_save, exist_ok = True)\n",
        "os.makedirs(added_path, exist_ok = True)  \n",
        "path_movie = lambda mv: movies_path + \"/\" + mv\n",
        "path_tvshow = lambda tvshow: tv_path + \"/\" + tvshow\n",
        "path_season = lambda tvshow, season: tv_path + \"/\" + tvshow + \"/\" + season\n",
        "path_episode = lambda tvshow, season, eps: tv_path + \"/\" + tvshow + \"/\" + season + \"/\" + eps\n",
        "joinpath = lambda start, dir: start + \"/\" + dir \n",
        "\n",
        "def getsdbackup(path: str, bakid = \"\", bak_index = 0): #fix backup\n",
        "    return\n",
        "\n",
        "#### API / Consts\n",
        "\n",
        "skip_list = ['.txt','.inf','.info','.nfo','www.yts','rarbg_do_not']\n",
        "this_year = date.today().year\n",
        "\n",
        "General = 101\n",
        "Software = 102\n",
        "Games = 103\n",
        "\n",
        "Movie = 201\n",
        "TV = 300\n",
        "\n",
        "Show = 301\n",
        "Season = 302\n",
        "Episode = 303\n",
        "\n",
        "Music = 401\n",
        "Album = 402\n",
        "Track = 403\n",
        "\n",
        "l337x = '1337x'\n",
        "rarbg = 'rarbg'\n",
        "\n",
        "allcategories = ''\n",
        "moviescategory = \"Movies\"\n",
        "tvcategory = \"TV\"\n",
        "appscategory = \"Apps\"\n",
        "gamescategory = \"Games\"\n",
        "\n",
        "seederssort = \"By Seeders\"\n",
        "timesort = \"By Time\"\n",
        "sizesort = \"By Size\"\n",
        "ascorder = \"Ascending\"\n",
        "descorder = \"Descending\"\n",
        "\n",
        "hash_addsource = \"download hash\"\n",
        "localfile_addsource = \"local file\"\n",
        "upload_addsource = \"uploaded file\"\n",
        "magnet_addsource = \"magnet\"\n",
        "fileurl_addsource = \"file url\"\n",
        "\n",
        "l337x_tv = \"TV\"\n",
        "l337x_movies = \"Movies\"\n",
        "l337x_apps = \"Apps\"\n",
        "l337x_games = \"Games\"\n",
        "\n",
        "l337x_seeders = \"seeders/desc\"\n",
        "l337x_size_asc = \"size/asc\"\n",
        "l337x_size_desc = \"size/desc\"\n",
        "l337x_time_asc = \"time/asc\"\n",
        "l337x_time_desc = \"time/desc\"\n",
        "\n",
        "rarbg_movie_xvid = 14\n",
        "rarbg_movie_xvid_720p = 48\n",
        "rarbg_movie_h264 = 17\n",
        "rarbg_movie_h264_720p = 45\n",
        "rarbg_movie_h264_1080p = 44\n",
        "rarbg_movie_h264_3d = 47\n",
        "rarbg_movie_h265_1080p = 54\n",
        "rarbg_movie_h264_4k = 50\n",
        "rarbg_movie_h265_4k = 51\n",
        "rarbg_movie_h265_4k_hdr = 52\n",
        "rarbg_movie_h265 = [rarbg_movie_h265_1080p, rarbg_movie_h265_4k,  rarbg_movie_h265_4k_hdr]\n",
        "rarbg_movie_full_bd = 42\n",
        "rarbg_movie_bd_remux = 46\n",
        "rarbg_tv_episodes = 18\n",
        "rarbg_tv_episodes_hd = 41\n",
        "rarbg_tv_episodes_uhd = 49\n",
        "rarbg_music_mp3 = 23\n",
        "rarbg_music_flac = 25\n",
        "rarbg_games_pc_iso = 27\n",
        "rarbg_games_pc_rip = 28\n",
        "rarbg_games_ps3 = 40\n",
        "rarbg_games_ps4 = 53\n",
        "rarbg_games_xbox = 32\n",
        "rarbg_software = 33\n",
        "rarbg_ebook = 35\n",
        "\n",
        "rarbg_movie= [rarbg_movie_h264] + rarbg_movie_h265\n",
        "rarbg_tv= [rarbg_tv_episodes, rarbg_tv_episodes_hd, rarbg_tv_episodes_uhd]\n",
        "\n",
        "sortrarbg_seeders = 'seeders'\n",
        "sortrarbg_time = 'last'\n",
        "\n",
        "sort1337x_seeders_asc = \"seeders_asc\"\n",
        "sort1337x_seeders_desc = \"seeders_desc\"\n",
        "sort1337x_time_asc = \"time_asc\"\n",
        "sort1337x_time_desc = \"time_desc\"\n",
        "sort1337x_size_asc = \"size_asc\"\n",
        "sort1337x_size_desc = \"size_desc\"\n",
        "\n",
        "new_trackers = [\"udp://tracker.opentrackr.org:1337/announce\", \"udp://tracker.internetwarriors.net:1337/announce\", \"udp://exodus.desync.com:6969/announce\", \"udp://tracker.cyberia.is:6969/announce\", \"udp://3rt.tace.ru:60889/announce\", \"http://5rt.tace.ru:60889/announce\", \"udp://explodie.org:6969/announce\", \"udp://47.ip-51-68-199.eu:6969/announce\", \"udp://opentracker.i2p.rocks:6969/announce\", \"http://open.acgnxtracker.com:80/announce\", \"udp://www.torrent.eu.org:451/announce\", \"udp://tracker.torrent.eu.org:451/announce\", \"udp://tracker.tiny-vps.com:6969/announce\", \"udp://tracker.ds.is:6969/announce\", \"udp://retracker.lanta-net.ru:2710/announce\", \"udp://open.stealth.si:80/announce\", \"udp://tracker.moeking.me:6969/announce\", \"udp://ipv4.tracker.harry.lu:80/announce\", \"http://tracker.dler.org:6969/announce\", \"http://rt.tace.ru:80/announce\", \"udp://93.158.213.92:1337/announce\", \"udp://138.255.103.83:1337/announce\", \"udp://208.83.20.20:6969/announce\", \"udp://193.218.118.220:6969/announce\", \"udp://79.111.118.59:60889/announce\", \"http://93.157.234.32:60889/announce\", \"udp://184.105.151.164:6969/announce\", \"udp://51.68.199.47:6969/announce\", \"udp://51.81.46.170:6969/announce\", \"udp://91.216.110.52:451/announce\", \"udp://89.234.156.205:451/announce\", \"udp://5.206.60.196:6969/announce\", \"udp://5.226.148.20:6969/announce\", \"udp://37.235.174.46:2710/announce\", \"udp://185.181.60.67:80/announce\", \"udp://138.201.150.56:6969/announce\", \"udp://51.15.40.114:80/announce\", \"http://168.119.237.9:6969/announce\", \"http://195.201.31.194:80/announce\", \"https://trakx.herokuapp.com:443/announce\", \"https://w.wwwww.wtf:443/announce\", \"https://tracker.tamersunion.org:443/announce\", \"https://tracker.sloppyta.co:443/announce\", \"https://tracker.renfei.net:443/announce\", \"https://tracker.nitrix.me:443/announce\",\n",
        "              \"https://tracker.nanoha.org:443/announce\", \"https://tracker.lelux.fi:443/announce\", \"https://tracker.imgoingto.icu:443/announce\", \"https://tracker.hama3.net:443/announce\", \"https://tracker.foreverpirates.co:443/announce\", \"http://tracker2.wasabii.com.tw:6969/announce\", \"udp://tracker.sktorrent.net:6969/announce\", \"http://www.wareztorrent.com:80/announce\", \"udp://bt.xxx-tracker.com:2710/announce\", \"udp://tracker.eddie4.nl:6969/announce\", \"udp://tracker.grepler.com:6969/announce\", \"udp://tracker.mg64.net:2710/announce\", \"udp://wambo.club:1337/announce\", \"udp://tracker.dutchtracking.com:6969/announce\", \"udp://tc.animereactor.ru:8082/announce\", \"udp://tracker.justseed.it:1337/announce\", \"udp://tracker.leechers-paradise.org:6969/announce\", \"https://open.kickasstracker.com:443/announce\", \"udp://tracker.coppersurfer.tk:6969/announce\", \"http://87.253.152.137/announce\", \"http://91.216.110.47/announce\", \"http://91.217.91.21:3218/announce\", \"http://91.218.230.81:6969/announce\", \"http://93.92.64.5/announce\", \"http://atrack.pow7.com/announce\", \"http://bt.henbt.com:2710/announce\", \"http://bt.pusacg.org:8080/announce\", \"https://tracker.bt-hash.com:443/announce\", \"udp://tracker.leechers-paradise.org:6969\", \"https://182.176.139.129:6969/announce\", \"udp://zephir.monocul.us:6969/announce\", \"https://tracker.dutchtracking.com:80/announce\", \"https://grifon.info:80/announce\", \"udp://tracker.kicks-ass.net:80/announce\", \"udp://p4p.arenabg.com:1337/announce\", \"udp://tracker.aletorrenty.pl:2710/announce\", \"https://tracker.parrotsec.org:443/announce\", \"https://tracker.moxing.party:6969/announce\", \"https://tracker.ipv6tracker.ru:80/announce\", \"https://tracker.fastdownload.xyz:443/announce\", \"https://gwp2-v19.rinet.ru:80/announce\", \"https://tr.kxmp.cf:80/announce\", \"https://explodie.org:6969/announce\"]\n",
        "\n",
        "types = {General:  \"General\",\n",
        "        Software:  \"Software\",\n",
        "        Games:  \"Games\",\n",
        "        Movie:  \"Movie\",\n",
        "        Show:  \"Show\",\n",
        "        Season:  \"Season\",\n",
        "        Episode:  \"Episode\",\n",
        "        Music : \"Music\",\n",
        "        Album : \"Album\",\n",
        "        Track : \"Track\"     \n",
        "}\n",
        "\n",
        "#### API / abstraction \n",
        "\n",
        "url_re = r\"^((http[s]?):\\/\\/)?([^:\\/\\s]+)((\\/\\w+\\/)*\\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?\"\n",
        "sm_re = r\"(?<=Shareddrives\\/)[A-Z]*(?=\\/)\"\n",
        "season_re0 = r\"\\b([S,s]|[S,s]eason([\\s,\\.]?))\\d{1,2}\"\n",
        "featurettes_re = r\"[F,f]eature[a-z]*|[E,e]xtras?\"\n",
        "mf_re = r\"((?<=\\b[S,s])|(?<=[S,s]eason)|(?<=[S,s]eason[\\s,\\.]))([1-9][0-9]?|0?[1-9])\"                       \n",
        "sn2num = r\"[1-9][0-9]?(?=[Xx]\\d{1,2}\\b)\"\n",
        "eps_re = r\"\\b([Ss]\\d{1,2}[Ee]\\d{1,2}|\\d{1,2}[xX]\\d{1,2}|[Ss]n?\\d{1,2}\\s?[Ee](ps?)?\\d{1,2})(?=[\\s\\.])\"\n",
        "check_sn_re = r\"[\\s,\\.]([S,s]\\d{1,2}|[Ss][Ee][Aa][Ss][Oo][Nn]([\\s,\\.]?)\\d{1,2})(?=[\\s,\\.]|e\\d{1,2}-\\d{1,2})(?!\\sto)\"\n",
        "eps2num_re = r\"(?<=\\d{1}[Xx])\\d{1,2}\\b\"\n",
        "year_re = r\"\\d{4}\" \n",
        "re_suf = r\"\\s\\d{1,2}$\"\n",
        "sn_in = r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\"\n",
        "sn_nm = r\"([1-9][0-9]?)\"\n",
        "skip_re = r\"(.txt)|(.i?nfo?)|(www.yts)|(RARBG_DO_NOT|rarbg_do_not)\"\n",
        "del_re = r\"\\.del\\d*\\/\"\n",
        "sd_re = r\"(\\/content\\/drive\\/Shareddrives\\/)[A-Za-z0-9]+(?=\\/)\"\n",
        "\n",
        "class DownloadAttrs:\n",
        "    def __init__(this, type_ = General, replace = False, backup = True, save_name = \"\", category = \"\", sequential= False, \n",
        "        uncomplete_source = \"\", imdb_name = \"\", imdb_rating = \"\", imdb_votes = \"\", partial = False, name= ''):\n",
        "        this.type_ = type_ \n",
        "        this.replace =  replace\n",
        "        this.backup =  backup\n",
        "        this.category =  category\n",
        "        this.save_name =  save_name\n",
        "        this.sequential = sequential \n",
        "        this.uncomplete_source  =  uncomplete_source\n",
        "        this.imdb_name =  imdb_name\n",
        "        this.imdb_rating =  imdb_rating\n",
        "        this.imdb_votes =  imdb_votes\n",
        "        this.partial = partial\n",
        "        this.name = name\n",
        "\n",
        "    artist = \"\"\n",
        "    album = \"\"\n",
        "    track = \"\"\n",
        "    partial = False\n",
        "    backup = False\n",
        "    completed = False\n",
        "    replace = False\n",
        "    name = \"\"\n",
        "    hash = ''\n",
        "    save_name = \"\"\n",
        "    save_path = \"\"\n",
        "    save_dir = \"\"\n",
        "    imdb_name = \"\"\n",
        "    type_ = General\n",
        "    save_type = 0\n",
        "    sequential = False\n",
        "    download_size = 0\n",
        "    allfiles = 0\n",
        "    selectedfiles = 0\n",
        "    files = None\n",
        "    uncomplete_source = \"\"\n",
        "    show = \"\"\n",
        "    season = \"\"\n",
        "    existing_dir = \"\"\n",
        "    existing_path = \"\"\n",
        "    existing_file = \"\"\n",
        "    baksv = None\n",
        "    year = 0\n",
        "    imdb_rating = \"\"\n",
        "    imdb_votes = \"\"\n",
        "    quality = \"1080\"\n",
        "    category = \"\"\n",
        "    site_source = \"\"\n",
        "    uploader = \"\"\n",
        "    format = \"\"\n",
        "    duration = \"\"\n",
        "    video_width = \"\"\n",
        "    video_height = \"\"\n",
        "    frame_rate = \"\"\n",
        "    bit_rate = \"\"\n",
        "    color_bit_depth = \"\"\n",
        "    video_bit_rate = \"\"\n",
        "    audio_tracks = None\n",
        "    magnet = \"\"\n",
        "    downloaded = None\n",
        "    total_downloaded = 0\n",
        "    verify_download = None\n",
        "    old_files = None\n",
        "    hasmetadata = False\n",
        "\n",
        "    def copy(this):\n",
        "        return DownloadAttrs(type_= this.type_,\n",
        "                    replace= this.replace,\n",
        "                    backup= this.backup,\n",
        "                    category= this.category,\n",
        "                    sequential= this.sequential,\n",
        "                    uncomplete_source= this.uncomplete_source,\n",
        "                    imdb_name= this.imdb_name,\n",
        "                    imdb_rating= this.imdb_rating,\n",
        "                    imdb_votes= this.imdb_votes)\n",
        "\n",
        "class DownloadFile():\n",
        "    def __init__(self, index, name, size, selected = True):\n",
        "        self.index = index\n",
        "        self.name = name\n",
        "        self.size = size\n",
        "    index = 0\n",
        "    name = \"\"\n",
        "    size = 0\n",
        "    selected = True\n",
        "        \n",
        "class imdb_params:\n",
        "    def __init__(self, keyword, title_type, s_year, e_year, ratings, min_votes, max_run, lists, labels, imdb_sort, \n",
        "        filter_watched: bool, filter_downloaded, l337x_download, rarbg_download, site_category, download_params, sort, rarbg_auto):\n",
        "        self.keyword = keyword\n",
        "        self.title_type = title_type\n",
        "        self.s_year = s_year\n",
        "        self.e_year = e_year\n",
        "        self.ratings = ratings\n",
        "        self.min_votes = min_votes\n",
        "        self.max_run = max_run\n",
        "        self.lists = lists\n",
        "        self.labels = labels\n",
        "        self.imdb_sort = imdb_sort\n",
        "        self.filter_watched = filter_watched\n",
        "        self.filter_downloaded = filter_downloaded\n",
        "        self.l337x_download = l337x_download\n",
        "        self.rarbg_download = rarbg_download\n",
        "        self.site_category = site_category\n",
        "        self.download_params = download_params\n",
        "        self.sort = sort\n",
        "        self.rarbg_auto = rarbg_auto\n",
        "\n",
        "    keyword = \"\"\n",
        "    title_type = \"\"\n",
        "    s_year = \"\"\n",
        "    e_year = \"\"\n",
        "    ratings = \"\"\n",
        "    min_votes = \"\"\n",
        "    max_run = \"\"\n",
        "    lists = \"\"\n",
        "    labels = \"\"\n",
        "    imdb_sort = \"\"\n",
        "    filter_watched = False\n",
        "    filter_downloaded = False\n",
        "    l337x_download = False\n",
        "    rarbg_download = False\n",
        "    site_category = \"\"\n",
        "    download_params = \"\"\n",
        "    sort = sort1337x_seeders_desc\n",
        "    rarbg_auto = True\n",
        "\n",
        "class imdb_result:\n",
        "    def __init__(self, title, runtime, genres, rating, votes, director, staring):\n",
        "        self.title = title\n",
        "        self.runtime = runtime\n",
        "        self.rating = rating\n",
        "        self.votes = votes\n",
        "        self.director = director\n",
        "        self.staring = staring\n",
        "        self.genres = genres\n",
        "\n",
        "class web_result:\n",
        "    def __init__(this, title, size = 0, date = \"\", seeders = \"\", leechers = \"\", uploader = \"\", href = \"\", download_state = \"\" , magnet = \"\"):\n",
        "        this.title = title\n",
        "        this.size = size\n",
        "        this.date = date \n",
        "        this.seeders = seeders\n",
        "        this.leechers = leechers\n",
        "        this.uploader = uploader\n",
        "        this.href = href\n",
        "        this.download_state = download_state\n",
        "    title: str\n",
        "    size = 0\n",
        "    magnet = date = seeders = leechers = uploader = href = download_state = \"\" \n",
        "\n",
        "#### API / Download library management\n",
        "\n",
        "def get_year(name): \n",
        "    dgts = re.findall(year_re, name.split('1080')[0])\n",
        "    if dgts: \n",
        "        return dgts[-1]\n",
        "    else:\n",
        "        return this_year\n",
        "\n",
        "def get_season(name, allow_year = True):\n",
        "    info(f'Retrieving season from: {name}')\n",
        "    lookup = re.search(mf_re, name)\n",
        "    if lookup:\n",
        "        sn = lookup.group()\n",
        "        sn = 'S' + sn if len(sn) != 1 else 'S0' + sn\n",
        "        info(f'Found season: {sn}')\n",
        "        return sn\n",
        "\n",
        "    lookup = re.search(featurettes_re, name)\n",
        "    if lookup:\n",
        "        ft = lookup.group()\n",
        "        info(f'Extra folder: {ft}')\n",
        "        return \"Extras\"\n",
        "\n",
        "    if allow_year:\n",
        "        sn = get_year(name)  \n",
        "        info(f'Season retrieved as a year: {sn}')\n",
        "        return sn\n",
        "    else:\n",
        "        info(f'No season was retrieved.')\n",
        "        return ''\n",
        "\n",
        "def transstring(name): \n",
        "    if not name:\n",
        "        error('String is empty.')\n",
        "        raise Exception('String is empty.')\n",
        "    table = name.maketrans(\"\",\"\",\" ,.;:!?'&#$%`!@^*_-/\\\\|'\\\"<>())[]{}\")\n",
        "    return name.translate(table).lower()\n",
        "\n",
        "def transtitle(name, show = False): \n",
        "    if not name:\n",
        "        error('Name is empty.')\n",
        "        raise Exception('Trans title,name is empty.')\n",
        "    name = name.replace(\"&\",\"and\")\n",
        "    dgts = re.findall(year_re, name)\n",
        "    year = \"\"\n",
        "    if dgts: \n",
        "        if len(dgts) == 1 :\n",
        "            name = name.split(dgts[0])[0]\n",
        "            year = dgts[0]\n",
        "        else:\n",
        "            name.split(dgts[-1])[0]\n",
        "            year = dgts[-1]\n",
        "    table = name.maketrans(\"\",\"\",\" '(#$%-,.;:!?)\")\n",
        "    return name.translate(table).lower()+year if not show else name.translate(table).lower()\n",
        "\n",
        "def name_movie(name, quality = \"1080\"): \n",
        "    name = name.split(quality)[0]\n",
        "    table = name.maketrans(\".\",\" \",\"()\")\n",
        "    trans = name.translate(table)\n",
        "    dgts = re.findall(year_re, trans)\n",
        "    if dgts and len(dgts) >= 1:\n",
        "         return f\"{trans.split(dgts[-1])[0].strip()} {dgts[-1]}\"\n",
        "    else:\n",
        "        return trans.strip()\n",
        "\n",
        "def name_show(name, quality = \"1080\"): \n",
        "    name = name.split(quality)[0]\n",
        "    table = name.maketrans(\".\",\" \",\"'()\")\n",
        "    trans = name.translate(table)\n",
        "    search = re.search(year_re, trans)\n",
        "    if search: \n",
        "        year = search.group()\n",
        "        return f\"{trans.split(year)[0].strip()} {year}\"\n",
        "    search = re.search(season_re0, trans)\n",
        "    if search: \n",
        "        return trans.split(search.group())[0].strip()\n",
        "    else: \n",
        "        return trans\n",
        "\n",
        "def name_episode(name, quality = \"1080\", keepDot = False):\n",
        "    if quality in name:\n",
        "        name = name.split(\"1080\")[0]\n",
        "    elif \"720p\" in name:\n",
        "        name = name.split(\"720p\")[0]\n",
        "    if keepDot: \n",
        "        r = s = \"\"\n",
        "    else:\n",
        "        r =\".\"\n",
        "        s = \" \"\n",
        "    table = name.maketrans(r, s, \"()\")\n",
        "    name = name.translate(table)\n",
        "    if name[-1] == \".\":\n",
        "        name = name[:-1]\n",
        "    return title(name)\n",
        "\n",
        "def movie_exists(name):\n",
        "    if not name.strip():\n",
        "        error('Movie name is empty')\n",
        "        return           \n",
        "    info(f\"Checking if the movie {name} is downloaded.\")\n",
        "    movies_raw = filter_checks(next(os.walk(movies_path))[1])\n",
        "    name_s = transtitle(name)\n",
        "    for i in range(len(movies_raw)):\n",
        "        path = path_movie(movies_raw[i])\n",
        "        if name_s == transtitle(movies_raw[i]):\n",
        "            info(f\"{name} is downloaded as {movies_raw[i]}\")\n",
        "            return (movies_raw[i], path_movie(movies_raw[i]))\n",
        "    info(f\"{name} is not downloaded\")\n",
        "    return False\n",
        "\n",
        "def show_exists(name: str):\n",
        "    if not name.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "    info(f\"Checking if the show {name} is downloaded\")\n",
        "    shows_raw = filter_checks(next(os.walk(tv_path))[1])\n",
        "    name_trans = transtitle(name, True)\n",
        "    for i in range(len(shows_raw)):\n",
        "        path = path_tvshow(shows_raw[i])\n",
        "        trans1 = transtitle(shows_raw[i], True)\n",
        "        if contains(trans1, name_trans) and not is_empty(path):\n",
        "            info(f\"{name} is downloaded as {shows_raw[i]}\")\n",
        "            return (shows_raw[i], path)\n",
        "    info(f\"{name} is not downloaded\")\n",
        "    return False\n",
        "\n",
        "def season_exists(show, season):\n",
        "    if not season.strip():\n",
        "        error('Season name is empty')\n",
        "        return\n",
        "\n",
        "    if not show.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "\n",
        "    info(f\"Checking if the season {season} of {show} is downloaded\")\n",
        "    search = show_exists(show)\n",
        "    path = \"\"\n",
        "    if search:\n",
        "        show = search[0]\n",
        "        p0 = path_tvshow(show) + \"/\" + season\n",
        "        if os.path.exists(p0) and not is_empty(p0):\n",
        "            info(f\"Season {season} of {show} is downloaded\")\n",
        "            path = p0\n",
        "    info(f\"Season {season} of {show} is not downloaded\")\n",
        "    return (show, path)\n",
        "\n",
        "def episode_exists(show, season, name): \n",
        "    info(f\"Checking if the episode: {name} is downloaded\")\n",
        "    search = show_exists(show)\n",
        "    episode = \"\"\n",
        "    path= \"\"\n",
        "    if search:\n",
        "        show = search[0]\n",
        "        checkpath = path_season(show, season)\n",
        "        if os.path.exists(checkpath) and not is_empty(checkpath):\n",
        "            check = re.search(eps_re, name)\n",
        "            eps = check.group() if check else name\n",
        "            epses = next(os.walk(checkpath))[2]\n",
        "            for e in epses:\n",
        "                splt = os.path.splitext(e)\n",
        "                if splt[1] == \".mp4\" or splt[1] == \".mkv\": \n",
        "                    if contains(splt[0], eps):\n",
        "                        episode = e\n",
        "                        info(f\"Episode: {name} is downloaded as {e}\")\n",
        "                        path = path_episode(show, season, e)\n",
        "                        break\n",
        "    if not episode:\n",
        "        info(f\"Episode: {name} is not downloaded.\")\n",
        "    return (episode, show, path)\n",
        "\n",
        "def movie_file(path, name):\n",
        "    if path and os.path.exists(path):\n",
        "        files = next(os.walk(path))[2]\n",
        "        for file in files:\n",
        "            splt = os.path.splitext(file)\n",
        "            ext = splt[1]\n",
        "            title: str = splt[0].lower()\n",
        "            if (ext == \".mp4\" or ext == \".mkv\" or ext == \".av\" or ext == \".ts\") and name.lower().startswith(title):\n",
        "                return path + \"/\" + file\n",
        "    return \"\"\n",
        "\n",
        "def find_title(title_raw, year_raw):\n",
        "    year = re.search(year_re, year_raw)\n",
        "    year = year.group() if year else \"\"\n",
        "    title = \"{0} {1}\".format(title_raw, year)\n",
        "    table = title.maketrans(\"/\",\" \",\":'(,?)\")\n",
        "    title = title.translate(table)\n",
        "    return normalizestring(title.replace(\"&\", \"and\"))\n",
        "\n",
        "def rename_title(newname):\n",
        "    print(f\"Renaming: {newname}\\nEnter title name for search or proceed:\")\n",
        "    inp = input().lower()\n",
        "    if inp:\n",
        "        words = inp.split()\n",
        "    else:\n",
        "        words: list[str] = newname.split()\n",
        "    check1 = \" \".join(words[:2])\n",
        "    check2 = len(words[0]) > 3\n",
        "    movies = filter_checks(next(os.walk(movies_path))[1])\n",
        "    res = []\n",
        "\n",
        "    for mv in movies:\n",
        "        if mv.startswith(check1) or (check2 and mv.startswith(words[0])) or any(not check3.isdigit() and len(check3) > 3 and contains(mv, check3) for check3  in words):\n",
        "            res.append(mv)\n",
        "    if len(res) == 1:\n",
        "        title = res[0]\n",
        "    elif res:\n",
        "        res.sort()\n",
        "        i = 0\n",
        "        for mv in res:\n",
        "            i += 1\n",
        "            print(f\"{i} {mv}\")       \n",
        "        print(\"\\nChoose a title to rename:\\n\")\n",
        "        c = input()\n",
        "        if c == \"\" or c == \" \" or c == \"q\" or c == \"s\":\n",
        "            print(\"No title was renamed.\\n\")\n",
        "            return\n",
        "        else:\n",
        "            try:\n",
        "                title = res[int(c)-1]\n",
        "            except Exception as e:\n",
        "                print(e)\n",
        "                return\n",
        "    else:\n",
        "        print(\"No title was renamed.\\n\")\n",
        "        return\n",
        "\n",
        "    print(f\"Renaming: {title} to {newname} Confirm?\")\n",
        "    if input() != \"n\":\n",
        "        p0 = movies_path + \"/\" + title\n",
        "        p1 = movies_path + \"/\" + newname\n",
        "        print(f\"Renaming: {p0}\")\n",
        "        !mv \"$p0\" \"$p1\"\n",
        "\n",
        "        for p3 in moviesbackups:\n",
        "            p0 = joinpath(p3, title)\n",
        "            if os.path.exists(p0):\n",
        "                p1 = joinpath(p3, newname) \n",
        "                print(f\"Renaming backup: {p0}\")\n",
        "                !mv \"$p0\" \"$p1\"\n",
        "\n",
        "        print(\".....Rename done......\")\n",
        "    else:\n",
        "        print(\"No title was renamed.\\n\")\n",
        "\n",
        "def replace_download(path):\n",
        "    if path and os.path.exists(path):\n",
        "        parent = os.path.dirname(path)\n",
        "        rp = parent + \"/\" + \".replace\"\n",
        "        os.makedirs(rp, exist_ok=True)\n",
        "        !mv \"$path\" \"$rp\"\n",
        "\n",
        "def get_tv_type(attrs: DownloadAttrs):\n",
        "    search = re.search(eps_re, attrs.name)\n",
        "    if search:\n",
        "        return Episode\n",
        "    search = re.search(check_sn_re, attrs.name)\n",
        "    if search:\n",
        "        return Season  \n",
        "\n",
        "split_title_re = r\"[\\[\\]\\(]\"\n",
        "\n",
        "def music_title(name: str):\n",
        "    search = re.search(split_title_re, name)\n",
        "    if search:\n",
        "        name = name.split(search.group())[0]\n",
        "    splt = name.split(\"-\")\n",
        "    if splt:\n",
        "        artist = splt[0].strip() \n",
        "        name = splt[1].strip()\n",
        "        title = f\"{artist} - {name}\"\n",
        "    else:\n",
        "        artist = \"\"\n",
        "        name = title = name.strip()\n",
        "    return (artist, name, title)\n",
        "\n",
        "def prepare_download(attrs: DownloadAttrs):\n",
        "    info(f\"Preparing {types[attrs.type_]} download info for: {attrs.name}\")\n",
        "    Type = attrs.type_\n",
        "    if Type == Movie:\n",
        "        newname = name_movie(attrs.name, attrs.quality)\n",
        "        search = movie_exists(newname)\n",
        "        if search:\n",
        "            path = search[1]\n",
        "            if not attrs.replace:\n",
        "                size = pathsize(path, True)\n",
        "                message = f\"The movie {search[0]} is already downloaded. Size: {size}.\"\n",
        "                warning(message) #add to output window\n",
        "                print(f\"Warning: {message} Do you want to overwrite?\")\n",
        "                if input() == \"n\": # get user input from gui\n",
        "                    return False\n",
        "            attrs.replace = True\n",
        "            attrs.existing_dir = search[0]\n",
        "            attrs.existing_path = path\n",
        "            attrs.existing_file = movie_file(path, search[0])\n",
        "            if attrs.replace or not attrs.save_name:\n",
        "                attrs.save_name = search[0]\n",
        "        if not attrs.save_name:\n",
        "            attrs.save_name = newname\n",
        "        attrs.save_path = movies_path\n",
        "        if attrs.backup:\n",
        "            attrs.baksv = moviesbackups\n",
        "\n",
        "    elif Type == Show:\n",
        "        newname = name_show(attrs.name, attrs.quality)\n",
        "        search = show_exists(newname)\n",
        "        if search:\n",
        "            path = search[1]\n",
        "            if not attrs.replace:\n",
        "                message = f\"The show {search[0]} is already downloaded.\"\n",
        "                warning(message)\n",
        "                print( #add to output window\n",
        "                    f\"Warning: Prepare Download: The show {search[0]} is already downloaded. Do you want to overwrite?\")\n",
        "                if input() == \"n\":\n",
        "                    return False\n",
        "            attrs.replace = True\n",
        "            attrs.existing_dir = search[0]\n",
        "            attrs.existing_path = path\n",
        "            if attrs.replace or not attrs.save_name:\n",
        "                attrs.save_name = search[0]\n",
        "\n",
        "        if not attrs.save_name:\n",
        "            attrs.save_name = newname\n",
        "        attrs.save_path = tv_path\n",
        "        attrs.show = attrs.save_name\n",
        "        if attrs.backup:\n",
        "            attrs.baksv = tvbackups\n",
        "\n",
        "    elif Type == Season:\n",
        "        newname = get_season(attrs.name)\n",
        "        show = name_show(attrs.name, attrs.quality)\n",
        "        search = season_exists(show, newname)\n",
        "        if search:\n",
        "            show = search[0]\n",
        "            if search[1]:\n",
        "                path = search[1]\n",
        "                if not attrs.replace:\n",
        "                    size = pathsize(path, True)\n",
        "                    message = f\"{show} {newname} is already downloaded. Size: {size}.\"\n",
        "                    warning(message)\n",
        "                    print( #add to output window\n",
        "                        f\"Warning: Prepare Download: {show} {newname} is already downloaded. Size: {size}. Do you want to overwrite?\")\n",
        "                    if input() == \"n\":\n",
        "                        return False\n",
        "                attrs.existing_path = path\n",
        "                attrs.replace = True\n",
        "        attrs.show = show\n",
        "        attrs.save_path = path_tvshow(show)\n",
        "        os.makedirs(attrs.save_path, exist_ok=True)\n",
        "        if not attrs.save_name:\n",
        "            attrs.save_name = newname\n",
        "\n",
        "        if attrs.backup:\n",
        "            attrs.baksv = set()\n",
        "            for item in tvbackups:\n",
        "                pt1 = joinpath(item, show)\n",
        "                attrs.baksv.add(pt1)\n",
        "                os.makedirs(pt1, exist_ok=True)\n",
        "\n",
        "    elif Type == Episode:\n",
        "        newname = name_episode(attrs.name, attrs.quality)\n",
        "        show = name_show(attrs.name)\n",
        "        season = get_season(attrs.name)\n",
        "        search = episode_exists(show, season, newname)\n",
        "        if search:\n",
        "            show = search[1]\n",
        "            if search[2]:\n",
        "                path = search[2]\n",
        "                size = data_str(os.path.getsize(path))\n",
        "                message = f\"{newname} is already downloaded as {search[0]}. Size: {size}.\"\n",
        "                warning(message)\n",
        "                print( #add to output window\n",
        "                    f\"Warning: Prepare Download: {newname} is already downloaded as {search[0]}. Size: {size}. Do you want to overwrite?\")\n",
        "                if input() == \"n\":\n",
        "                    return False\n",
        "                attrs.existing_path = path\n",
        "                attrs.existing_file = search[0]\n",
        "                attrs.replace = True\n",
        "        attrs.show = show\n",
        "        attrs.season = season\n",
        "        attrs.save_path = path_season(show, season)\n",
        "        os.makedirs(attrs.save_path, exist_ok=True)\n",
        "        if not attrs.save_name:\n",
        "            attrs.save_name = newname\n",
        "\n",
        "        if attrs.backup:\n",
        "            itemdir = f\"{show}/{season}\"\n",
        "            attrs.baksv = set()\n",
        "            for item in tvbackups:\n",
        "                pt1 = joinpath(item, itemdir)\n",
        "                attrs.baksv.add(pt1)\n",
        "                os.makedirs(pt1, exist_ok=True)\n",
        "    else:\n",
        "        attrs.save_path = general_path\n",
        "        if attrs.backup:\n",
        "            attrs.baksv = generalbackups\n",
        "\n",
        "    if attrs.save_name:\n",
        "        attrs.save_dir = attrs.save_path if attrs.type_ == Episode else attrs.save_path + \\\n",
        "          '/' + attrs.save_name\n",
        "    info(\n",
        "        f\"Finished preparing download successfully.\\nDownload attributes: {getattrstr(attrs, filter_empty = True, add_line= True)}\")\n",
        "    return True\n",
        "\n",
        "#### API / Download management\n",
        "\n",
        "addsuccuss = 100\n",
        "adderror = 101\n",
        "alreadyadded = 101\n",
        "\n",
        "class AddResult():\n",
        "    handle = None\n",
        "    status = addsuccuss\n",
        "    errormessage = \"\"\n",
        "    succussmessage = \"\"\n",
        "    name = \"\"\n",
        "    savename = \"\"\n",
        "    size = 0\n",
        "    backuppath = \"\"\n",
        "    savepath = \"\"\n",
        "    hash = \"\"\n",
        "    totalfiles = \"\"\n",
        "    files = []\n",
        "    hasmetadata = False\n",
        "\n",
        "def get_magnet_name(magnet):\n",
        "    return urllib.parse.unquote(magnet.split(\"dn=\")[1].split(\"&tr=\")[0], encoding='utf-8', errors='replace').replace('+',\".\")\n",
        "\n",
        "def add_local_files(path= '.', files = set(), attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "      attrs = DownloadAttrs()\n",
        "    result = AddResult()\n",
        "    pathinvalid =  path != \".\" and not os.path.isdir(path) and not files\n",
        "    if path.endswith('.torrent'):\n",
        "        files= {path}\n",
        "    elif pathinvalid:\n",
        "        result.status = adderror\n",
        "        result.errormessage = f\"Path {path} isn't a directory or a torrent file.\"\n",
        "        error(result.errormessage)\n",
        "        return result\n",
        "    files = files if files else next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        attrs = attrs.copy()\n",
        "        splited = os.path.splitext(file)\n",
        "        if splited[1] == \".torrent\":\n",
        "            info(f\"Found a file to download: {file}\")\n",
        "            return add_download_file(file, attrs, result= result)\n",
        "\n",
        "def add_download_file(file, attrs: DownloadAttrs, result: AddResult = None, v= False):\n",
        "    if not result: \n",
        "        result = AddResult()\n",
        "    appstate.addresults.append(result)    \n",
        "    ti = lt.torrent_info(file)\n",
        "    attrs.name = ti.name()\n",
        "    info(f\"Adding file: {attrs.name}\")\n",
        "    if not ti.is_valid():\n",
        "        result.status = adderror\n",
        "        result.errormessage = f\"Invalid torrent: {attrs.name}\"\n",
        "        error(result.errormessage)\n",
        "        return result\n",
        "    if prepare_download(attrs):\n",
        "        !mv \"$file\" \"$added_path\"\n",
        "        result.succussmessage = \"Added Successfully \" + attrs.name\n",
        "        if v :\n",
        "            print(result.succussmessage) \n",
        "        params = {\n",
        "        \"save_path\": temp_save,\n",
        "        \"ti\": ti}\n",
        "\n",
        "        handle = ses.add_torrent(params)\n",
        "        handle.name = attrs.name\n",
        "        key = str(handle.info_hash())\n",
        "        result.name = attrs.name\n",
        "        result.handle = handle\n",
        "        info(f\"Download info: {attrs.name}\\nHash: {key}\\nFiles: {result.totalfiles}\")\n",
        "        if key in downloads_dict:\n",
        "            result.status = adderror\n",
        "            result.errormessage = f\"{attrs.name} is already added.\"\n",
        "            error(result.errormessage)\n",
        "            return result\n",
        "        \n",
        "        result.hash = key\n",
        "        result.totalfiles = ti.num_files()\n",
        "        result.savepath = attrs.save_path\n",
        "        result.savename = attrs.save_name\n",
        "        \n",
        "        handle.completed = False\n",
        "        handle.attrs = attrs\n",
        "        downloads_dict[key] = handle\n",
        "        active.append(handle)\n",
        "        add_download_trackers(handle)\n",
        "        torrentfile = handle.torrent_file()\n",
        "        if torrentfile:\n",
        "            get_filtered_download_files(handle)\n",
        "            handle.attrs.hasmetadata = True\n",
        "            result.hasmetadata = True\n",
        "            result.files = handle.attrs.files\n",
        "        else:\n",
        "            handle.attrs.hasmetadata = False\n",
        "            result.hasmetadata = False\n",
        "        result.status = addsuccuss\n",
        "        info(f\"{attrs.name} is added succussfully. Save name: {attrs.save_name}\")\n",
        "        return result\n",
        "    result.status = adderror\n",
        "    result.errormessage = f\"Download wasn't added {attrs.name}\"\n",
        "    warning(f\"{attrs.name} wasn't added.\")\n",
        "    return result\n",
        "\n",
        "def add_magnet_download(magnet_link, attrs: DownloadAttrs, v= False):\n",
        "    result = AddResult()\n",
        "    appstate.addresults.append(result) \n",
        "    if not magnet_link:\n",
        "        error(f\"Magnet is empty. {attrs.name}\")\n",
        "        return result\n",
        "    info(f\"Adding magnet download: {attrs.name}\")\n",
        "    if prepare_download(attrs):\n",
        "        params = lt.parse_magnet_uri(magnet_link)\n",
        "        params.save_path = temp_save\n",
        "        handle = ses.add_torrent(params)\n",
        "        handle.name = attrs.name \n",
        "        result.name = attrs.name \n",
        "        result.handle = handle\n",
        "        if not handle.is_valid():\n",
        "            result.status = adderror\n",
        "            result.errormessage = f\"Invalid torrent {attrs.name}\"\n",
        "            error(f\"Invalid torrent {attrs.name}\")\n",
        "            if v:\n",
        "                print(\" Invalid torrent  {0}\".format(attrs.name))\n",
        "            return result\n",
        "        key = str(handle.info_hash())\n",
        "        if key in downloads_dict:\n",
        "            result.status = adderror\n",
        "            result.errormessage = f\"{attrs.name} is already added.\"\n",
        "            error(f\"{attrs.name} is already added.\")\n",
        "            return result\n",
        "\n",
        "        handle.attrs = attrs\n",
        "        handle.completed = False\n",
        "        downloads_dict[key] = handle\n",
        "        active.append(handle)\n",
        "        add_download_trackers(handle)\n",
        "        torrentfile = handle.torrent_file()\n",
        "        if torrentfile:\n",
        "            handle.name = attrs.name = torrentfile.name()\n",
        "            handle.attrs.hasmetadata = True\n",
        "            get_filtered_download_files(handle)\n",
        "            result.hasmetadata = True\n",
        "            result.files = handle.attrs.files\n",
        "        else:\n",
        "            handle.attrs.hasmetadata = False\n",
        "            result.hasmetadata = False\n",
        "        info(f\"{attrs.name} is added succussfully. Save name: {attrs.save_name}\")\n",
        "        result.status = addsuccuss\n",
        "        return result\n",
        "    error(f\"{attrs.name} wasn't added.\")\n",
        "    result.status = adderror\n",
        "    result.errormessage = f\"An error in adding download: {attrs.name}\"\n",
        "    return result\n",
        "\n",
        "def add_hash_download(hash, attrs, title = ''):\n",
        "    if not title:\n",
        "        title = hash\n",
        "    download_link = f\"https://itorrents.org/torrent/{hash}.torrent\"\n",
        "    filename = f\"/content/{title}.torrent\"\n",
        "    !wget \"$download_link\" -O \"$filename\" $nullout\n",
        "    return add_download_file(filename, attrs)\n",
        "\n",
        "def get_filtered_download_files(handle): \n",
        "    info(f\"Filtering download files for: {handle.name}.\")\n",
        "    downloadfiles = []\n",
        "    allfiles = selectedfiles = total_download = 0\n",
        "    tf = handle.torrent_file()\n",
        "    if tf:\n",
        "        handle.attrs.hasmetadata = True\n",
        "        files = tf.files()\n",
        "        total_download = 0\n",
        "        allfiles = files.num_files()\n",
        "        selectedfiles = 0\n",
        "\n",
        "        for i in range(allfiles):\n",
        "            file = DownloadFile(i, files.file_name(i), files.file_size(i))\n",
        "            if any(contains(file.name, check) for check in skip_list):\n",
        "                info(f\"{files.file_name(i)} is filtered.\")\n",
        "                handle.file_priority(i,0)\n",
        "                file.selected = False\n",
        "            else:\n",
        "                selectedfiles += 1\n",
        "                handle.file_priority(i,6)\n",
        "                total_download += file.size\n",
        "                file.selected = True\n",
        "            downloadfiles.append(file)\n",
        "    else:\n",
        "        info(handle.name + \" has no metadata.\")\n",
        "        handle.attrs.hasmetadata = False\n",
        "    handle.attrs.download_size = total_download\n",
        "    handle.attrs.allfiles = allfiles\n",
        "    handle.attrs.selectedfiles = selectedfiles\n",
        "    handle.attrs.files = downloadfiles\n",
        "\n",
        "def selectdownloadfiles(handle, files):\n",
        "    if not handle:\n",
        "        return\n",
        "    totaldownload = 0\n",
        "    for file in files:\n",
        "        if file.selected:\n",
        "            handle.file_priority(file.index, 6)\n",
        "            totaldownload += file.size\n",
        "        else:\n",
        "            handle.file_priority(file.index, 0)\n",
        "    handle.total_download = totaldownload\n",
        "    return True\n",
        "  \n",
        "def add_download_trackers(handle):\n",
        "    for x in range(len(new_trackers)):\n",
        "        annouce_entry = {'url': new_trackers[x], 'tier': 2}\n",
        "        handle.add_tracker(annouce_entry) \n",
        " \n",
        "#### API / After Download Operations \n",
        "\n",
        "def shave_download(handle, path, maindir) :\n",
        "    tf = handle.torrent_file()\n",
        "    files = tf.files()\n",
        "    priorities = handle.get_file_priorities()\n",
        "    for i in range(len(priorities)):\n",
        "        file_path = path + \"/\" + files.file_path(i)\n",
        "        if os.path.isfile(file_path) and priorities[i] == 0:\n",
        "            !rm \"$file_path\"\n",
        "            dirpath = os.path.dirname(file_path)\n",
        "            if is_empty(dirpath):\n",
        "                !rm -r \"$dirpath\"\n",
        "    dircontent = next(os.walk(maindir))[1]\n",
        "    for path in dircontent:\n",
        "        if is_empty(path):\n",
        "            !rm -r \"$dirpath\"\n",
        "\n",
        "def clean_download(attrs: DownloadAttrs, path):\n",
        "    info(f\"Cleaning type: {types[attrs.type_]} name: {attrs.name}\")\n",
        "    attrs.downloaded = []\n",
        "    if attrs.type_ == Movie:\n",
        "        after_shave(path, attrs.save_name, pathitems = attrs.downloaded)\n",
        "    elif attrs.type_ == Show:\n",
        "        clean_tvshow(path, pathitems = attrs.downloaded)\n",
        "    elif attrs.type_ == Season or attrs.type_ == Episode:\n",
        "        path_item =  ('', clean_season(path))\n",
        "        attrs.downloaded.append(path_item)\n",
        "  \n",
        "def after_shave (path, newname, v= False, pathitems = []):\n",
        "    dircontent = next(os.walk(path))[2]\n",
        "    item1 = ('', [])\n",
        "    for file in dircontent:\n",
        "        srt = 0\n",
        "        split = os.path.splitext(file)\n",
        "        ext = split[1]\n",
        "        p1 = path + \"/\" + file\n",
        "        if any(contains(file, check) for check in skip_list):\n",
        "            if v:\n",
        "                print(f\"Deleting: {p1[36:]}\")\n",
        "            !rm \"$p1\"\n",
        "            continue\n",
        "        elif  (ext == \".mp4\" or ext == \".mkv\" or ext == \".srt\" or ext == \".idx\"):\n",
        "            extra = \"\"\n",
        "            if ext == \".srt\": \n",
        "                if re.split(re_suf, split[0])[0] != newname:\n",
        "                    if srt > 0 :\n",
        "                        extra = \" \" + str(srt)\n",
        "                    srt += 1\n",
        "                else:\n",
        "                    item1[1].append(file)\n",
        "                    continue\n",
        "            elif split[0] == newname:\n",
        "                item1[1].append(file)\n",
        "                continue\n",
        "            file = newname + extra + ext\n",
        "            if v:\n",
        "                print(f\"Renaming: {p1[36:]} to {file}\")\n",
        "            p2 = path + \"/\" + file\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            item1[1].append(file)\n",
        "    pathitems.append(item1)\n",
        "    subdir = \"Subs\"\n",
        "    subspath = path + \"/\" + subdir\n",
        "    if not os.path.exists(subspath):\n",
        "        subdir = \"subs\"\n",
        "        subspath = path + \"/\" + subdir\n",
        "        if not os.path.exists(subspath):\n",
        "            return\n",
        "    subs =  next(os.walk(subspath))[2]\n",
        "    count = 0\n",
        "    item2 = (subdir, [])\n",
        "    for sub in subs:\n",
        "        split = os.path.splitext(sub)\n",
        "        ext = split[1]\n",
        "        srtname = f\"{newname} {str(count)}\" if count > 0 else newname\n",
        "        if ext == '.srt' and re.split(re_suf, split[0])[0] != newname:\n",
        "            newsub = srtname + ext \n",
        "            p1 = subspath + \"/\" + sub\n",
        "            p2 = subspath + \"/\" + newsub\n",
        "            if v:\n",
        "                print(f\"Renaming: {p1[36:]} to {newsub}\")\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            count += 1\n",
        "            item2[1].append(newsub)\n",
        "        else:\n",
        "            item2[1].append(sub)\n",
        "        pathitems.append(item2)\n",
        "    return\n",
        "\n",
        "def clean_movies_dir(movie_path = movies_path, v = False, backup = False, delete_empty = False, clean = True) :\n",
        "    dir_content = filter_checks(next(os.walk(movie_path))[1])\n",
        "    path = \"\"\n",
        "    for dir in dir_content :\n",
        "        path = movie_path + \"/\" + dir\n",
        "        if delete_empty:\n",
        "            size = pathsize(path)\n",
        "            if size < size_limit:\n",
        "                if v:\n",
        "                    print(f\"Deleting: {path} size: {data_str(size)}\")\n",
        "                !rm -r \"$path\"\n",
        "\n",
        "                if backup and False: #fixbackup\n",
        "                    for mvdir in movies_basenames:\n",
        "                        if not mvdir in movie_path:\n",
        "                            path0 = \"bk path\"\n",
        "                            size = pathsize(path0)\n",
        "                            if size < size_limit:\n",
        "                                if v:\n",
        "                                    print(f\"Deleting: {path0} size: {data_str(size)}\")\n",
        "                                !rm -r \"$path0\" \n",
        "                continue\n",
        "          \n",
        "        if clean:\n",
        "            clean_movie(path, dir, movie_path, v = v)\n",
        "\n",
        "def clean_movie(path, name, movie_path = movies_path, v = False):\n",
        "    newname = name\n",
        "    search = re.search(r\"\\d{4}$\", name)\n",
        "    if not search:\n",
        "        newname = name_movie(name)\n",
        "        p1 = path\n",
        "        p2 = movie_path + \"/\" + newname\n",
        "        !mv \"$p1\" \"$p2\"\n",
        "        path = p2\n",
        "        print(newname)\n",
        "    after_shave(path, newname, v = v)\n",
        "\n",
        "def clean_tvshows(path = \"\"):\n",
        "    if not path:\n",
        "        path = tv_path\n",
        "    shows = next(os.walk(path))[1]\n",
        "    for show in shows:\n",
        "        print(show)\n",
        "        path = path + \"/\" + show\n",
        "        clean_tvshow(path)\n",
        "\n",
        "def clean_tvshow(path, keepChar = \"\", pathitems = []):\n",
        "    dircontent = next(os.walk(path))[1]\n",
        "    if len(dircontent) != 0:\n",
        "        for dir in dircontent:\n",
        "            p0 = path + \"/\" + dir\n",
        "            if not has_size(p0, True):\n",
        "                !rm -r \"$p0\"\n",
        "                continue\n",
        "            newname = get_season(dir, False)\n",
        "            if newname:\n",
        "                if newname != dir:\n",
        "                    p0 =  path + \"/\" + dir\n",
        "                    p1 = path + \"/\" + newname\n",
        "                    !mv \"$p0\" \"$p1\"\n",
        "                    dir = newname\n",
        "            seasonpath = path + \"/\" + dir\n",
        "            files = clean_season(seasonpath, keepChar)\n",
        "            item = (dir, files)\n",
        "            pathitems.append(item)\n",
        "    else:\n",
        "        files = clean_season(path, keepChar)\n",
        "        item = ('', files)\n",
        "        pathitems.append(item)\n",
        "    return\n",
        "\n",
        "def clean_season(path, keepDot = False):\n",
        "    clean = []\n",
        "    info(f'Cleaning show season in path: {path}')\n",
        "    if not os.path.exists(path):\n",
        "        return\n",
        "    files = next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        splitted = os.path.splitext(file)\n",
        "        eps = splitted[0]\n",
        "        ext = splitted[1]\n",
        "        p1 = path + \"/\" + file\n",
        "        if ext == \".mkv\" or ext == \".mp4\" or ext == \".srt\":\n",
        "            newname = name_episode(eps, keepDot= keepDot) + ext\n",
        "            if newname != file:\n",
        "                p2 = path + \"/\" + newname\n",
        "                !mv \"$p1\" \"$p2\" \n",
        "            clean.append(newname)\n",
        "        elif any(contains(file.lower(), check) for check in skip_list):\n",
        "            !rm \"$p1\" \n",
        "    info(f'Cleaned files: {len(clean)}')   \n",
        "    return clean\n",
        "\n",
        "#### API / IMDB Scraping\n",
        "\n",
        "def AdvancedIMDBSearch ( params: imdb_params, attr_ : DownloadAttrs):\n",
        "    url=f'https://www.imdb.com/search/title/?title={params.keyword}&title_type={params.title_type}&release_date={params.s_year}-01-01,{params.e_year}-12-31&user_rating={params.ratings}&num_votes={params.min_votes},&runtime=,{params.max_run}&my_ratings=exclude&lists={params.lists}&groups={params.labels}&sort={params.imdb_sort}&view=advanced&count=250'\n",
        "    resp=requests.get(url, headers = {\"Accept-Language\": \"en-US\"})\n",
        "    if resp.status_code == 200:\n",
        "        print(\"\\n IMDB Search Done Successfully...\\n\")\n",
        "        soup = BeautifulSoup(resp.text,'html.parser')    \n",
        "        l = soup.find(\"div\", {\"class\":\"lister-list\"})\n",
        "        if not l :\n",
        "            print(\"AdvancedIMDBSearch: Error: An error occured while performing the web scrapping.\")\n",
        "            return\n",
        "        movie_list: list[imdb_result]= []\n",
        "        downloaded= []\n",
        "        all_items = l.findAll(class_=\"lister-item\")\n",
        "        for i in range(len(all_items)):\n",
        "            year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
        "            title_raw = all_items[i].find(class_=\"lister-item-header\").a.text\n",
        "            title = find_title(title_raw, year_raw)\n",
        "            runtime = all_items[i].find(class_=\"runtime\").text\n",
        "            genres = all_items[i].find(class_=\"genre\").text.strip()\n",
        "            rating = all_items[i].find(class_=\"ratings-imdb-rating\")[\"data-value\"]\n",
        "            votes = all_items[i].find(\"span\", {\"name\":\"nv\"}).text\n",
        "            res= imdb_result(title, runtime, genres, rating, votes, \"\", \"\")\n",
        "            if title in watched_movies_list and params.filter_watched:\n",
        "                continue\n",
        "            if movie_exists(title):\n",
        "                downloaded.append(res)\n",
        "                if params.filter_downloaded:\n",
        "                    continue         \n",
        "            movie_list.append(res)\n",
        "        print()\n",
        "        watch_state=\"\"\n",
        "        if params.filter_downloaded:\n",
        "            for item in downloaded:\n",
        "                if item.title in watched_movies_list:\n",
        "                    watch_state = \"WATCHED\"\n",
        "                else:\n",
        "                    watch_state = \"\"\n",
        "                print(\"        {:<70}{:<30}DOWNLOADED{:>10}{:^12}{:15}{:>10}\".format(item.title, item.genres, item.runtime, item.rating, item.votes, watch_state))\n",
        "            for index in range(len(movie_list)):\n",
        "                if movie_list[index].title in watched_movies_list:\n",
        "                    watch_state = \"WATCHED\"\n",
        "                else:\n",
        "                    watch_state = \"\"\n",
        "                print(\"  {:>3} - {:<70}{:<29}{:>21}{:^12}{:15}{:>10}\".format(index + 1 , movie_list[index].title, movie_list[index].genres, movie_list[index].runtime, movie_list[index].rating, movie_list[index].votes, watch_state))\n",
        "        else:\n",
        "            watch_state = download_state = \"\"\n",
        "            for index in range(len(movie_list)):          \n",
        "                if movie_list[index].title in watched_movies_list:\n",
        "                    watch_state = \"WATCHED\"\n",
        "                else:\n",
        "                    watch_state = \"\"          \n",
        "                if movie_list[index] in downloaded:\n",
        "                    download_state = \"DOWNLOADED\"\n",
        "                else:\n",
        "                    download_state = \"\"\n",
        "                print(\"  {:>3} - {:<70}{:<29}{:>15}{:>15}{:^12}{:15}{:>10}\".format(index + 1,  movie_list[index].title, movie_list[index].genres,  download_state, movie_list[index].runtime, movie_list[index].rating, movie_list[index].votes, watch_state))\n",
        "\n",
        "        if params.rarbg_download or params.l337x_download:\n",
        "            print(\"\\n--> Choose movie range to download:       Format: [start-end]      [title1,title5..]     [single]     Exit: enter \\n\")\n",
        "            start = end = -1\n",
        "            items: list[int] = []\n",
        "            rng = input().lower()\n",
        "            if rng == \"\" or rng == 'q' or rng == \"s\" or rng == \" \":\n",
        "                return\n",
        "            rngs = rng.split(',')\n",
        "            for item in rngs:\n",
        "                if \"r\" in item:\n",
        "                    try:\n",
        "                        rename_title(movie_list[int(item.replace(\"r\", \"\"))-1].title)\n",
        "                    except Exception as e:\n",
        "                        print(e)\n",
        "                elif \"-\" in item:\n",
        "                    in_rngs = item.split('-')\n",
        "                    start = int(in_rngs[0])-1\n",
        "                    end = int(in_rngs[1])\n",
        "                    items.extend(range(start, end))\n",
        "                else:\n",
        "                    i = int(item)-1\n",
        "                    items.append(i)\n",
        "            for i in items:\n",
        "                attrs = attr_.copy()\n",
        "                attrs.save_name = movie_list[i].title \n",
        "                attrs.imdb_name = movie_list[i].title\n",
        "                attrs.imdb_rating = movie_list[i].rating\n",
        "                attrs.imdb_votes = movie_list[i].votes         \n",
        "                if params.l337x_download and params.rarbg_download:         \n",
        "                    print(\"Downloading: {}\\nSelect source:\\n  1- 1337x\\n  2- rarbg\\n\".format(movie_list[i].title))\n",
        "                    select= input(\"\").lower()\n",
        "                    if select == \"s\" or select == \"\" : \n",
        "                        continue\n",
        "                    if select == \"q\" or select == \" \" : \n",
        "                        return\n",
        "                    select= int(select)\n",
        "                    if select == 1:                  \n",
        "                        search(Site = (l337x, True), Search = f\"{movie_list[i].title} {params.download_params}\", category = params.site_category, attrs = attrs, sort = params.sort)\n",
        "                    else: \n",
        "                        search((rarbg, True),  Search = f\"{movie_list[i].title} {params.download_params}\", category = params.site_category, attrs = attrs, rarbg_auto = params.rarbg_auto)\n",
        "                elif params.l337x_download:\n",
        "                    search((l337x, False),  Search = f\"{movie_list[i].title} {params.download_params}\", category = params.site_category, attrs = attrs, sort = params.sort)\n",
        "                elif params.rarbg_download:    \n",
        "                    search((rarbg, False), Search = f\"{movie_list[i].title} {params.download_params}\", category = params.site_category, attrs = attrs, rarbg_auto = params.rarbg_auto)            \n",
        "            print(\"\\n         Done\")\n",
        "    else:\n",
        "        print(\"AdvancedIMDBSearch: Error accessing the web page. Code error: {0}\".format(resp.state_code))\n",
        "\n",
        "def scrape_watched_movies_list(pages = 1):\n",
        "    info(f\"Scrapping watched movies list from IMDB. URL:{watched_list_url}.\")\n",
        "    for i in range(0,1):\n",
        "        currentpage = watched_list_url + str(i*251)\n",
        "        imdbresponse = requests.get(currentpage, headers = {\"Accept-Language\": \"en-US\"})\n",
        "        soup = BeautifulSoup(imdbresponse.text,'html.parser')    \n",
        "        scrape = soup.find(\"div\",{\"class\":\"lister-list\"})\n",
        "        if not scrape :\n",
        "            return\n",
        "        all_items = scrape.findAll(class_=\"lister-item-header\")\n",
        "        for i in range(len(all_items)):\n",
        "            year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
        "            title_raw = all_items[i].a.text\n",
        "            title = find_title(title_raw, year_raw)      \n",
        "            watched_movies_list.append(title)\n",
        "    info(f\"Scrapped watched movies: {len(watched_movies_list)} movie.\")\n",
        "    return\n",
        "\n",
        "#### API / rarbg api\n",
        "\n",
        "tokens = {\"TD0\": \"anpfy1ko6z\", \"TD1\": \"b2nuip039q\", \"TD2\": \"84gy57ew3v\", \"TD3\": \"2kjweiogl5\", \"TD4\": \"e0bnj3xucl\", \"TD5\": \"cs4r9hvpkj\", \"TD6\": \"uso5jew6yh\", \"TD7\": \"yc82r5ogws\", \"TD8\": \"fhpkc0ivau\", 'TD9': 'm9ytpnkdxj'}\n",
        "rarbg_api = 'http://torrentapi.org/pubapi_v2.php'\n",
        "token = tokens[td_id]\n",
        "version = '2.6.0'\n",
        "app_id = 'cooltd'\n",
        "user_agent = \"cooltd/1.5.0 (Linux; c6afa4a080b9; 5.10.133+; #1 SMP Fri Aug 26 08:44:51 UTC 2022; x86_64; x86_64) python 3.7.13\"\n",
        "\n",
        "def get_user_agent():\n",
        "    uname = '; '.join(platform.uname())\n",
        "    pyver = platform.python_version()\n",
        "    return f'{app_id}/{version} ({uname}) python {pyver}'\n",
        "\n",
        "def request(method, url, params=None):\n",
        "    info(f\"Request {method}@{url}\\nParams: {params}\")\n",
        "    if not params:\n",
        "        params = {}\n",
        "    params.update({\n",
        "        'app_id': app_id\n",
        "    })\n",
        "\n",
        "    headers = {\n",
        "        'user-agent': user_agent\n",
        "    }\n",
        "    sess = requests.Session()\n",
        "    req = requests.Request(method, url, params=params, headers=headers)\n",
        "    preq = req.prepare()\n",
        "    res = sess.send(preq)\n",
        "    info(f\"Request status: {res.status_code}\")\n",
        "    res.raise_for_status()\n",
        "    return res\n",
        "\n",
        "def rarbg_token(v = False):\n",
        "    info('Refreshing rarbg token.')\n",
        "    if v:\n",
        "        print('Refreshing rarbg token.')\n",
        "    params = {\n",
        "        'get_token': 'get_token'\n",
        "    }\n",
        "    res = request('GET', rarbg_api, params)\n",
        "    json_res = res.json() if res and res.status_code == 200 else None\n",
        "    if json_res and 'token' in json_res:\n",
        "        info(\"Rarbg token successfully refreshed.\")\n",
        "        global token, user_agent\n",
        "        token = json_res['token']\n",
        "        user_agent = get_user_agent()\n",
        "        info(f\"New rarbg token: {token} User agent: {user_agent}\")\n",
        "        if v:\n",
        "            print(f\"New rarbg token: {token}\\nUser agent: {user_agent}\")\n",
        "    else:\n",
        "        error(f'Error while getting a rarbg token. status code: {res.status_code()}\\nrequest result: {res}\\nUser agent: {user_agent}')\n",
        "        print(f'Error while getting a rarbg token.status code: {res.status_code()}\\nrequest result: {res}\\nUser agent: {user_agent}')\n",
        "\n",
        "def rarbg_rip(key= '', imdb = '', categories = None, sort = '', v = False):\n",
        "    catstr = 'any' if categories == None else categories\n",
        "    info(f\"Searching for: {key} {imdb} in categories: {catstr}\")\n",
        "    category = ''\n",
        "    params = {\n",
        "        'mode': 'search',\n",
        "        'token': token\n",
        "        }\n",
        "    if key:\n",
        "        params['search_string'] = key\n",
        "    elif imdb:\n",
        "        params['search_imdb'] = imdb\n",
        "    else:\n",
        "        return None\n",
        "    if categories:\n",
        "        category = str(categories[0])\n",
        "        for i in range(1, len(categories)):\n",
        "            category += ';' + str(categories[i])\n",
        "        params['category'] = category \n",
        "\n",
        "    if sort:\n",
        "        params['sort'] = sort\n",
        "    try:\n",
        "        res = request('GET', rarbg_api, params)\n",
        "        json_res = res.json() if res.status_code == 200 else None\n",
        "    except Exception as e:\n",
        "        print(e)\n",
        "        return None\n",
        "    if json_res:\n",
        "        if \"error_code\" in json_res.keys():\n",
        "            if json_res[\"error_code\"] == 20:\n",
        "                info(f\"Searching for {key if key else imdb} got no results. \\nRequest result: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\\nThe API may not be working check the link.\")\n",
        "                if v:\n",
        "                    print(f\"Searching for {key if key else imdb} got no results. \\nRequest result: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\\nThe API may not be working check the link.\") \n",
        "            else:\n",
        "                error(f\"An error happened while requesting rarbg api. Error: {json_res['error']}. Error code: {json_res['error_code']}.\\nParams: {params}\", v = False)     \n",
        "            rarbg_token()\n",
        "            params['token'] = token\n",
        "            time.sleep(1)\n",
        "            info(f\"Retrying search for: {key} {imdb}\")\n",
        "            res = request('GET', rarbg_api, params)\n",
        "            json_res = res.json() if res.status_code == 200 else None  \n",
        "\n",
        "        if json_res and 'torrent_results' in json_res:\n",
        "            results = []\n",
        "            for rs in json_res['torrent_results']:\n",
        "                result: web_result = web_result(rs[\"filename\"])\n",
        "                result.magnet = rs[\"download\"]\n",
        "                results.append(result)\n",
        "            info(f\"Successfully searched: {key} {imdb} in categories: {catstr} {len(results)} results.\")\n",
        "            return results\n",
        "    error(f\"Search for: {key} {imdb} in categories: {catstr} wasn't completed.\\nResult: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\", v = False)\n",
        "    if v: \n",
        "        print(f\"An error happened while requesting rarbg api. Result: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\")\n",
        "    return False\n",
        "\n",
        "def Download_Rarbg(search, category = '', sort = sort1337x_seeders_desc, rarbg_auto = False, attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    info(f\"Searching for {search} in rarbg.com.\")\n",
        "    print(f\"\\nSearching for:  {search} in rarbg.com.\\n\")\n",
        "    rarbgsort = magnet = name = \"\"\n",
        "\n",
        "    if category == moviescategory:\n",
        "        all_cat = rarbg_movie\n",
        "        categories = rarbg_movie\n",
        "    elif category == tvcategory : \n",
        "        all_cat = rarbg_tv\n",
        "        categories = rarbg_tv\n",
        "    else:\n",
        "        all_cat = None\n",
        "        categories = None\n",
        "\n",
        "    rarbgsort = sortrarbg_seeders  \n",
        "    if sort == sort1337x_time_desc:\n",
        "        rarbgsort = sortrarbg_time\n",
        "\n",
        "    results: list[web_result]\n",
        "    state = 1                                 # 1 init, 2 edit & redo search, 0 done, -1 bad search\n",
        "    while state != 0 :\n",
        "\n",
        "        if state == 1:\n",
        "            results = rarbg_rip(key = search, categories = categories, sort = rarbgsort)\n",
        "            if not results and categories and state != 2 :    \n",
        "                results = rarbg_rip(key = search, sort = rarbgsort)\n",
        "            state = 3\n",
        "\n",
        "        elif state == 2:\n",
        "            link = f\"https://rarbgenter.org/torrents.php?search={search.replace(' ', '+')}\"\n",
        "            warning(f\"Searching for {search} in rarbg.com. No results were found. Please check the link to ensure the results.\\n{link}\")\n",
        "            print(f\"No results were found. Please check the link to ensure the results.\\n{link}\\n\\nEnter e:[search] to edit, m:[magnet] to add magnet directly:, i < 7 to exit:\\n\")\n",
        "            newinput = input()\n",
        "\n",
        "            if len (newinput) < 7:\n",
        "                return -1\n",
        "\n",
        "            elif newinput.startswith(\"m:\"):\n",
        "                magnet = newinput[2:]\n",
        "                try:\n",
        "                    name = get_magnet_name(magnet)\n",
        "                except Exception as e:\n",
        "                    name = search\n",
        "                    error(f\"Magnet name wasn't obtained: {magnet}\")\n",
        "                results = None\n",
        "                state = 4\n",
        "\n",
        "            elif newinput.startswith(\"e:\"):\n",
        "                newinput = newinput[2:]\n",
        "                results = rarbg_rip(key = newinput, sort = rarbgsort)\n",
        "                state = 1\n",
        "\n",
        "        if results: \n",
        "            print(\"\\n     {:<70}{:>10}{:>10}\\n\".format(\"Title\", \"Size\", \"Seeders\"))\n",
        "            for i in range(len(results)):\n",
        "                print(\" {:<2}- {:<70}\".format(i + 1 , results[i].title))\n",
        "            if len(results) == 1 and rarbg_auto:\n",
        "                magnet = results[0].magnet\n",
        "                name = results[0].title\n",
        "                state = 4\n",
        "\n",
        "            else:\n",
        "                print(\"\\nPlease choose one of the results to download             Format [single]     Enter q to exit, e to edit the search:\")\n",
        "                choice = -1\n",
        "                while choice == -1:                   #out of range get input again.\n",
        "                    choice = input().lower()\n",
        "                    if choice == \"\" or choice == \" \" or choice == \"s\" or choice == \"q\": \n",
        "                        return -1\n",
        "                    elif choice == \"e\":\n",
        "                        state = 2\n",
        "                        break\n",
        "                      \n",
        "                    choice = int(choice) - 1\n",
        "                    if choice < 0 or choice >= len(results):\n",
        "                        print(\"\\nChoice out of range.\")\n",
        "                        choice = -1\n",
        "                if state == 2:\n",
        "                    continue\n",
        "                else:\n",
        "                    magnet = results[choice].magnet\n",
        "                    name = results[choice].title\n",
        "                    results = None\n",
        "                    state = 4\n",
        "\n",
        "        if state == 4:      \n",
        "            attrs.site_source = rarbg\n",
        "            attrs.name = name\n",
        "            attrs.magnet = magnet\n",
        "            result: AddResult = add_magnet_download(magnet, attrs)\n",
        "            if result.status == addsuccuss:\n",
        "                state = 0\n",
        "                return 0\n",
        "            else:\n",
        "                return -1\n",
        "        else:\n",
        "            state = 2\n",
        "    return 0\n",
        "\n",
        "#### API / search 1337\n",
        "\n",
        "def search1337x(search, sort = sort1337x_seeders_desc, category = \"\", page = 1, attrs = None):\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    search_s = search.replace(\"'\", \" \").replace(\" \",\"%20\")\n",
        "    sort1337x = l337x_seeders\n",
        "    if sort == sort1337x_time_desc:\n",
        "        sort1337x = l337x_time_desc\n",
        "    elif sort == sort1337x_time_asc:\n",
        "        sort1337x = sort1337x_time_asc    \n",
        "    elif sort == sort1337x_size_asc:\n",
        "        sort1337x = l337x_size_asc    \n",
        "    elif sort == sort1337x_size_desc:\n",
        "        sort1337x = l337x_size_desc   \n",
        "\n",
        "    parameters = f\"sort-category-search/{search_s}/{category}/{sort1337x}/{page}/\" if category else f\"sort-search/{search_s}/{sort1337x}/{page}/\"\n",
        "    url = \"https://www.1337xx.to/\" + parameters\n",
        "    info(f\"Scraping 1337x search for: {search} URL: {url}.\")\n",
        "    download_state = \"downloaded\" if check_download(attrs.type_, search) else  \"not downloaded\"\n",
        "    info(f\"{search} is {download_state}.\")\n",
        "    state = 1\n",
        "    while state:\n",
        "        if state == 1:\n",
        "            print(\"Page: {} \\n\".format(url))\n",
        "            response = requests.get(url, headers= {\"Accept-Language\": \"en-US\"})\n",
        "        elif state == 2:\n",
        "            print(f\"Edit search, q to return: {search}\")\n",
        "            newinput = input()\n",
        "            if len (newinput) < 4: return -1\n",
        "            else:\n",
        "                newurl = f\"https://www.1337xx.to/sort-search/{newinput}/{sort1337x}/1/\"\n",
        "                print(\"Page: {} \\n\".format(newurl))\n",
        "                response = requests.get(newurl, headers= {\"Accept-Language\": \"en-US\"})\n",
        "                state = 0\n",
        "        if response.status_code == 200 :\n",
        "            soup = BeautifulSoup(response.text, 'html.parser' )\n",
        "            main_element = soup.find(\"tbody\")\n",
        "            if main_element is None:\n",
        "                print(\"\\nNull search. Enter e to edit the search, q to exit.\\n\")\n",
        "                choice = input().lower()\n",
        "                if choice == \"e\":\n",
        "                    state = 2\n",
        "                    continue\n",
        "                else: return -1\n",
        "            all_res = main_element.findAll(\"tr\")\n",
        "            title = size = uploader = seeders = leechers = \"\"\n",
        "            results = [] \n",
        "            if all_res:\n",
        "                info(f\"Results found: {len(all_res)}.\")\n",
        "                print(\"\\n    {:<120}{:^12}    {:^15}{:^21}{:^4}{:>14}\\n\".format(\"Title\", \"Size\", \"Date\", \"Uploader\", \"Seeders\", \"Leechers\"))\n",
        "            else:\n",
        "                info(f\"No results found for {search}.\")\n",
        "            for i in  range(len(all_res)):\n",
        "                alldata= all_res[i].findAll(\"td\")\n",
        "                title = alldata[0].findAll(\"a\")[1].text\n",
        "                size = alldata[4].text\n",
        "                date = alldata[3].text\n",
        "                seeders = alldata[1].text\n",
        "                leechers = alldata[2].text\n",
        "                uploader = alldata[5].a.text\n",
        "                print(\"{:<2}- {:<118}{:>11}       {:<16}{:>12}{:>12}{:>13}\".format(i + 1, title.strip(), size, date, uploader, seeders, leechers,))\n",
        "                href = \"https://www.1337xx.to\" + alldata[0].findAll(\"a\")[1]['href']\n",
        "                res = web_result(title= title, size= size, date= date, seeders= seeders, leechers= leechers, uploader= uploader, href= href)\n",
        "                results.append(res)\n",
        "\n",
        "            print(\"\\nPlease choose a result to download:\\n        Enter space, s or q to quit, n for the next page, p for the previous page, p+page to choose page.\\n\")\n",
        "            choice = input().lower()\n",
        "            if choice == \"\" or choice == \" \" or choice == \"s\" or choice == \"q\":\n",
        "                info(f\"No result chosen. Exiting scrap1337x.\")\n",
        "                print(\"\\nExiting.\\n\")\n",
        "                return -1\n",
        "            if choice == 'n':\n",
        "                info(f\"1337x will be scrapped for next page: {page + 1}.\")\n",
        "                return page + 1\n",
        "            if choice == 'p':\n",
        "                if page > 1:\n",
        "                    info(f\"1337x will be scrapped for previous page: {page - 1}.\")\n",
        "                    return page - 1\n",
        "                else:\n",
        "                    info(f\"1337x will be scrapped for page: {page}.\")\n",
        "                    return page\n",
        "            elif choice[0] == \"p\":\n",
        "                try:\n",
        "                    page = int(choice[1:])\n",
        "                    if page > 0:\n",
        "                        return page\n",
        "                    else:\n",
        "                        return -1\n",
        "                except Exception as e:\n",
        "                    print(e)\n",
        "                    return -1      \n",
        "            if ',' in choice:\n",
        "                choices = choice.split(',')\n",
        "            else:\n",
        "                choices = [choice]\n",
        "            i = 0  \n",
        "            for choice in choices:\n",
        "                select = results[int(choice) - 1]\n",
        "                info(f\"Download choice: {select.title}.\")\n",
        "                print(f\"\\n Downloading file and adding {select.title} :\\n\")\n",
        "                url = select.href\n",
        "                download = requests.get(url)\n",
        "                soup = BeautifulSoup(download.text, \"html.parser\")\n",
        "                if  i > 0 and attrs.save_name:\n",
        "                    attrs.save_name = attrs.save_name + f\" {str(i)}\"\n",
        "                attrs.site_source = l337x  \n",
        "                hash = soup.find(class_=\"infohash-box\").span.text.strip()  \n",
        "                if add_hash_download(hash, attrs, select.title):\n",
        "                    i += 1\n",
        "            print(\"Done.\\n\")\n",
        "            return 0\n",
        "        else:\n",
        "            error(f\"An error occured while trying to access 1337x.com  status: {response.status_code}.\")\n",
        "    return -1\n",
        "\n",
        "#### API / Torrent Search\n",
        "\n",
        "def search(Site, Search, attrs, category = '', sort = sort1337x_seeders_desc, rarbg_auto = True, Page = 1):\n",
        "    sts = '1337x' if  Site[0] else 'Rarbg'\n",
        "    sts += ' and Rarbg' if Site[0] and Site[1] else ''\n",
        "    info(f\"Searching for {Search} in {Site[0]}\")\n",
        "    if Site[0] == l337x:\n",
        "        pagestate: int = max(Page, 1)\n",
        "        while pagestate > 0 :\n",
        "            pagestate = search1337x(Search, sort = sort, category = category, page = pagestate, attrs = attrs)\n",
        "        if pagestate == -1 and Site[1]:\n",
        "            print(\"Do you want to repeat search with rarbg? [y '' to confirm.]\\n\")\n",
        "            choice = input()\n",
        "            if choice.lower() == \"y\" or choice == \" \" or choice == \"\":\n",
        "                return\n",
        "    else:\n",
        "        res = []\n",
        "        if res == -1 and Site[1]:\n",
        "            print(\"Do you want to repeat search with 1337x? [y '' to confirm.]\\n\")\n",
        "            choice = input()\n",
        "            if choice.lower() == \"y\" or choice == \" \" or choice == \"\":\n",
        "                page = 1\n",
        "                while page > 0 :\n",
        "                    page = search1337x(Search, sort = sort, category = category,  page = Page, attrs = attrs)\n",
        "\n",
        "def check_download(type_, name):\n",
        "    if type_ == Movie:\n",
        "        name = name_movie(name)\n",
        "        return movie_exists(name)\n",
        "    if type_ == Show:\n",
        "        name = name_show(name)\n",
        "        return show_exists(name)\n",
        "     \n",
        "#### API / File Manager\n",
        "\n",
        "def mv(from_path, to_path, content=None, backup=False, movie_name=False, show_name=False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok=True)\n",
        "        if content:\n",
        "            info(f\"Moving batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to move [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0, len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input()\n",
        "            if ext(inpt):\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)\n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))\n",
        "                        if end > len(content) or start < 0:\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Moving: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            rename = \"\"\n",
        "            if movie_name:\n",
        "                rename = \"/\" + name_movie(content[i])\n",
        "            elif show_name:\n",
        "                rename = \"/\" + name_show(content[i])\n",
        "  \n",
        "            p1 = (from_path + \"/\" + content[i]) if content else from_path\n",
        "            p2 = to_path + rename\n",
        "            info(f\"Moving {p1} to: {p2}\")\n",
        "            os.makedirs(to_path, exist_ok=True)\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            if backup and False:  # fixbackup\n",
        "                info(f\"Processing backup.\")\n",
        "                for i in range(1, 4):\n",
        "                    p11bak = \"bk path\"\n",
        "                    tpbak = \"bk path\"\n",
        "                    if not (p11bak[0] in from_path and tpbak[0] in to_path):\n",
        "                        tp = tpbak[1]\n",
        "                        p11 = p11bak[1]\n",
        "                        p21 = tp + rename\n",
        "                        if os.path.exists(p11):\n",
        "                            os.makedirs(tp, exist_ok=True)\n",
        "                            print(f\"Moving {p11} to {p21}\\n\")\n",
        "                            info(f\"Moving {p11} to {p21}\")\n",
        "                            !mv \"$p11\" \"$p21\"\n",
        "                        else:\n",
        "                            print(f\"Backup {p11} Doesn't exist.\\n\")\n",
        "                            warning(f\"Backup {p11} Doesn't exist.\")\n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(\"Moving done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\")\n",
        "        return\n",
        "\n",
        "def cp(from_path, to_path, content = None, backup = False, movie_name = False, show_name = False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok= True)  \n",
        "        if content:\n",
        "            info(f\"Copying batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to copy [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0 ,len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input()\n",
        "            if ext(inpt):\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)      \n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))      \n",
        "                        if end > len(content) or start < 0 :\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Copying: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            newname  = \"\"\n",
        "            if movie_name:\n",
        "                newname =  name_movie(items[i])\n",
        "            elif show_name:\n",
        "                newname = name_show(items[i]) \n",
        "  \n",
        "            p1 = from_path + \"/\" + content[i] if content else from_path\n",
        "            if newname:\n",
        "                p2 = from_path + \"/\" +  newname if content else os.path.dirname(from_path) + '/' + newname\n",
        "                print(\"  Renaming:  {} to {}\".format(items[i], newname))\n",
        "                !mv \"p1\" \"$p2\"\n",
        "                p1 = p2\n",
        "  \n",
        "            print(f\"Copying:  {p1} to {to_path}\")\n",
        "            info(f\"Copying:  {p1} to {to_path}\")\n",
        "            !rsync -r --size-only  \"$p1\" \"$to_path\"\n",
        "            if backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    p3bak = \"bk path\"\n",
        "                    if not (p3bak[0]in from_path and p3bak[0] in to_path):\n",
        "                        p3 =  p3bak[1]\n",
        "                        os.makedirs(p3, exist_ok= True)\n",
        "                        print(f\"Copying  {p1} to {p3}\\n\")\n",
        "                        info(f\"Copying:  {p1} to {p3}\")\n",
        "                        !rsync -r --size-only \"$p1\" \"$p3\" \n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(f\"Copying done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\\n\")\n",
        "        return\n",
        "    \n",
        "def rename(path, newpath, backup, content = None):\n",
        "    print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "    !mv \"$path\" \"$newpath\" \n",
        "    if backup and False: #fixbackup\n",
        "        for i in range(1,4):\n",
        "            pathbu = \"bk path\"\n",
        "            newpathbu = \"bk\"\n",
        "            if not pathbu[0] in path and os.path.exists(pathbu[1]):\n",
        "                path = pathbu[1]\n",
        "                newpath = newpathbu[1]    \n",
        "                print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "                !mv \"$path\" \"$newpath\"      \n",
        "\n",
        "        int(\"......................\")\n",
        "    print(\"       Done\")\n",
        "    return  \n",
        "  \n",
        "def rm(delpath, process_backup = False, replace = False, content = None, v = False):\n",
        "    if content:\n",
        "        content.sort()\n",
        "        info(f'Deleing files in from: {delpath}\\nProcess backup: {process_backup}')\n",
        "        print(\" Enter directory selection to remove: [s-e],2  '.' = All \")\n",
        "        items: list[int] = []\n",
        "        print_files(content, 0 ,len(content))\n",
        "        print()\n",
        "        start = end = 0\n",
        "        inpt = input()\n",
        "        if ext(inpt):\n",
        "            return\n",
        "        if '.' == inpt:\n",
        "            start = 0\n",
        "            end = len(rng)      \n",
        "        else:\n",
        "            rngs = inpt.split(',')\n",
        "            for rng in rngs:\n",
        "                if '-' in rng:\n",
        "                    rngs = rng.split('-')\n",
        "                    start = int(rngs[0]) - 1\n",
        "                    end = int((rngs[1]))\n",
        "                    items.extend(range(start, end))      \n",
        "                    if end > len(content) or start < 0 :\n",
        "                        print(\"The ranges' ends are out of the directory file range.\")\n",
        "                    continue\n",
        "                else:\n",
        "                    i = int(rng)-1\n",
        "                    items.append(i)\n",
        "  \n",
        "    elif delpath:\n",
        "        info(f'Deleing: {delpath}\\nProcess backup: {process_backup}')\n",
        "        items = [0]\n",
        "    else:\n",
        "        return -1\n",
        "  \n",
        "    if replace:\n",
        "        for i in items:\n",
        "            if v:\n",
        "                print(\"Moving to .replace:  {0}\".format(items[i]))\n",
        "            path = delpath +\"/\"+ content[i] if content else delpath\n",
        "            replace_download(path)\n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt0 = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Moving to .replace:  {pt0}\")\n",
        "                        info(f\"Moving to .replace:  {pt0}\")\n",
        "                        replace_download(pt0)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt0} doesn't exist.\") \n",
        "  \n",
        "    else:\n",
        "        for i in items:\n",
        "            path = delpath + \"/\" + content[i] if content else delpath\n",
        "            if v:\n",
        "                print(f\"Deleting path:  {path}\")\n",
        "            info(f'Deleing path: {path}')\n",
        "            if os.path.exists(path):\n",
        "                rt = !rm -r \"$path\"\n",
        "                if rt:\n",
        "                    error(lines = rt)\n",
        "                    list_lines(rt)\n",
        "            else:\n",
        "                error(f\"{path} doesn't exist.\")\n",
        "                continue\n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Deleting path: {pt}\")\n",
        "                        info(f'Deleing file: {pt}')\n",
        "                        rt = !rm -r \"$pt\"\n",
        "                        if rt:\n",
        "                            error(lines = rt)\n",
        "                            list_lines(rt)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt} doesn't exist.\") \n",
        "        return\n",
        "  \n",
        "def is_cp(name):\n",
        "    return True if contains(checkpoint, name) else False\n",
        "\n",
        "def del_cp(path):\n",
        "    p0 = f\"{path}/{checkpoint}\"\n",
        "    if os.path.exists(p0):\n",
        "        !rm -r \"$p0\"\n",
        "\n",
        "def dircontent(path):\n",
        "    del_cp(path)\n",
        "    return os.listdir(path)\n",
        "\n",
        "sizeDiffers = (1,'Size differs')\n",
        "doesntExist = (2,\"Doesn't Exist\")\n",
        "emptySizeLimit = 40000\n",
        "class Sync_Status:\n",
        "    def __init__(self, path, src: int, message = '', name1 = '', name2 = '', size1 = '', size2 = '', status = doesntExist):\n",
        "        self.path = path\n",
        "        self.src = src\n",
        "        self.message = message\n",
        "        self.name1 = name1\n",
        "        self.name2 = name2\n",
        "        self.size1 = size1\n",
        "        self.size2 = size2\n",
        "        self.status = status\n",
        "\n",
        "def compare_dirs(first, second, sync = False, syncNames = False, delEmpty = False):\n",
        "   info(f'Comparing sync status.\\nFirst path: {first}\\nSecond path: {second}')\n",
        "   if first and os.path.exists(first) and second and os.path.exists(second):\n",
        "       del_cp(first)\n",
        "       del_cp(second)\n",
        "       content1 = os.listdir(first)\n",
        "       content2 = os.listdir(second)\n",
        "       content1.sort()\n",
        "       content2.sort()\n",
        "       synced = []\n",
        "       sync_list: list[Sync_Status] = []\n",
        "       emty1 = emty2 = 0\n",
        "       if content1:\n",
        "           ln1 = len(content1)\n",
        "           ln2 = len(content2)\n",
        "           print(\"         {:<74}{:^43} {:^12}{:^12}{:^14}\\n\".format(\"In Dir 1\", \"In Dir 2\", \"Size in 1\",  \"Size in 2\", 'Sync Status'))\n",
        "           for item in content1:\n",
        "               path1 = f\"{first}/{item}\"\n",
        "               path2 = f\"{second}/{item}\"\n",
        "               size1_raw= pathsize(path1)\n",
        "               size1 = data_str(size1_raw)\n",
        "               size2 = \"\"\n",
        "               exists2 = False\n",
        "               status2 = ''\n",
        "               synced_ = 'Synced'\n",
        "               unsynced_ = 'Unsynced'\n",
        "               recheck = ''\n",
        "               if delEmpty and size1_raw <= emptySizeLimit:\n",
        "                   !rm -r \"$path1\"\n",
        "                   ln1 -= 1\n",
        "                   info(f\"Empty directory deleted {path1}\")\n",
        "                   emty1 += 1\n",
        "                   size1 = 0\n",
        "       \n",
        "               if item in content2:        \n",
        "                   exists2 = True \n",
        "                   status2 = \"Exists\"\n",
        "                   content2.remove(item)       \n",
        "               else:\n",
        "                   recheck = research_name(item, content2)\n",
        "                   if recheck:\n",
        "                       exists2 = True\n",
        "                       content2.remove(recheck)\n",
        "                       path2 = f\"{second}/{recheck}\"\n",
        "                       status2 = f'[{recheck}]'\n",
        "                       info(f\"{item} exists as {recheck} in 2.\")\n",
        "       \n",
        "               if exists2:\n",
        "                   size2_raw = pathsize(path2)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       ln2 -= 1\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1            \n",
        "                       continue\n",
        "       \n",
        "                   if recheck and syncNames:\n",
        "                       info(f\"Renaming {recheck} to {item}\")\n",
        "                       p0 = f\"{second}/{recheck}\"\n",
        "                       p1 = f\"{second}/{item}\"\n",
        "                       ot = !mv \"$p0\" \"$p1\"\n",
        "                       if ot:\n",
        "                           error(ot)\n",
        "                       else:\n",
        "                           path2 = p1\n",
        "                           status2 = 'Renamed'\n",
        "                           info(f\"Item {recheck} renamed to {item} in 2.\")\n",
        "       \n",
        "       \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   diff = False if abs(size1_raw - size2_raw) <= 50000 else True\n",
        "                   if not diff:\n",
        "                       msg = \"    {:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, synced_)\n",
        "                       synced.append(msg)\n",
        "                   else: \n",
        "                       s_status = sizeDiffers[1]\n",
        "                       msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status)\n",
        "                       if  size1_raw > size2_raw:\n",
        "                           status = Sync_Status(path= path1, src= 1, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 1: {path1}, size differs in path 2.\")\n",
        "                       else:\n",
        "                           status = Sync_Status(path= path2, src= 2, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 2: {path2}, size differs in path 1.\")\n",
        "                       sync_list.append(status)\n",
        "               else:\n",
        "                   if not size1:\n",
        "                       continue\n",
        "                   status2 = ''\n",
        "                   s_status = doesntExist[1]\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status )\n",
        "                   status = Sync_Status(path= path1, src= 1, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 1: {path1}, doesn't exist in path 2.\")\n",
        "             \n",
        "           if content2:\n",
        "               for item in content2:                    \n",
        "                   path2 = f'{second}/{item}'\n",
        "                   size2_raw =  pathsize(path2, False)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1\n",
        "                       ln2 -= 1\n",
        "                       continue          \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(\"\", item, '', size2, \"Doesn't Exist\")\n",
        "                   status = Sync_Status(path= path2, src= 2, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 2: {path2}, doesn't exist in path 1.\")\n",
        "     \n",
        "           for item in synced:\n",
        "               print(item)\n",
        "               info(item)\n",
        "     \n",
        "           if sync_list:\n",
        "               sync_list.sort(key= lambda obj: obj.status[0])\n",
        "               for i in range(len(sync_list)):\n",
        "                   item = sync_list[i]\n",
        "                   msg = f\"{str(i + 1)+' - ' if sync else '    '}{item.message}\"\n",
        "                   print(msg)\n",
        "                   info(item.message)\n",
        "                    \n",
        "           msg = f\"\\nTotal items in path 1: {ln1}   Total items in path 2:  {ln2}   Unsynced items: {len(sync_list)}.\\n\"\n",
        "           msg += f\"{f'Deleted empty folders in path 1:  {emty1}  ' if emty1 else ''}{f'Deleted empty folders in path 2:  {emty2}' if emty2 else ''}\\n\"\n",
        "           info(msg)\n",
        "           print(msg)\n",
        "           \n",
        "           if sync and sync_list:\n",
        "               print('Enter a selection for the synchronization:  e.g. i1, i2, i1-i5\\n')\n",
        "               inp = input().strip()\n",
        "               if (ext(inp) or no(inp)):\n",
        "                   return\n",
        "               rngs = []  \n",
        "               if inp == '.':\n",
        "                   rngs.extend(range(len(sync_list)))\n",
        "               else:\n",
        "                   selects = inp.split(',')\n",
        "                   for select in selects:\n",
        "                       try:          \n",
        "                           if '-' in select:\n",
        "                               splt = select.split('-')\n",
        "                               s = int(splt[0]) - 1\n",
        "                               e = int(splt[1])\n",
        "                               rngs.extend(range(s, e))\n",
        "                           else:\n",
        "                               rngs.append(int(select) - 1)\n",
        "                       except Exception as e:\n",
        "                           error(str(e))\n",
        "                           continue\n",
        "               msg = f\"Syncing {first} with {second}.\\nTotal copying items: {len(rngs)}\"\n",
        "               info(msg)\n",
        "               print(msg)\n",
        "               for i in rngs:\n",
        "                   p0 = sync_list[i].path\n",
        "                   p1 = second if sync_list[i].src == 1 else first\n",
        "                   print(f\"Copying: {os.path.basename(p0)} to {p1}\")\n",
        "                   info(f\"Copying: {os.path.basename(p0)} to {p1}\")\n",
        "                   !rsync --size-only -P -h -r \"$p0\" \"$p1\"\n",
        "           print(\"\\n.............\\n    Done\\n\")\n",
        "   else:\n",
        "       msg = f\"{first} {'exists' if os.path.exists(first) else 'does not exist'}\\n{second} {'exists' if os.path.exists(second) else 'does not exist'}\"\n",
        "       error(msg)\n",
        "\n",
        "def research_name(key, content2):\n",
        "    key = key.strip()\n",
        "    if key:\n",
        "        key = os.path.splitext(key)[0]\n",
        "        keytrans = transstring(key)\n",
        "        ln = len(keytrans)\n",
        "        if ln >= 15:\n",
        "            for i in range(len(content2)):\n",
        "                trans = transstring(os.path.splitext(content2[i])[0])\n",
        "                ln1 = len(trans)\n",
        "                if ln1 < 15:\n",
        "                    continue\n",
        "                if ln1 <= ln:\n",
        "                    n0 = trans  \n",
        "                    n1 = keytrans\n",
        "                else:\n",
        "                    n0 = keytrans\n",
        "                    n1 = trans\n",
        "                if contains(n1, n0):\n",
        "                    return content2[i]\n",
        "    return False\n",
        "\n",
        "def mt(path, bd = None, ad = None, backup = False, prompt = False):\n",
        "    if not (bd or ad):\n",
        "        return\n",
        "    info(f'Deleing files dated before {datetime.fromtimestamp(bd).strftime(\"%Y-%m-%d\")} in {path}')\n",
        "    files = next(os.walk(path))[2]\n",
        "    check = bd and ad\n",
        "    filter = []\n",
        "    for file in files:\n",
        "        p0 = os.path.join(path, file)\n",
        "        md = os.path.getmtime(p0)\n",
        "        if (check and md <= bd and md >= ad) or (bd and md <= bd) or (ad and md >= ad):\n",
        "            dstr = datetime.fromtimestamp(md).strftime('%Y-%m-%d')\n",
        "            size = data_str(os.path.getsize(p0))\n",
        "            msg = f'{dstr} - {size} {file}'\n",
        "            info(msg)\n",
        "            print(msg)\n",
        "            if prompt:\n",
        "                filter.append(file)\n",
        "                continue         \n",
        "            info(f\"Deleting {p0}..\")\n",
        "            rm(p0, backup, False)\n",
        "    if prompt:\n",
        "        rm(delpath= path, process_backup= backup, content= filter)\n",
        "    print('..... Done .....\\n')\n",
        "\n",
        "def check_sd_base(path):\n",
        "  lookup = re.search(sd_re, path)\n",
        "  if lookup:\n",
        "      p0 = lookup.group()  \n",
        "      if os.path.exists(p0):\n",
        "          return p0\n",
        "  return False\n",
        "\n",
        "def makedirs(path, backup = False):\n",
        "    if path:\n",
        "        info(f\"Creating dir: {path}\")\n",
        "        os.makedirs(path, exist_ok = True)\n",
        "    if backup and False: #fixbackup\n",
        "        for i in range(1, 4):\n",
        "            nd = \"bk path\"\n",
        "            np = nd[1]\n",
        "            check = check_sd_base(np)\n",
        "            if check:\n",
        "                info(f\"Creating backup dir: {np}\")\n",
        "                os.makedirs(nd, exist_ok = True)\n",
        "            else:\n",
        "                warning(f\"{nd[0]} doesn't exist.\")\n",
        "\n",
        "def clean_general(Type) :\n",
        "    dirs = next(os.walk(general_path))[1]\n",
        "    if checkpoint in dirs: dirs.remove(checkpoint)\n",
        "    for name in dirs:\n",
        "        newname = \"\"\n",
        "        p1 = general_path + \"/\" + name\n",
        "        p0 = general_path\n",
        "        if not os.path.isdir(p1):\n",
        "            p0 = general_path + \"/\" + os.path.splitext(name)[0]\n",
        "            os.makedirs(p0, exist_ok= True)\n",
        "            !mv \"$p1\" \"$p0\"\n",
        "            p1 = p0\n",
        "\n",
        "        if Type == Movie:\n",
        "            newname = name_movie(name)\n",
        "            save_path = movies_path\n",
        "            after_shave(p1, newname)\n",
        "        elif Type == Show:\n",
        "            newname = name_show(name)\n",
        "            clean_tvshow(p1)\n",
        "            save_path = tv_path\n",
        "            check = save_path + \"/\" + newname\n",
        "        elif Type == Season:\n",
        "            newname = get_season(name)\n",
        "            if not newname:\n",
        "                newname = name\n",
        "            show = name_show(name)\n",
        "            clean_season(p1)\n",
        "            save_path= path_tvshow(show)\n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        elif Type == Episode:\n",
        "            newname = name_episode(name)\n",
        "            show = name_show(name)\n",
        "            season= get_season(name)\n",
        "            if not season:\n",
        "                season = name\n",
        "            save_path= path_season(show, season) \n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        else:\n",
        "            save_path = general_path\n",
        "        if newname:\n",
        "            p2 = general_path + \"/\" + newname\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "        else:\n",
        "            p2 = p2 + name\n",
        "\n",
        "        if Type == Episode and os.path.isdir(p2):\n",
        "            clean_season(p2)\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\" \n",
        "\n",
        "        if Type == Show and os.path.isdir(check):\n",
        "            save_path = check\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\"\n",
        "\n",
        "        !mv \"$p2\"* \"$save_path\"\n",
        "        if p02 and os.path.exists(p02): \n",
        "            !rm -r \"$p02\"\n",
        "      \n",
        "def clean_path(type_, path, process_backup = False, keepdot = False, multi = False, delete_empty = False, clean = True):\n",
        "    if multi:\n",
        "        if type_ == Movie:\n",
        "            if path :\n",
        "                print(f\"Cleaning movie library path: {path}\")  \n",
        "                clean_movies_dir(path, v = True, backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "            else:\n",
        "                clean_movies_dir(v = True, backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "\n",
        "        elif type_ == Show:\n",
        "            print(f\"Cleaning TV library path: {tv_path}\")\n",
        "            clean_tvshows()\n",
        "            if process_backup:\n",
        "                for pt in tvbackups:\n",
        "                    print(f\"Cleaning backup TV library path: {pt}\")\n",
        "                    clean_tvshows(pt)\n",
        "\n",
        "    else:\n",
        "            if type_ == Movie:\n",
        "                if path and os.path.exists(path):\n",
        "                        name = path.split(\"/\")[-1]\n",
        "                        print(f\"Cleaning movie: {path}\")\n",
        "                        clean_movie(path, name)\n",
        "\n",
        "                        if process_backup and False: #fixbackup\n",
        "                            for dir in movies_basenames:\n",
        "                                path = \"bk path\"\n",
        "                                if os.path.exists(path):\n",
        "                                    print(f\"Cleaning movie: {path}\")\n",
        "                                    clean_movie(path, name)\n",
        "                                else: \n",
        "                                    warning(f\"Backup path: {path} doesn't exist.\")\n",
        "                                    print(f\"Backup path: {path} doesn't exist.\")\n",
        "\n",
        "            elif type_ == Show:\n",
        "                if path and os.path.exists(path):\n",
        "                        print(f\"Cleaning show path: {path}\")\n",
        "                        clean_tvshow(path, keepdot)\n",
        "                        if process_backup and False: #fixbackup\n",
        "                            for dir in tv_basenames:\n",
        "                                    path = \"bk path\"\n",
        "                                    if os.path.exists(path):          \n",
        "                                        print(f\"Cleaning backup Show path: {path}\")\n",
        "                                        clean_tvshow(path, keepdot)\n",
        "                                    else:\n",
        "                                        warning(f\"Backup path: {path} doesn't exist.\")\n",
        "                                        print(f\"Backup path: {path} doesn't exist.\")              \n",
        "\n",
        "#### API / Download files utils\n",
        "\n",
        "def clean_download_destination(attrs: DownloadAttrs):\n",
        "    info(f'Cleaning distination for: {attrs.save_name}')\n",
        "    attrs.old_files = set()\n",
        "    delstr = '.del' + nowstr()\n",
        "    if 1 <= attrs.type_/TV < 1.1 :\n",
        "        for file in attrs.downloaded:\n",
        "            lookup1 = episode_exists(attrs.show, get_season(file[0]), file[0])\n",
        "            if lookup1 and lookup1[2]:\n",
        "                p0 = lookup1[2] \n",
        "                p1 = os.path.dirname(p0) + '/' + delstr\n",
        "                if not os.path.isdir(p1):\n",
        "                    os.makedirs(p1)\n",
        "                info(f'Moving: {p0} to {p1}')\n",
        "                rt = !mv \"$p0\" \"$p1\"\n",
        "                if rt:\n",
        "                    error(lines = rt)\n",
        "                list_lines(rt)          \n",
        "                attrs.old_files.add(p1)\n",
        "                info(f'Old file added: {lookup1[0]}')\n",
        "                if attrs.backup and False: #fixbackup\n",
        "                    for i in range(1,4):\n",
        "                        p01 =\"bk\"\n",
        "                        if os.path.exists(p0):\n",
        "                            p11 = \"bk\"\n",
        "                            if not os.path.isdir(p11):\n",
        "                                os.makedirs(p11)\n",
        "                            info(f'Moving: {p01} to {p11}')\n",
        "                            rt = !mv \"$p01\" \"$p11\" \n",
        "                            if rt:\n",
        "                                info(lines = rt)\n",
        "                                list_lines(rt) \n",
        "\n",
        "    elif attrs.type_ == Movie:\n",
        "        p0 = attrs.existing_file \n",
        "        p1 = os.path.dirname(p0) + '/' + delstr\n",
        "        os.makedirs(p1, exist_ok = True)\n",
        "        info(f'Moving: {p0} to {p1}')\n",
        "        rt = !mv \"$p0\" \"$p1\"\n",
        "        if rt:\n",
        "            info(lines = rt)\n",
        "            list_lines(rt)\n",
        "        attrs.old_files.add(p1)\n",
        "        info(f'Old file added: {attrs.existing_file}')\n",
        "        if attrs.backup and False: #fixbackup\n",
        "            for i in range(1,4):\n",
        "                p01 = \"bk\"\n",
        "                if os.path.exists(p0):\n",
        "                    p11 = \"bk\"\n",
        "                    if not os.path.isdir(p11):\n",
        "                        os.makedirs(p11)\n",
        "                    info(f'Moving: {p01} to {p11}')\n",
        "                    rt = !mv \"$p01\" \"$p11\" \n",
        "                    if rt:\n",
        "                        info(lines = rt)\n",
        "                        list_lines(rt)\n",
        "    else:\n",
        "        return  \n",
        "    info('Cleaning distination done.')\n",
        "    \n",
        "def pre_download_transfer(attrs: DownloadAttrs, path):\n",
        "    if not attrs.save_dir:\n",
        "        attrs.save_dir = attrs.save_path if attrs.type_ == Episode else attrs.save_path + '/' + attrs.save_name \n",
        "    attrs.verify_download = []\n",
        "    info(f\"Preparing transfer for: {path}\\nSave dir: {attrs.save_dir}\")\n",
        "    size = 0  \n",
        "    for item in attrs.downloaded:\n",
        "        p01 = '/' + item[0] if item[0] else ''\n",
        "        base = path + p01\n",
        "        to_base = attrs.save_dir + p01\n",
        "        info(f\"    .{base}/\")\n",
        "        for file in item[1]:\n",
        "            p02 = base + '/' + file\n",
        "            s01 = pathsize(p02)\n",
        "            size += s01\n",
        "            p03 = to_base + '/' + file\n",
        "            attrs.verify_download.append((p02, p03))\n",
        "            info(f'({data_str(s01)}) {p02}\\n           {p03}\\nVerification item added.')\n",
        "    DownloadAttrs.total_downloaded = size \n",
        "\n",
        "def verify_saving_download(attrs: DownloadAttrs):\n",
        "    fails = []\n",
        "    info(f\"Verifying downloaded files for: {DownloadAttrs.save_name}\\nTotal downloaded: {data_str(attrs.total_downloaded)}\")\n",
        "    for i in range(len(attrs.verify_download)):\n",
        "        item = attrs.verify_download[i]\n",
        "        s1 = has_size(item[0], False)\n",
        "        s2 = has_size(item[1], False)\n",
        "        info(f\"Verifying: ({'Does not exist.' if s1 == -1 else s1}) {item[0]}\\n       To: ({'Does not exist.' if s2 == -1 else s2}) {item[1]}\")\n",
        "        if s2 != -1 and abs(s2-s1) <= size_limit:\n",
        "            info('Successfully transfered.')\n",
        "        else:\n",
        "            info('Not transfered.')\n",
        "            fails.append(item[1])\n",
        "    if len(fails) == 0:\n",
        "        info(f\"Successful transfer verification.\")\n",
        "        return True\n",
        "    else:\n",
        "        error(f\"Verification failed.\\nFailed items: {len(fails)}\\n{list_lines(fails, str = True)}\")\n",
        "    return False\n",
        "\n",
        "def revert_download_file_transfer(delpaths, backup):\n",
        "    info('Reverting transfered files.')\n",
        "    for path in delpaths:\n",
        "        path0 = path + '/*'\n",
        "        path1 = re.sub(del_re, '', path)\n",
        "        mv(path0, path1, backup = backup)\n",
        "    return\n",
        "\n",
        "def transfer_download_files(handle, copy = False, v = False):\n",
        "    handle.pause()\n",
        "    attrs: DownloadAttrs = handle.attrs\n",
        "    status = handle.status()\n",
        "    name = status.name\n",
        "    p1 = status.save_path + \"/\" + name\n",
        "    p0 = status.save_path\n",
        "    info(f'Transfering files for: {name}\\nNewname: {attrs.save_name}')\n",
        "    p2 = done_path + \"/\" + attrs.save_name\n",
        "    if os.path.exists(p1):\n",
        "        single = not os.path.isdir(p1)\n",
        "        if single:\n",
        "            info(f'The download is a single file without a directory\\nMoving the download into a directory with the same name.')\n",
        "            p0 = status.save_path + \"/\" + os.path.splitext(name)[0]\n",
        "            os.makedirs(p0, exist_ok = True)\n",
        "            if not copy:\n",
        "                info(f'Moving {p1} to {p0}')\n",
        "                !mv \"$p1\" \"$p0\"\n",
        "            else:\n",
        "                info(f'Copying {p1} to {p0}')\n",
        "                !cp \"$p1\" \"$p0\"\n",
        "            p1 = p0 \n",
        "        shave_download(handle, p0, p1)\n",
        "        clean_download(attrs, path = p1)\n",
        "        if (not copy) or single:\n",
        "            if v:\n",
        "                  print(f\"Moving {p1} to {p2}\")\n",
        "            info(f'Moving to done path with the new name\\n {p1} to {p2}')\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "        else:\n",
        "            if v:\n",
        "                  print(f\"Copying {p1} to {p2}\")\n",
        "            info(f'Copying to done path with the new name\\n {p1} to {p2}')  \n",
        "            !cp -r \"$p1\" \"$p2\"\n",
        "    else:\n",
        "        m = f\"Download folder {p1} is missing.\"\n",
        "        error(m, v = False)\n",
        "        release()\n",
        "        raise(m)  \n",
        "    if not attrs.save_name:\n",
        "        attrs.save_name = name\n",
        "        p2 = p2 + attrs.save_name  \n",
        "    pre_download_transfer(attrs, p2)  \n",
        "    if attrs.type_ == Episode and os.path.isdir(p2):\n",
        "        p2 = p2 + \"/\"     \n",
        "    if os.path.exists(p2):\n",
        "        if attrs.replace and attrs.downloaded:\n",
        "            clean_download_destination(attrs) \n",
        "        if v:\n",
        "            print(f\"Copying {p2} to {attrs.save_path}\")\n",
        "\n",
        "        info(f'Saving {attrs.save_name} to: {attrs.save_path}')\n",
        "        msg = !rsync --size-only -r \"$p2\" \"$attrs.save_path\"\n",
        "        if msg:\n",
        "            error(lines = msg)\n",
        "            list_lines(msg)\n",
        "            main_verification = False\n",
        "        else:\n",
        "            main_verification = verify_saving_download(attrs)   \n",
        "        if attrs.backup:\n",
        "            for bk in attrs.baksv:\n",
        "                if v:\n",
        "                    print(f\"Copying {p2} to {bk}\")\n",
        "                info(f'Copying {attrs.save_name} to: {bk}')\n",
        "                msg = !rsync --size-only -r \"$p2\" \"$bk\"\n",
        "                if msg:\n",
        "                    error(lines = msg)\n",
        "                    list_lines(msg) \n",
        "        if main_verification:\n",
        "            if v:\n",
        "                print(f\"Deleting {p2}\")\n",
        "            info(f'Deleting {p2}')\n",
        "            !rm -r \"$p2\"    \n",
        "            if attrs.uncomplete_source and os.path.exists(attrs.uncomplete_source):\n",
        "                if v:\n",
        "                    print(f\"Deleting uncompleted source: {attrs.uncomplete_source}\")\n",
        "                info(f'Deleting uncompleted source: {attrs.uncomplete_source}')\n",
        "                !rm -r \"$attrs.uncomplete_source\"  \n",
        "            if attrs.replace and attrs.old_files:\n",
        "                info('Deleting replaced files.')\n",
        "                for p in attrs.old_files:\n",
        "                    rm(p, process_backup = attrs.backup) \n",
        "\n",
        "            info(f'Done saving {attrs.save_name}.')\n",
        "            return True   \n",
        "        else:\n",
        "            print(\"Transfer verification failed.\")\n",
        "            if attrs.replace and attrs.old_files:\n",
        "                revert_download_file_transfer(attrs.old_files, attrs.backup)\n",
        "            return False\n",
        "    else:\n",
        "        error(f\"Files for: {attrs.save_name} were not transfered.\")\n",
        "        return False\n",
        "\n",
        "def save_download_progress(handle, savepath):\n",
        "    status = handle.status()\n",
        "    name = status.name\n",
        "    info(f\"Saving download progress for {name}\")\n",
        "    os.makedirs(savepath, exist_ok = True)\n",
        "    p0 = temp_save +\"/\"+ name\n",
        "    p1 = f\"{savepath}/{name}\"\n",
        "    if os.path.exists(p1):\n",
        "        name2 = name + \"@SAVE2\"\n",
        "        p1 = f\"{savepath}/{name2}\"\n",
        "    print(\"\\nSaving {0} into    {1}\\n\".format(name, p1))\n",
        "    !cp -r \"$p0\" \"$p1\"\n",
        "    info(f\"Done saving download progress for {name}.\")\n",
        "  \n",
        "def save_downloads_progress(savepath):\n",
        "    if active:\n",
        "        print(\" Choose a download to save progress , q to exit:\\n\")\n",
        "        for i in range(len(active)):\n",
        "            print(\"   {0}-  {1}\".format(i+1, active[i].name))\n",
        "        print()\n",
        "        inpt =  input().lower()\n",
        "        if inpt == '' or inpt == \" \" or inpt == 'q' or inpt == \"s\":\n",
        "            return\n",
        "        if \",\" in inpt:\n",
        "            choices = inpt .split(\",\")\n",
        "        else:\n",
        "            choices = [inpt]    \n",
        "        for choice in choices:\n",
        "            try:\n",
        "                choice = int(choice) - 1\n",
        "            except Exception as e:\n",
        "                error(str(e), 'save_downloads')\n",
        "                continue\n",
        "            if(choice >= len(active) or choice < 0):\n",
        "                print(\"\\nThe choice is out of range.\\n\")\n",
        "            else:\n",
        "                save_download_progress(active[choice], savepath)\n",
        "            print(\"..................\")\n",
        "            print(\"      Done\\n\")\n",
        "\n",
        "def load_uncompleted(path, type_ = Movie, local = False):\n",
        "    (path, files, dirs) = next(os.walk(path))\n",
        "    content = filter_checks(dirs) + files\n",
        "    if content:\n",
        "        print(\" Choose a directory or a file to load:\")\n",
        "        for i in range(len(content)):\n",
        "            p00 = f\"{path}/{content[i]}\"\n",
        "            size = pathsize(p00, True)\n",
        "            print(\"   {}- {:<90}{}\".format(i+1, content[i], size))\n",
        "        print()\n",
        "        choice = input().lower()\n",
        "        if \"\" == choice or \" \" == choice or  \"q\" == choice or \"s\" == choice:\n",
        "            return\n",
        "        elif \",\" in choice:\n",
        "            choices = choice.split(\",\")\n",
        "        else:\n",
        "            choices = [choice]\n",
        "        for select in choices:\n",
        "            select = int(select) - 1\n",
        "            if select >= len(content) or select < 0 :\n",
        "                print(\"\\nThe choice is out of range.\\n\")\n",
        "            else:\n",
        "                name = content[select]\n",
        "                if not local:\n",
        "                    p0 = f\"{path}/{name}\"\n",
        "                    if content[select].endswith(\"@SAVE2\"):\n",
        "                        name = content[select].split(\"@SAVE2\")[0]\n",
        "                    p1 = f\"{temp_save}/{name}\"\n",
        "                    info(f\"Loading uncompleted download: {content[select]} to {p1}\")\n",
        "                    print(\"Loading into {}\\n\".format(p1))\n",
        "                    !cp -r \"$p0\" \"$p1\"\n",
        "                    print(\"{0} is Loaded\\n\".format(content[select]))\n",
        "                    info(f\"Uncompleted download: {content[select]} loaded to {p1}\")\n",
        "                attrs = DownloadAttrs(type_= type_, name = name)\n",
        "                r = resume_download(name) \n",
        "                if r == -2:\n",
        "                    break\n",
        "                print(\"\\n   ...................\\n          Done\\n\")\n",
        "    else:\n",
        "        error(\"Uncomplete directory is empty.\")\n",
        "\n",
        "def resume_download(attrs):\n",
        "    info(f\"Resuming download {attrs.name}\")\n",
        "    lookup = name_movie(attrs.name)\n",
        "    print(f\"Downloading: {lookup}\\nSelect a source:\\n 1 - 1337x\\n 2 - rarbg\\n\")\n",
        "    select = input().lower()\n",
        "    if select == \"s\" or select == \"\":\n",
        "        return -1\n",
        "    elif select == \"q\" or select == \" \":\n",
        "        return -2\n",
        "    elif select == \"1\":\n",
        "        attrs.site_source = l337x\n",
        "        search((l337x, True), Search = lookup,  attrs= attrs)\n",
        "    elif select == \"2\":\n",
        "        attrs.site_source = rarbg\n",
        "        search((rarbg, True), Search = lookup,  attrs= attrs,  rarbg_auto = True)\n",
        "    return 0\n",
        "\n",
        "#### API / Session setup\n",
        "\n",
        "downloads_dict = {}\n",
        "active = []\n",
        "completed = [] \n",
        "uncompleted = []\n",
        "watched_movies_list = []\n",
        "watched_list_url = \"https://www.imdb.com/search/title/?title_type=feature&lists=ls047519430&view=simple&sort=alpha,asc&count=250&start=\"\n",
        "\n",
        "def enablelt(v= False):\n",
        "    global downloads_dict, active, completed, uncompleted\n",
        "    if  not 'ses' in globals():\n",
        "        global ses\n",
        "        ses = lt.session()\n",
        "        User_Agent = '\"Utorrent\"/3.5.5' \n",
        "        sett = {'allow_multiple_connections_per_ip': True, 'active_downloads': config.activedownloads, 'active_seeds':1, 'active_checking': 3, 'active_limit':10, 'announce_to_all_tiers': True, 'announce_to_all_trackers':True, 'allow_multiple_connections_per_ip':True, 'auto_sequential':True, 'auto_manage_interval': 30, 'connections_limit':2330, 'connection_speed': 80, 'connections_slack':50, 'close_redundant_connections':True, 'file_pool_size':20, 'local_service_announce_interval':200, 'max_rejects':8, 'max_peerlist_size': 5000, 'max_paused_peerlist_size': 2000, 'max_failcount':3, 'min_announce_interval':30, 'min_reconnect_time': 20, 'peer_timeout':20, 'request_timeout':10, 'half_open_limit': 100, 'send_buffer_watermark':5*1024*1024, 'strict_end_game_mode':True, 'seed_time_limit': 60, 'tracker_completion_timeout':30, 'upload_rate_limit':0} #'user_agent': User_Agent,'inactivity_timeout':20, 'ban_web_seeds':False,\n",
        "        ses.apply_settings(sett)\n",
        "        if v:\n",
        "            print(\"LT Client session started.\")\n",
        "        info(f\"LT Client session started. Listening ports: 6881, 6891. User agent: {User_Agent}, Active downloads: {config.activedownloads}.\")\n",
        "        info(f\"Rarbg token is {token}\") \n",
        "        for item in uncompleted_sources:\n",
        "            if v:\n",
        "                print(f\"Uncomplete source: {item}\")\n",
        "\n",
        "### UI API\n",
        "\n",
        "gethtmltitle = lambda text, titlenumber, style=\"\": f'<h{titlenumber} style=\"{style}; font-family: {fontfamily}\">{text}</h{titlenumber}>'\n",
        "def gethtmltext(text, tag= \"span\", elid=\"\", elclass= \"\", fontsize= \"32px\", style= \"\", animated= False):\n",
        "    animation = getcssblinkanimation(color= accentcolor, elementid='el' + nowstr()) if animated else ''\n",
        "    return f'<{tag} id=\"{elid}\" class=\"{elclass}\" style=\"font-size: {fontsize}; {style}\">{text}</{tag}>{animation}'\n",
        "\n",
        "accentcolor = '#085fb1'\n",
        "succusscolor = '#039129'\n",
        "failcolor = '#9c0909'\n",
        "loadingcolor = ''\n",
        "\n",
        "fontfamily = 'system-ui'\n",
        "messagecontainerhight = '250px'\n",
        "messagecontainerpadding = '15% 0 0 0'\n",
        "\n",
        "def hideview(obj):\n",
        "    obj.layout.display = 'none'\n",
        "\n",
        "def showview(obj):\n",
        "    obj.layout.display = 'flex'\n",
        "\n",
        "def switchview(container, nextview = None, temp= False, allowback = True):\n",
        "    if container == None:\n",
        "        return\n",
        "    if container.viewstack:\n",
        "        if nextview:\n",
        "            if temp:\n",
        "                nextview.temp = True\n",
        "            else:\n",
        "                nextview.temp = False\n",
        "                container.viewstack.append(nextview)\n",
        "            container.children = (nextview,)\n",
        "            if allowback:\n",
        "                container.back_button.disabled = False\n",
        "            else:\n",
        "                container.back_button.disabled = True\n",
        "\n",
        "        elif len(container.viewstack) >= 1:\n",
        "            if len(container.viewstack) > 1 and not container.children[0].temp:\n",
        "                container.viewstack.pop(-1)\n",
        "            container.children = (container.viewstack[-1],)\n",
        "            if len(container.viewstack) == 1:\n",
        "                container.back_button.disabled = True\n",
        "\n",
        "def validateconfig():\n",
        "    return True\n",
        "\n",
        "def saveuploadedfiles():\n",
        "    os.makedirs('uploadedfiles', exist_ok= True)\n",
        "    files= set()\n",
        "    try:\n",
        "        for filename in t4source_file.value:\n",
        "            content= t4source_file.value[filename]['content']\n",
        "            filepath= f'/content/uploadedfiles/{filename}'\n",
        "            with open(filepath, 'wb') as savefile:\n",
        "                savefile.write(content)\n",
        "                files.add(filepath)\n",
        "    except Exception as e:\n",
        "        error(e)\n",
        "        print(e)\n",
        "    return files\n",
        "\n",
        "def selectallfiles(files: list[DownloadFile]):\n",
        "    doselect = False\n",
        "    for file in files:\n",
        "        if not file.selected:\n",
        "            doselect = True\n",
        "            break\n",
        "    if doselect:\n",
        "        for file in files: file.selected = True\n",
        "    else:\n",
        "        for file in files: file.selected = False\n",
        "    \n",
        "sn_in = r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\"\n",
        "sn_nm = r\"([1-9][0-9]?)\"\n",
        "\n",
        "def getfileselectionwithstr(files: list[DownloadFile], selectionstr = \"\"):\n",
        "    if not selectionstr:\n",
        "        return False\n",
        "    includerange = []\n",
        "    excluderange = []\n",
        "    seasonselectionstr = \"\"\n",
        "    if ',' in selectionstr:\n",
        "        inputs = selectionstr.split(',')\n",
        "    else:\n",
        "        inputs = [selectionstr]   \n",
        "    try: \n",
        "        for i  in inputs:\n",
        "            i = i.strip()\n",
        "            if i[0] == 's' or i[0] == 'S':\n",
        "                lookup = re.search(sn_in, i)\n",
        "                if lookup:\n",
        "                    if '-' in i:\n",
        "                        rng = i.split('-')\n",
        "                        lookup1 = re.search(sn_nm, rng[0])\n",
        "                        start = lookup1.group() if lookup1 else ''\n",
        "                        lookup1 = re.search(sn_nm, rng[1])\n",
        "                        end = lookup1.group() if lookup1 else ''\n",
        "                        if not (start or end):\n",
        "                            continue\n",
        "                        elif start and end:\n",
        "                            add = list(range(int(start), int(end) + 1))\n",
        "                        elif start:\n",
        "                            add = [int(start)]\n",
        "                        else:\n",
        "                            add = [int(end)]\n",
        "                    else:\n",
        "                        lookup1 = re.search(sn_nm, i)\n",
        "                        if lookup1:\n",
        "                            add = [int(lookup1.group())]\n",
        "                    si2 = 0\n",
        "                    if seasonselectionstr:\n",
        "                        seasonselectionstr += '|'\n",
        "                    for item in add:\n",
        "                        sep = '|' if 0 < si2 < len(add) else ''\n",
        "                        zero = '0?' if item < 10 else '' \n",
        "                        seasonselectionstr += f'{sep}({zero}{item})' \n",
        "                        si2 += 1                      \n",
        "\n",
        "            elif i.lower().startswith('n:'):\n",
        "                i = i[2:]\n",
        "                if '-' in i:\n",
        "                    rng = i.split('-')\n",
        "                    excluderange.extend(range(int(rng[0])-1, int(rng[1])))\n",
        "                else:\n",
        "                    excluderange[0].append(int(i))\n",
        "\n",
        "            else:\n",
        "                if '-' in i :\n",
        "                    rng = i.split('-')\n",
        "                    includerange.extend(range(int(rng[0])-1, int(rng[1])))          \n",
        "                else:\n",
        "                    includerange[0].append(int(i))\n",
        "    except Exception as end:\n",
        "        error(str(end))\n",
        "\n",
        "    seasonselectionstr =  r\"\\b\" + f\"[Ss]({seasonselectionstr})\" + r\"(?=[Ee]|\\s|\\.)\" if seasonselectionstr else \"\"\n",
        "    includes = True if len(includerange) >= 1 or seasonselectionstr else False \n",
        "    excludes = True if len(excluderange) >= 1 else False \n",
        "    for file in files:\n",
        "        i = file.index\n",
        "        if excludes and (i in excluderange):\n",
        "            file.selected = False\n",
        "        elif includes:\n",
        "            if (seasonselectionstr and re.search(seasonselectionstr, file.name)) or (i in includerange):\n",
        "                file.selected = True\n",
        "            else:\n",
        "                file.selected = False\n",
        "\n",
        "def process_adddownload_result(addfunc):\n",
        "    try:\n",
        "        result: AddResult = addfunc()\n",
        "        resultview = getaddresultsubview(result)\n",
        "        info('got result')\n",
        "        if result.status == addsuccuss:\n",
        "            info('getting result view and files')\n",
        "            children = (resultview, getfileselectionsubview(result))\n",
        "            info('launching view')\n",
        "            create_active_view(result.handle)\n",
        "            info('view done')\n",
        "            if not appstate.monitoralive or not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
        "                info('launching monitor') \n",
        "                appstate.monitoralive = True\n",
        "                appstate.monitorthread = threading.Thread(target= monitoractivedownloads, args= ())\n",
        "                appstate.monitorthread.start()\n",
        "                info('monitor started')\n",
        "        else:\n",
        "            children = (resultview,)\n",
        "        t4r2view2_addresult_vbox.children = children\n",
        "        switchview(t4_vbox.maincontainer, t4r2view2_addresult_vbox)\n",
        "        appstate.addalive = False\n",
        "        release()\n",
        "        \n",
        "    except Exception as e:\n",
        "        err = str(e) + '\\n' + traceback.format_exc()\n",
        "        error(err)\n",
        "        release()\n",
        "\n",
        "def saveconfhandler(button):\n",
        "    switchview(t1_vbox.maincontainer, getloadingview(f'Setting up requirments'), temp= True, allowback= False)\n",
        "    config.ltenabled = view1r1v1lttoggle_checkbox.value\n",
        "    config.activedownloads = view1r1v1activedownload_numeric.value\n",
        "    config.ftpenabled = view1r1v2ftptoggle_checkbox.value\n",
        "    if config.ftpenabled:\n",
        "        config.ftphost = view1r1v3ftphost_text.value \n",
        "        config.ftpuser = view1r1v3ftpuser_text.value \n",
        "        config.ftppassword = view1r1v3ftppass_text.value \n",
        "    config.gdriveenabled = view1r1v2gdrivetoggle_checkbox.value\n",
        "    if config.gdriveenabled  and env_colab:\n",
        "        enablegdrive()\n",
        "    config.localdownloadbase = view1r2v1localbase_text.value.strip()\n",
        "    config.remotedownloadbase = view1r2v1remotebase_text.value.strip()\n",
        "\n",
        "    global general_path, movies_path, tv_path, music_path\n",
        "    general_path = view1r2v2generallib_text.value.strip()\n",
        "    movies_path = view1r2v3movielib_text.value.strip()\n",
        "    tv_path = view1r2v3tvlib_text.value.strip()\n",
        "    music_path = view1r2v2musiclib_text.value.strip()\n",
        "\n",
        "    bkgeneral = view1r3v2bkgenerallib_text.value.strip()\n",
        "    if bkgeneral: generalbackups.add(bkgeneral)\n",
        "\n",
        "    bkmovie = view1r3v3bkmovielib_text.value.strip()\n",
        "    if bkmovie: moviesbackups.add(bkmovie)\n",
        "\n",
        "    bktv = view1r3v3bktvlib_text.value.strip()\n",
        "    if bktv: tvbackups.add(bktv)\n",
        "\n",
        "    bkmusic = view1r3v2bkmusiclib_text.value.strip()\n",
        "    if bkmusic: musicbackups.add(bkmusic)\n",
        "    \n",
        "    if validateconfig():\n",
        "        setupreqs()\n",
        "        setuppathes()\n",
        "        if general_path:\n",
        "            checkuncompletesources()\n",
        "        if config.ltenabled:\n",
        "            enablelt()\n",
        "            scrape_watched_movies_list(2)\n",
        "        setpatheshtml()\n",
        "        view1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved.\", fontsize='14px', style= saveconfstyle) \n",
        "    switchview(t1_vbox.maincontainer)\n",
        "\n",
        "def saveconffilehandler(button):\n",
        "    view1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved to file.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "def loadconffilehandler(button):\n",
        "    view1r5saveconfoutput_html.value = gethtmltext(\"Configuration loaded.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "# Add handlers\n",
        "\n",
        "def addsource_change(obj):\n",
        "    newval = t4addsourcetype_dropdown.value\n",
        "    if newval == upload_addsource:\n",
        "        t4source_text.layout.display = \"none\"\n",
        "        t4source_file.layout.display = \"flex\"\n",
        "        t4sourcefile_labelhbox.layout.display = \"flex\"\n",
        "        return\n",
        "    if t4source_text.layout.display == \"none\":\n",
        "        t4source_text.layout.display = \"flex\"\n",
        "        t4source_file.layout.display = \"none\"\n",
        "        t4sourcefile_labelhbox.layout.display = \"none\"\n",
        "    if newval == magnet_addsource:\n",
        "        t4source_text.description = \"Download magnet\"\n",
        "    elif newval == hash_addsource:\n",
        "        t4source_text.description = \"Download hash\"\n",
        "    elif newval == localfile_addsource:\n",
        "        t4source_text.description = \"Local file path\"\n",
        "    elif newval == fileurl_addsource:\n",
        "        t4source_text.description = \"Download file URL\"\n",
        "\n",
        "def addinput_change(val):\n",
        "    if len(t4source_text.value.strip()) > 0:\n",
        "        if t4add_button.disabled:\n",
        "            t4add_button.disabled = False\n",
        "    else:\n",
        "        if not t4add_button.disabled:\n",
        "            t4add_button.disabled = True\n",
        "\n",
        "def addfile_change(val):\n",
        "    t4add_button.disabled = False\n",
        "\n",
        "def adddownload_handler(obj):\n",
        "    addsource = t4addsourcetype_dropdown.value\n",
        "    switchview(t4_vbox.maincontainer, getloadingview(f'Adding download with {addsource}'), temp= True)\n",
        "    input_ = t4source_text.value\n",
        "    type_ = t4type_dropdown.value\n",
        "    backup = t4backup_checkbox.value\n",
        "    partial = t4partial_checkbox.value\n",
        "    replace = t4replace_checkbox.value\n",
        "    customname = t4customname_text.value\n",
        "    attrs = DownloadAttrs(type_ = type_, replace= replace, backup = backup, partial= partial, save_name= customname)\n",
        "    if addsource == localfile_addsource:\n",
        "        addfunc = lambda : add_local_files(path= input_, attrs=  attrs)\n",
        "    elif addsource == upload_addsource:\n",
        "        if t4source_file.value:\n",
        "            files= saveuploadedfiles()\n",
        "            if files:\n",
        "                addfunc = lambda : add_local_files(files= files, attrs= attrs)\n",
        "            else:\n",
        "                return\n",
        "        else:\n",
        "            return\n",
        "    elif addsource == hash_addsource and input_:\n",
        "        addfunc = lambda : add_hash_download(hash= input_, attrs= attrs)\n",
        "    elif addsource == magnet_addsource and input_:\n",
        "        addfunc = lambda : add_magnet_download(magnet_link= input_, attrs= attrs)\n",
        "    process_adddownload_result(addfunc)\n",
        "    #appstate.addthread = threading.Thread(target= process_adddownload_result, args= (addfunc,))\n",
        "    #appstate.addthread.start()\n",
        "    #appstate.addalive = True\n",
        "\n",
        "### Monitor\n",
        "\n",
        "monitorcompleted_views = []\n",
        "monitordownload_views = []\n",
        "monitortitle_labels = []\n",
        "monitormanage_checks = []\n",
        "monitorprogress_labels = []\n",
        "monitorprogress_bars = []\n",
        "monitorstates = []\n",
        "monitortype_labels = []\n",
        "monitordownloadspeeds_labels = []\n",
        "monitoruploadspeeds_labels = []\n",
        "monitortotaldownloads_labels = []\n",
        "monitorremainingbytes_labels = []\n",
        "monitortotaluploads_labels = []\n",
        "monitoreta_labels = []\n",
        "\n",
        "#stat = get_completed_stats() completed_down = stat[0] completed_up = stat[1] update_download_stats_labels(completed_down, completed_up)\n",
        "\n",
        "total_download = total_wanted = total_up = total_progress = dead = active_down = active_up = 0 \n",
        "completed_up = 0\n",
        "completed_down = 0\n",
        "\n",
        "def get_eta(status):\n",
        "    remaining_bytes = status.total_wanted - status.total_wanted_done\n",
        "    if remaining_bytes >= 0 and status.download_rate > 0:\n",
        "        eta_sec = remaining_bytes/status.download_rate \n",
        "        eta_sec = eta_sec + 1.5 if remaining_bytes else 0\n",
        "        return f\"Estimated: {time_str(eta_sec)}\"\n",
        "    return \"\"\n",
        "\n",
        "def update_download_view(downloadviewindex, status, show= False, done= False, transfering= False):\n",
        "    if done:\n",
        "        upload = status.all_time_upload\n",
        "        if upload == 0:\n",
        "            upload = status.total_upload\n",
        "        monitorprogress_labels[downloadviewindex].value = \"100%\"\n",
        "        monitorprogress_bars[downloadviewindex].value = 100\n",
        "        monitorprogress_bars[downloadviewindex].bar_style = 'success'\n",
        "\n",
        "        monitorstates[downloadviewindex].value = \"Completed\"\n",
        "        monitordownloadspeeds_labels[downloadviewindex].value = f\"Completed at:{whitespace3}{time.strftime('%I:%M:%S %p', time.localtime(status.completed_time))}\"\n",
        "        monitortotaldownloads_labels[downloadviewindex].value = \"Total time:{}{:.2f} m\".format(whitespace3, status.active_time/60)\n",
        "        monitorremainingbytes_labels[downloadviewindex].value = f\"Download:{whitespace3}{data_str(status.total_wanted_done)} / {data_str(status.total_wanted)}\"\n",
        "        monitoreta_labels[downloadviewindex].value = f\"Upload:{whitespace3}{data_str(upload)}\"\n",
        "        return\n",
        "    \n",
        "    downloadstate = status.state if not transfering else 9\n",
        "    monitorstates[downloadviewindex].value = downloadmonitorstatestrings[downloadstate] \n",
        "    monitorprogress_labels[downloadviewindex].value =  \"{:.2f}%\".format(status.progress*100)\n",
        "    monitorprogress_bars[downloadviewindex].value = status.progress*100\n",
        "    \n",
        "    monitordownloadspeeds_labels[downloadviewindex].value = f\"Rate:{whitespace3} {speed_str(status.download_rate)}{whitespace3} {speed_str(status.upload_rate)}\"\n",
        "    monitortotaldownloads_labels[downloadviewindex].value = f\"Transfered:{whitespace3} {data_str(status.total_wanted_done)}{whitespace3} {data_str(status.total_upload)}\"\n",
        "    monitorremainingbytes_labels[downloadviewindex].value = f\"Remaining:{whitespace3}{data_str(status.total_wanted - status.total_wanted_done)}\"\n",
        "    monitoreta_labels[downloadviewindex].value = get_eta(status)\n",
        "    if show:\n",
        "        showview(monitordownload_views[downloadviewindex])\n",
        "    return\n",
        "\n",
        "def update_download_stats_labels(_download,_upload):\n",
        "    if total_wanted == 0:\n",
        "        total_progress = 0\n",
        "    else:\n",
        "        total_progress = (100*_download)/total_wanted \n",
        "    t5view1active_label.value = f\"Active:{whitespace3}{len(active) - dead}\"\n",
        "    t5view1completed_label.value = f\"Completed:{whitespace3}{len(completed)}\"\n",
        "    t5view1dead_label.value = f\"Dead:{whitespace3}{format(dead)}\"\n",
        "    t5view1totaldownload_label.value = f\"Session download:{whitespace3}{data_str(_download)} / {data_str(total_wanted)}\"\n",
        "    t5view1totalprogress_label.value = f\"{whitespace4}{round(total_progress,2)}%\"\n",
        "    t5view1totalupload_label.value = f\"Session upload:{whitespace3}{data_str(_upload)}\"\n",
        "\n",
        "def remove_active_view(downloadviewindex):\n",
        "    del monitordownload_views[downloadviewindex]\n",
        "    del monitortitle_labels[downloadviewindex]\n",
        "    del monitorprogress_labels[downloadviewindex]\n",
        "    del monitorprogress_bars[downloadviewindex]\n",
        "    del monitortype_labels[downloadviewindex]\n",
        "    del monitordownloadspeeds_labels[downloadviewindex]\n",
        "    del monitortotaldownloads_labels[downloadviewindex]\n",
        "    del monitorremainingbytes_labels[downloadviewindex]\n",
        "    del monitoreta_labels[downloadviewindex]\n",
        "    info(f'Active view removed.')\n",
        "\n",
        "def create_active_view(handle):\n",
        "    global total_wanted, dead\n",
        "    info(f\"Creating active download view for {handle.name}\")\n",
        "    status = handle.status() \n",
        "    total_wanted += status.total_wanted\n",
        "    if status.total_wanted_done == 0:\n",
        "        hidden = True\n",
        "        dead += 1\n",
        "    else:\n",
        "        hidden = False\n",
        "    view = get_download_view(handle, hidden)\n",
        "    monitordownload_views.append(view)\n",
        "    handle.progress = status.progress\n",
        "    t5view1r4downloadscontainer_vbox.children = monitordownload_views\n",
        "\n",
        "def process_completed_download(handle, status, index):\n",
        "    info(f'{handle.name} finished downloading.')\n",
        "    if len(active) == 0:\n",
        "        appstate.monitoralive = False    \n",
        "    t5view1r3status_html.value =  gethtmltext(f\"Saving {handle.attrs.save_name} to: {handle.attrs.save_path}\", fontsize= '12px', animated= True)\n",
        "    transfer_download_files(handle, copy= False, v= False)\n",
        "    update_download_view(index, status, False, done = True)        \n",
        "    remove_active_view(index)\n",
        "    t5view1r3status_html.value = ''\n",
        "    handle.completed = True\n",
        "    handle.pause()\n",
        "    release()\n",
        "\n",
        "def get_completed_stats_deprecation():\n",
        "    _download = 0\n",
        "    _upload = 0\n",
        "    for c in completed:\n",
        "        status = c.status()\n",
        "        upload = status.all_time_upload\n",
        "        if upload == 0:\n",
        "            upload = status.total_upload  \n",
        "        _download += status.total_wanted_done\n",
        "        _upload += upload\n",
        "    info('Complated stats updated.')\n",
        "    return [_download,_upload]\n",
        "\n",
        "def update_completed_stats(downloaded, uploaded):\n",
        "    global completed_up, completed_down\n",
        "    completed_down += downloaded\n",
        "    completed_up += uploaded\n",
        "\n",
        "def monitoractivedownloads():\n",
        "    global completed_up, completed_down\n",
        "    if ses.is_paused():\n",
        "        return\n",
        "    try:\n",
        "        while appstate.monitoralive and active:\n",
        "            active_down = active_up = active_wanted = 0\n",
        "            for index in range(len(active)):\n",
        "                handle = active[index]    \n",
        "                status = handle.status()\n",
        "                donebytes = status.total_wanted_done\n",
        "                wantedbytes = status.total_wanted\n",
        "                uploadedbytes = status.total_upload\n",
        "                handle.progress = status.progress\n",
        "                if donebytes > 70000:\n",
        "                    showdl = True\n",
        "                    dead -= 1\n",
        "                else:\n",
        "                    showdl = False\n",
        "                if status.is_finished or (wantedbytes > 10000 and donebytes == wantedbytes):\n",
        "                    active.remove(handle)\n",
        "                    completed.append(handle)\n",
        "                    update_completed_stats(wantedbytes, uploadedbytes)\n",
        "                    appstate.filetransferthread = threading.Thread(target= process_completed_download, args= (handle, status, index))\n",
        "                    appstate.filetransferthread.start()\n",
        "                    update_download_view(index, status, transfering= True)\n",
        "                    break\n",
        "                else:\n",
        "                    update_download_view(index, status, showdl)\n",
        "                    active_up += uploadedbytes\n",
        "                    active_down += donebytes\n",
        "                    active_wanted += wantedbytes\n",
        "            total_wanted = completed_down + active_wanted \n",
        "            total_download = completed_down + active_down \n",
        "            total_up = active_up + completed_up\n",
        "            update_download_stats_labels(total_download, total_up)\n",
        "            active.sort(key = lambda obj: obj.progress, reverse= True)\n",
        "            time.sleep(0.8)\n",
        "    except Exception as e:\n",
        "        0\n",
        "\n",
        "def pause_all():\n",
        "    try:\n",
        "        downloads= ses.get_torrents()\n",
        "        for h in downloads:\n",
        "            h.pause()\n",
        "        ses.pause()\n",
        "        \n",
        "    except (KeyboardInterrupt, Exception) as k:\n",
        "        print(k)\n",
        "\n",
        "def resume_all():\n",
        "    ses.resume()\n",
        "    for h in active:\n",
        "        h.resume()\n",
        "\n",
        "### UI    \n",
        "### general style\n",
        "\n",
        "layout_15 ={'width':'auto', 'flex':'15 1 0%', 'align_items':\"center\"}\n",
        "layout_10 ={'width':'auto', 'flex':'10 1 0%', 'align_items':\"center\"}\n",
        "layout_8 ={'width':'auto', 'flex':'8 1 0%', 'align_items':\"center\"}\n",
        "layout_7 ={'width':'auto', 'flex':'7 1 0%', 'align_items':\"center\"}\n",
        "layout_5 ={'width':'auto', 'flex':'5 1 0%', 'align_items':\"center\"}\n",
        "layout_4 ={'width':'auto', 'flex':'4 1 0%', 'align_items':\"center\"}\n",
        "layout_3 ={'width':'auto', 'flex':'3 1 0%', 'align_items':\"center\"}\n",
        "layout_2 ={'width':'auto', 'flex':'2 1 0%', 'align_items':\"center\"}\n",
        "layout_1 ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"center\"}\n",
        "layout_1E ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"flex-start\"}\n",
        "\n",
        "col4layout = {'width':'%25','flex':'3 1 0%', 'align_items':\"center\"}\n",
        "col3layout = {'width':'%33','flex':'2 1 0%', 'align_items':\"center\"}\n",
        "col2layout = {'width':'%50','flex':'1 1 0%', 'align_items':\"center\"}\n",
        "\n",
        "empty_label_1 = widgets.Label(value = \"\", layout = layout_1)\n",
        "empty_label_2 = widgets.Label(value = \"\", layout = layout_2)\n",
        "empty_label_3 = widgets.Label(value = \"\", layout = layout_3)\n",
        "empty_label_4 = widgets.Label(value = \"\", layout = layout_4)\n",
        "empty_label_5 = widgets.Label(value = \"\", layout = layout_5)\n",
        "\n",
        "whitespace1 = ''\n",
        "whitespace2 = ''\n",
        "whitespace3 = ''\n",
        "whitespace4 = ''\n",
        "whitespace5 = ''\n",
        "\n",
        "### custom style\n",
        "rowlayout = {\n",
        "    'flex_flow':'row',\n",
        "    'align_items':'center',\n",
        "    'width':'90%',\n",
        "    'height':'160px',\n",
        "    'justify_content':'center'}\n",
        "\n",
        "saverowlayout = {\n",
        "    'flex_flow':'row',\n",
        "    'align_items':'center',\n",
        "    'width':'80%',\n",
        "    'justify_content':'center'\n",
        "    }\n",
        "\n",
        "input_style = {\"description_width\":\"160px\"}\n",
        "samplestyle = {\"padding-left\":\"200px\",\"padding-right\":\"200px\"}\n",
        "conflabelstyle = {\"padding-left\":\"150px\"}\n",
        "\n",
        "## Reusable Elements\n",
        "mainbox_layout = { 'height':'800px', 'width': '100%', 'margin':'0 0 20px 0' , 'border': '1px solid #0762c9', 'display': 'flex'}\n",
        "tabtitlerow_layout = widgets.Layout(height= '100px', width= '100%', padding= '10px 100px', align_items=  'center')\n",
        "formcontent_layout = {'height':'100%', 'width':'100%', 'padding':'40px 30% 0 0'}\n",
        "viewcontainer_layout = widgets.Layout(height= '100%', width= '100%')\n",
        "t_formrow_layout = widgets.Layout(align_items= 'center', height= '50px', width= '100%', justify_content= 'center', padding= '0')\n",
        "tab_title_layout = widgets.Layout( width= \"200px\")\n",
        "t2labels_layout = {'width':'35%', 'justify_content': 'flex-end'}\n",
        "t2labels_style = {'font_size': '18px'}\n",
        "t2checkboxs_layout = {'margin':'5px 0 0 10px', 'justify_items': 'flex-start','justify_content': 'flex-start','align_content': 'flex-start',}\n",
        "t2controls_layout = {'margin':'0 0 0 10px', 'width':'400px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
        "t2controls_style = {'font_size': '16px', 'description_width':'150px'}\n",
        "bigbtn_style = {'font_size':'16px', 'font_weight':'600'}\n",
        "bigbtn_layout = {'width':'120px', 'height':'50px', 'margin': '0 0 8px 0'}\n",
        "\n",
        "### Tab 1: Configuration\n",
        "### r1\n",
        "\n",
        "t1title_html = widgets.HTML(gethtmltitle('Configurations', 1), layout= tab_title_layout)\n",
        "t1back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'})\n",
        "t1r1_hbox = widgets.HBox((t1title_html, t1back_btn), layout = tabtitlerow_layout)\n",
        "\n",
        "### view1r1v1\n",
        "\n",
        "view1r1v1lttoggle_checkbox = widgets.Checkbox(description=\"Enable LT\", value=True)\n",
        "view1r1v1activedownload_numeric = widgets.BoundedIntText(value=5, min=1, max=25, step=1, description='Active Downloads', disabled=False, style=input_style)\n",
        "view1r1v1_vbox = widgets.VBox((view1r1v1lttoggle_checkbox, view1r1v1activedownload_numeric), layout= col4layout)\n",
        "\n",
        "### view1r1v2\n",
        "\n",
        "view1r1v2ftptoggle_checkbox = widgets.Checkbox(description= \"Enable FTP\", value= False, disabled= False)\n",
        "view1r1v2gdrivetoggle_checkbox = widgets.Checkbox(description= \"Enable Google Dirve\", value= True)\n",
        "view1v2vbox = widgets.VBox((view1r1v2ftptoggle_checkbox, view1r1v2gdrivetoggle_checkbox), layout= col4layout)\n",
        "\n",
        "### t1r1v3\n",
        "\n",
        "view1r1v3ftphost_text = widgets.Text(placeholder= \"FTP host address\", description= \"FTP Host\", style= input_style)\n",
        "view1r1v3ftpuser_text = widgets.Text(placeholder= \"FTP account username\", description= \"FTP Username\", style= input_style)\n",
        "view1r1v3ftppass_text = widgets.Password(placeholder= \"FTP account Password\", description=\"FTP Password\", style= input_style)\n",
        "view1r1v3_vbox = widgets.VBox((view1r1v3ftphost_text, view1r1v3ftpuser_text, view1r1v3ftppass_text), layout= col4layout)\n",
        "\n",
        "view1r1_hbox = widgets.HBox((view1r1v1_vbox, view1v2vbox, view1r1v3_vbox), layout= rowlayout)\n",
        "\n",
        "### view1r2v1\n",
        "\n",
        "view1r2v1localbase_text = widgets.Text(placeholder= \"Local Base\", description= \"Local Base\", value= '/content/Downloads', style= input_style)\n",
        "view1r2v1remotebase_text = widgets.Text(placeholder= \"Remote Base\", description=\"Remote Base\", value= '/media', style= input_style)\n",
        "view1r2v1_vbox = widgets.VBox((view1r2v1localbase_text, view1r2v1remotebase_text), layout= col3layout)\n",
        "\n",
        "### t1r2v2\n",
        "\n",
        "view1r2v2generallib_text = widgets.Text(placeholder= \"Downloads Path\", description= \"Downloads Path\", value= '/content/drive/MyDrive/Downloads', style= input_style)\n",
        "view1r2v2musiclib_text = widgets.Text(placeholder= \"Music Library\", description= \"Music Library\", value= '', style= input_style)\n",
        "view1r2v2_vbox = widgets.VBox((view1r2v2generallib_text, view1r2v2musiclib_text), layout= col3layout)\n",
        "\n",
        "### t1r2v3\n",
        "\n",
        "view1r2v3movielib_text = widgets.Text(placeholder= \"Movies Library\", description= \"Movies Library\", value= '/content/drive/MyDrive/Movies', style= input_style)\n",
        "view1r2v3tvlib_text = widgets.Text(placeholder= \"TV Library\", description= \"TV Library\", value= '/content/drive/MyDrive/TV', style= input_style)\n",
        "view1r2v3_vbox = widgets.VBox((view1r2v3movielib_text, view1r2v3tvlib_text), layout= col3layout)\n",
        "view1r2_hbox = widgets.HBox((view1r2v1_vbox, view1r2v2_vbox, view1r2v3_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r3v1\n",
        "\n",
        "view1r3v1_vbox = widgets.VBox(layout= col3layout)\n",
        "\n",
        "### t1r3v2\n",
        "\n",
        "view1r3v2bkgenerallib_text = widgets.Text(placeholder= \"Backup General Library\", description= \"Backup General Library\", value= '', style= input_style)\n",
        "view1r3v2bkmusiclib_text = widgets.Text(placeholder= \"Backup Music Library\", description= \"Backup Music Library\", value= '', style= input_style)\n",
        "view1r3v2_vbox = widgets.VBox((view1r3v2bkgenerallib_text, view1r3v2bkmusiclib_text), layout= col3layout)\n",
        "\n",
        "### t1r3v3\n",
        "\n",
        "view1r3v3bkmovielib_text = widgets.Text(placeholder= \"Backup Movie Library\", description= \"Backup Movie Library\", value= '', style= input_style)\n",
        "view1r3v3bktvlib_text = widgets.Text(placeholder= \"Backup TV Library\", description= \"Backup TV Library\", value= '', style= input_style)\n",
        "view1r3v3_vbox = widgets.VBox((view1r3v3bkmovielib_text, view1r3v3bktvlib_text), layout= col3layout)\n",
        "\n",
        "view1r3_hbox = widgets.HBox((view1r3v1_vbox, view1r3v2_vbox, view1r3v3_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r4v1\n",
        "\n",
        "view1r4v1_vbox = widgets.VBox(layout= col2layout)\n",
        "\n",
        "### t1r4v2\n",
        "\n",
        "view1r4v2conffile_text = widgets.Text(placeholder= \"Configuration File\", description= \"Configuration File\", value= '', style= input_style)\n",
        "view1r4v2saveconffile_button = widgets.Button(description= \"Export Configuration\",)\n",
        "view1r4v2saveconffile_button.on_click(saveconffilehandler)\n",
        "\n",
        "view1r4v2loadconffile_button = widgets.Button(description= \"Load Configuration\",)\n",
        "view1r4v2loadconffile_button.on_click(loadconffilehandler)\n",
        "view1r4v2conffile_hbox = widgets.HBox((view1r4v2saveconffile_button, view1r4v2loadconffile_button), layout= {\"width\":\"auto\",\"justify-content\":\"space-around\"})\n",
        "view1r4v2_vbox = widgets.VBox((view1r4v2conffile_text, view1r4v2conffile_hbox), layout= col2layout)\n",
        "\n",
        "view1r4_hbox = widgets.HBox((view1r4v1_vbox, view1r4v2_vbox), layout= rowlayout)\n",
        "\n",
        "### t1r5\n",
        "saveconfstyle = f\"color:{succusscolor}\"\n",
        "view1r5saveconf_button = widgets.Button(description= \"Save Configuration\",)\n",
        "view1r5saveconf_button.on_click(saveconfhandler)\n",
        "view1r5saveconfoutput_html = widgets.HTML(layout= layout_4)\n",
        "view1r5saveconfig_Box = widgets.Box((empty_label_3 ,view1r5saveconf_button, empty_label_1, view1r5saveconfoutput_html), layout= saverowlayout)\n",
        "view1r5_hbox = widgets.HBox((view1r5saveconfig_Box,), layout= rowlayout)\n",
        "\n",
        "t1view1_vbox = widgets.VBox((view1r1_hbox, view1r2_hbox, view1r3_hbox, view1r4_hbox, view1r5_hbox), )\n",
        "\n",
        "t1r2container_vbox = widgets.VBox((t1view1_vbox,), layout= viewcontainer_layout)\n",
        "t1r2container_vbox.viewstack = [t1view1_vbox]\n",
        "t1r2container_vbox.back_button = t1back_btn\n",
        "\n",
        "t1_vbox = widgets.VBox((t1r1_hbox, t1r2container_vbox), layout= mainbox_layout)\n",
        "t1_vbox.maincontainer = t1r2container_vbox\n",
        "\n",
        "### Tab 2: Search\n",
        "## Row 1: Title\n",
        "\n",
        "t2title_html = widgets.HTML(gethtmltitle('Search', 1), layout= tab_title_layout)\n",
        "t2back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'})\n",
        "t2r1_hbox = widgets.HBox((t2title_html, t2back_btn), layout = tabtitlerow_layout)\n",
        "\n",
        "## Row 2: Main Content\n",
        "# View 1: Search\n",
        "\n",
        "t2search_text = widgets.Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t2search_hbox = widgets.HBox((t2search_text,),layout= t_formrow_layout)\n",
        "\n",
        "t2type_dropdown = widgets.Dropdown(description= \"Download Type\", value= Movie ,options= [('General', General), ('Movie', Movie), ('Episode', Episode), ('Season', Season), ('TV Show', Show), ('Music Album', Album), ('Song', Track)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2type_hbox = widgets.HBox((t2type_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t2site_dropdown = widgets.Dropdown(description= \"Site\", value= l337x, options = [('1337x', l337x)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2site_hbox = widgets.HBox((t2site_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2page_int = widgets.IntText(description= \"Page\", value= 0, layout= t2controls_layout, style= t2controls_style)\n",
        "t2page_hbox = widgets.HBox((t2page_int,),layout= t_formrow_layout)\n",
        "\n",
        "t2searchcategory_dropdown = widgets.Dropdown(description= \"Search Category\", value= allcategories, options = [('All', allcategories), ('Movies', moviescategory), ('TV', tvcategory), ('Apps', appscategory), ('Games', gamescategory)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2searchcategory_hbox = widgets.HBox((t2searchcategory_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2sort_dropdown = widgets.Dropdown(description= \"Results Sorting\", value= seederssort, options = [('By Seeders', seederssort), ('By Time', timesort), ('By Size', sizesort)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2sort_hbox = widgets.HBox((t2sort_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2order_dropdown = widgets.Dropdown(description= \"Results Order\", value= descorder, options = [('Ascending', ascorder), ('Descending', descorder)], layout= t2controls_layout, style= t2controls_style)\n",
        "t2order_hbox = widgets.HBox((t2order_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "t2replace_checkbox = widgets.Checkbox(description= \"Replace Existing\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2replace_hbox = widgets.HBox((t2replace_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2backup_checkbox = widgets.Checkbox(description= \"Save Backup\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2backup_hbox = widgets.HBox((t2backup_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2partial_checkbox = widgets.Checkbox(description= \"Partial Download\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t2partial_hbox = widgets.HBox((t2partial_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t2customname_text = widgets.Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t2customname_hbox = widgets.HBox((t2customname_text,),layout= t_formrow_layout)\n",
        "\n",
        "t2search_button = widgets.Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
        "t2search_button.layout.align_self = \"center\"\n",
        "\n",
        "t2view1_search_vbox= widgets.VBox((t2search_hbox, t2type_hbox, t2site_hbox,\n",
        "                                   t2page_hbox, t2searchcategory_hbox,\n",
        "                                   t2sort_hbox, t2order_hbox, t2replace_hbox,\n",
        "                                   t2backup_hbox, t2partial_hbox,\n",
        "                                    t2customname_hbox, t2search_button), layout= formcontent_layout)\n",
        "\n",
        "t2r2viewcontainer_vbox = widgets.VBox((t2view1_search_vbox, ), layout= viewcontainer_layout)\n",
        "t2r2viewcontainer_vbox.viewstack = [t2view1_search_vbox]\n",
        "t2r2viewcontainer_vbox.back_button = t2back_btn\n",
        "\n",
        "t2back_btn.on_click(lambda b: switchview(t2r2viewcontainer_vbox))\n",
        "\n",
        "t2_vbox = widgets.VBox((t2r1_hbox, t2r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t2_vbox.maincontainer = t2r2viewcontainer_vbox\n",
        "\n",
        "### Tab 3: IMDB Search\n",
        "## Row 1: Title\n",
        "\n",
        "t3title_html = widgets.HTML(gethtmltitle('IMDB Search', 1), layout= tab_title_layout)\n",
        "t3back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'})\n",
        "\n",
        "t3r1_hbox = widgets.HBox((t3title_html, t3back_btn), layout = tabtitlerow_layout)\n",
        "\n",
        "t3r2imdbsearchview_vbox = widgets.VBox(layout= formcontent_layout)\n",
        "\n",
        "t3r2viewcontainer_vbox = widgets.VBox((t3r2imdbsearchview_vbox,), layout= viewcontainer_layout)\n",
        "t3r2viewcontainer_vbox.viewstack = [t3r2imdbsearchview_vbox]\n",
        "t3r2viewcontainer_vbox.back_button = t3back_btn\n",
        "\n",
        "t3back_btn.on_click(lambda b: switchview(t3r2viewcontainer_vbox))\n",
        "\n",
        "t3_vbox = widgets.VBox((t3r1_hbox, t3r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t3_vbox.maincontainer = t3r2viewcontainer_vbox\n",
        "\n",
        "### Tab 4: Adding Downloads\n",
        "## R1: Title\n",
        "\n",
        "t4title_html = widgets.HTML(gethtmltitle('Add Downloads', 1), layout= tab_title_layout)\n",
        "t4back_btn = widgets.Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'})\n",
        "\n",
        "t4r1_hbox = widgets.HBox((t4title_html, t4back_btn), layout = tabtitlerow_layout)\n",
        "\n",
        "## R2: Main Content\n",
        "\n",
        "t4addsourcetype_dropdown = widgets.Dropdown(description= \"Download Type\", value= magnet_addsource, \n",
        "                                         options= [('Magnet', magnet_addsource), ('Hash', hash_addsource),\n",
        "                                        ('Upload File', upload_addsource), ('Local File', localfile_addsource), ('File URL', fileurl_addsource)],\n",
        "                                         layout= t2controls_layout, style= t2controls_style)\n",
        "t4addsourcetype_hbox = widgets.HBox((t4addsourcetype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t4source_text = widgets.Text(description= \"Magnet\", layout= t2controls_layout, style= t2controls_style)\n",
        "\n",
        "t4sourcefile_labelhbox = widgets.HBox((widgets.Label(value= \"Torrent File\", layout= {\"width\":'auto'}),),\n",
        "                                      layout= {'height':'auto', 'display':'none', 'width':'170px', 'margin': '0 11px 0 0'})\n",
        "t4sourcefile_labelhbox.layout.justify_content= 'flex-end'\n",
        "t4sourcefile_labelhbox.layout.align_items = 'center'\n",
        "\n",
        "t4source_file = widgets.FileUpload(description= \"Upload File\", layout= {'width':'240px', 'align-items': 'center','justify-content':'flex-start'})\n",
        "t4source_file.layout.display = 'none'\n",
        "t4source_file.layout.align_items = 'center'\n",
        "\n",
        "t4source_hbox = widgets.HBox((t4source_text, t4sourcefile_labelhbox, t4source_file), layout= t_formrow_layout)\n",
        "\n",
        "t4type_dropdown = widgets.Dropdown(description= \"Download Type\", value= Movie ,options= [('General', General), ('Movie', Movie), ('Episode', Episode), ('Season', Season), ('TV Show', Show), ('Music Album', Album), ('Song', Track)], layout= t2controls_layout, style= t2controls_style)\n",
        "t4type_hbox = widgets.HBox((t4type_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "t4replace_checkbox = widgets.Checkbox(description= \"Replace Existing\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4replace_hbox = widgets.HBox((t4replace_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4backup_checkbox = widgets.Checkbox(description= \"Save Backup\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4backup_hbox = widgets.HBox((t4backup_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4partial_checkbox = widgets.Checkbox(description= \"Partial Download\", value= False, layout= t2checkboxs_layout, style= t2controls_style)\n",
        "t4partial_hbox = widgets.HBox((t4partial_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "t4customname_text = widgets.Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "t4customname_hbox = widgets.HBox((t4customname_text,),layout= t_formrow_layout)\n",
        "\n",
        "t4add_button = widgets.Button(description= \"Add\", disabled= True, layout= bigbtn_layout, style= bigbtn_style)\n",
        "t4add_button.layout.align_self = \"center\"\n",
        "\n",
        "t4r2view1_adddownload_vbox= widgets.VBox((t4addsourcetype_hbox, t4source_hbox, t4type_hbox, t4replace_hbox, t4backup_hbox, t4partial_hbox, t4customname_hbox, t4add_button), layout= formcontent_layout)\n",
        "\n",
        "t4r2viewcontainer_vbox = widgets.VBox((t4r2view1_adddownload_vbox,), layout= viewcontainer_layout)\n",
        "t4r2viewcontainer_vbox.viewstack = [t4r2view1_adddownload_vbox]\n",
        "t4r2viewcontainer_vbox.back_button = t4back_btn\n",
        "t4back_btn.on_click(lambda b: switchview(t4r2viewcontainer_vbox))\n",
        "\n",
        "t4r2view2_addresult_vbox = widgets.VBox(layout= formcontent_layout)\n",
        "t4r2view2_addresult_vbox.layout.padding = '20px 50px'\n",
        "\n",
        "t4_vbox = widgets.VBox((t4r1_hbox, t4r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t4_vbox.maincontainer = t4r2viewcontainer_vbox\n",
        "\n",
        "### Tab 5: Downloads\n",
        "## Row 1: Title\n",
        "\n",
        "t5title_html = widgets.HTML(gethtmltitle('Downloads', 1), layout= tab_title_layout)\n",
        "t5r1_hbox = widgets.HBox((t5title_html,), layout = tabtitlerow_layout)\n",
        "\n",
        "## Row 2: Monitor view\n",
        "\n",
        "downloadtransferstate = 9\n",
        "downloadmonitorstatestrings = [\"Queued\",\"Checking\",\"Downloading metadata\",\"Downloading\",\"Finished\",\"Seeding\",\"Allocating\",\"Checking resume files\", \"Transfering files\"]\n",
        "\n",
        "t5view1container_layout = {'width':'100%', 'height':'100%'}\n",
        "t5view1r1_layout = {'flex_flow':'row','align_items':'center', 'height':'40px', 'width':'100%','justify_content':'space-around'}\n",
        "t5view1r2manage_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','height':'50px','justify_content':'flex-start'}\n",
        "t5view1r3_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','justify_content':'space-around'}\n",
        "t5view1column_layout = {'width':'95%','align_items':'center','border':'solid #d9dbda 1px'}\n",
        "t5view1download_layout = {'flex_flow':'row','align_items':'center','width':'95%','justify_content':'space-around'}\n",
        "\n",
        "t5view1sessionstatus_label = widgets.Label(value= f'{\"\"}', layout= layout_3)\n",
        "t5view1totaltorrents_label = widgets.Label(value= \"Total torrents:  0\", layout= layout_3)\n",
        "t5view1active_label = widgets.Label(value= \"Active:  0\", layout= layout_3)\n",
        "t5view1dead_label = widgets.Label(value= \"Dead:  0\", layout= layout_3)\n",
        "t5view1completed_label = widgets.Label(value= \"Completed:  0\", layout= layout_3)\n",
        "t5view1totaldownload_label=widgets.Label(value= \"Session download:  0 MB\", layout= layout_5)\n",
        "t5view1totalprogress_label=widgets.Label(value= \"\", layout= layout_3)\n",
        "t5view1totalupload_label=widgets.Label(value= \"Session upload:  0 MB\", layout= layout_5)   \n",
        "\n",
        "t5view1r1pathes_html = widgets.HTML(layout= {'width':'100%'})\n",
        "t5view1r2stats_box = widgets.Box([t5view1sessionstatus_label, t5view1totaltorrents_label, t5view1active_label, t5view1completed_label, t5view1dead_label, t5view1totaldownload_label, t5view1totalprogress_label, t5view1totalupload_label, empty_label_3], layout= t5view1r1_layout)\n",
        "t5view1r3status_html =  widgets.HTML()\n",
        "t5view1r4downloadscontainer_vbox = widgets.VBox(layout= t5view1container_layout)\n",
        "t5view1downloadmonitor_vbox = widgets.VBox((t5view1r1pathes_html, t5view1r2stats_box, t5view1r3status_html, t5view1r4downloadscontainer_vbox), layout= {'width':'100%', 'height':'100%'})\n",
        "\n",
        "t5r2viewcontainer_vbox = widgets.VBox((t5view1downloadmonitor_vbox,), layout= viewcontainer_layout)\n",
        "\n",
        "t5_vbox = widgets.VBox((t5r1_hbox, t5r2viewcontainer_vbox), layout= mainbox_layout)\n",
        "t5_vbox.maincontainer = t5r2viewcontainer_vbox\n",
        "\n",
        "main_tabs = widgets.Tab([t1_vbox, t2_vbox, t3_vbox, t4_vbox, t5_vbox])\n",
        "\n",
        "main_tabs.set_title(0, 'Configuration')\n",
        "main_tabs.set_title(1, 'Search')\n",
        "main_tabs.set_title(2, 'IMDB Search')\n",
        "main_tabs.set_title(3, 'Add Downloads')\n",
        "main_tabs.set_title(4, 'Downloads')\n",
        "\n",
        "### Dynamic views\n",
        "\n",
        "addresultlayout =  {'height': '330px', 'width': '100%'}\n",
        "addresultrowlayout = {}\n",
        "addrestitlefont = '22px'\n",
        "addrestitlestyle = ' display: inline-block; margin: 0 0 10px 40px'\n",
        "addresultlabelfontsize = '18px'\n",
        "addresultvaluefontsize = '16px'\n",
        "addreslabelstyle = 'width:180px; display: inline-block; text-align: end; margin: 0 40px 0 0'\n",
        "fileselectionlayout =  {'height': '470px', 'width': '100%'}\n",
        "fileselectiontitlestyle = ' display: inline-block; margin: 0 20px 10px 40px'\n",
        "fileselectionbuttonlayout = {'width': '100px', 'height': '30px'}\n",
        "fileselectioncontrolgap = '15px'\n",
        "filerowfontsize = '16px'\n",
        "filetableformatters = {'Download': {'type': 'tickCross'},}\n",
        "filetableeditors = {'No': None, 'Download': CheckboxEditor(), 'Size': None,'Name': None, }\n",
        "filetablecolumnwidths={'No': '8%', 'Download': '15%', 'Size': '12%', 'Name': '65%'}\n",
        "\n",
        "def getcssblinkanimation(color, elementid = \"\", elementclass = \"\"):\n",
        "    if not elementclass and not elementid:\n",
        "        return None\n",
        "    shadecolor = color[:-2] + '2c' if len(color) == 9 else color + '2c'\n",
        "    styletag = '<style>'\n",
        "    idpart = f'#{elementid}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementid else \"\"\n",
        "    animationpart = f' @keyframes color-change {{ 0% {{ color: {color}; }} 50% {{ color: {shadecolor}; }} 100% {{ color: {color} ; }} }}</style>'\n",
        "    classpart = f'.{elementclass}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementclass else \"\"\n",
        "    return styletag + idpart + classpart + animationpart\n",
        "\n",
        "def getloadingview(text):\n",
        "    elid= 'el-' + nowstr()\n",
        "    t1style = f\"color:{accentcolor}; font-family: {fontfamily};  display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    spinnerhtml = \"<div class=loadingio-spinner-spinner-m4dbaxm5cdf><div class=ldio-orkmsj9nbq><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><style>@keyframes ldio-orkmsj9nbq{0%{opacity:1}100%{opacity:0}}.ldio-orkmsj9nbq div{left:47px;top:16px;position:absolute;animation:ldio-orkmsj9nbq linear 1.1111111111111112s infinite;background:#184cad;width:6px;height:12px;border-radius:2.16px;transform-origin:3px 34px}.ldio-orkmsj9nbq div:first-child{transform:rotate(0);animation-delay:-1.0185185185185184s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(2){transform:rotate(30deg);animation-delay:-.9259259259259258s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(3){transform:rotate(60deg);animation-delay:-.8333333333333333s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(4){transform:rotate(90deg);animation-delay:-.7407407407407407s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(5){transform:rotate(120deg);animation-delay:-.6481481481481481s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(6){transform:rotate(150deg);animation-delay:-.5555555555555555s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(7){transform:rotate(180deg);animation-delay:-.4629629629629629s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(8){transform:rotate(210deg);animation-delay:-370.3703703703703ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(9){transform:rotate(240deg);animation-delay:-277.7777777777777ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(10){transform:rotate(270deg);animation-delay:-.18518518518518517s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(11){transform:rotate(300deg);animation-delay:-92.59259259259258ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(12){transform:rotate(330deg);animation-delay:0s;background:#184cad}.loadingio-spinner-spinner-m4dbaxm5cdf{width:100px;height:100px;display:inline-block;overflow:hidden;background:0 0}.ldio-orkmsj9nbq{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-orkmsj9nbq div{box-sizing:content-box}</style>\"\n",
        "    loading_container = f'<div style=\"height:{messagecontainerhight}; width:100%; text-align: center; padding: {messagecontainerpadding}\">{gethtmltext(text + \" \", elid= elid, style=t1style)} {spinnerhtml}</div>' + getcssblinkanimation(color= accentcolor, elementid=elid)\n",
        "    return widgets.HTML(loading_container)\n",
        "\n",
        "def getmessageview(text):\n",
        "    t1style = f\"color:{accentcolor}; font-family: {fontfamily}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    message_container = f'<div style=\"height: {messagecontainerhight}; width:100%; text-align: center; padding: {messagecontainerpadding}\">{gethtmltext(text , style=t1style)} </div>'\n",
        "    return widgets.HTML(message_container)\n",
        "\n",
        "def getconfirmmessage(message):\n",
        "    return None\n",
        "\n",
        "async def getuserinput():\n",
        "    return None\n",
        "\n",
        "def getimdbsearchresultsview():\n",
        "    return None\n",
        "\n",
        "def getaddresultsubview(result: AddResult):\n",
        "    if result.status == addsuccuss:\n",
        "        resulttitlehtml = widgets.HTML(gethtmltext(result.succussmessage, fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        namehtml = widgets.HTML(gethtmltext(\"Download name:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext(result.name, fontsize= addresultvaluefontsize))\n",
        "        savenamehtml = widgets.HTML(gethtmltext(\"Save as:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savename,fontsize= addresultvaluefontsize))\n",
        "        sizehtml = widgets.HTML(gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( data_str(result.size), fontsize= addresultvaluefontsize))\n",
        "        fileshtml = widgets.HTML(gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.totalfiles, fontsize= addresultvaluefontsize))\n",
        "        hashhtml = widgets.HTML(gethtmltext(\"Hash:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.hash, fontsize= addresultvaluefontsize))\n",
        "        savepathhtml = widgets.HTML(gethtmltext(\"Save path:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savepath, fontsize= addresultvaluefontsize))\n",
        "        children = (resulttitlehtml, namehtml, savenamehtml, sizehtml, fileshtml, hashhtml, savepathhtml)\n",
        "    else:\n",
        "        resulttitlehtml = widgets.HTML(gethtmltext(result.errormessage, fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        children = (resulttitlehtml,)\n",
        "    return widgets.VBox(children, layout= addresultlayout)\n",
        "\n",
        "def makefiletable(files: list[DownloadFile]):\n",
        "    filetablesource = {\"No\": [], \"Download\":[], \"Size\": [], \"Name\": []}\n",
        "    for item in files:\n",
        "        filetablesource['No'].append(item.index + 1)\n",
        "        filetablesource['Download'].append(item.selected)\n",
        "        filetablesource['Size'].append(data_str(item.size))\n",
        "        filetablesource['Name'].append(item.name)\n",
        "    dataframe = pd.DataFrame(filetablesource)\n",
        "    filetable = panel.widgets.Tabulator(dataframe, sizing_mode='stretch_width', widths= filetablecolumnwidths, disabled= False, show_index= False, pagination= None, editors= filetableeditors ,formatters=filetableformatters) \n",
        "    def editfiles(e):\n",
        "        files[e.row].selected = e.value\n",
        "    filetable.on_edit(editfiles)\n",
        "    return filetable\n",
        "\n",
        "def getfileselectionsubview(result: AddResult, fileselectionview_vbox= None):\n",
        "    if not fileselectionview_vbox:\n",
        "        fileselectionview_vbox = widgets.VBox(layout= fileselectionlayout)\n",
        "    if result.status == addsuccuss:\n",
        "        if result.hasmetadata:\n",
        "            handle = result.handle\n",
        "            files: list[DownloadFile] = result.files\n",
        "\n",
        "            fileselectiontitle = widgets.HTML(gethtmltext(\"Select files\", fontsize= addrestitlefont, style= fileselectiontitlestyle))\n",
        "\n",
        "            selectall_button = widgets.Button(description= \"All\", layout= fileselectionbuttonlayout)\n",
        "            selectall_button.layout.margin = f'1px 0 0 {fileselectioncontrolgap}'\n",
        "\n",
        "            selectintervals_text = widgets.Text(description= 'Intervals', description_width= '', placeholder= 'Start-end, single, n:start-end, s01-s03..', layout= {'width':'400px', 'margin': f'3px 0 0 {fileselectioncontrolgap}'})\n",
        "            selectintervals_button = widgets.Button(description= \"Select\", layout= fileselectionbuttonlayout)\n",
        "\n",
        "            downloadfiles_button = widgets.Button(description= \"Download Files\", layout= fileselectionbuttonlayout)\n",
        "            downloadfiles_button.layout.margin = f'1px 0 0 25px'\n",
        "            \n",
        "            selectstatus_html = widgets.HTML()\n",
        "\n",
        "            toprow_hbox = widgets.HBox((fileselectiontitle, selectall_button, selectintervals_text, selectintervals_button, downloadfiles_button, selectstatus_html), layout= {'width': '100%', 'height':'60px'})\n",
        "\n",
        "            filetable = makefiletable(files)\n",
        "            filetableoutput = widgets.Output()\n",
        "            with filetableoutput:\n",
        "                filetableoutput.clear_output()\n",
        "                display(filetable)\n",
        "            filetable_vbox = widgets.VBox((filetableoutput,), layout= {'width': '100%', 'height': '400px'})\n",
        "            filetable_vbox.layout.border = '1px solid #ababab'\n",
        "            fileselectionview_vbox.children = (toprow_hbox, filetable_vbox)\n",
        "            fileselectionview_vbox.filetable = filetable\n",
        "\n",
        "            def selectallandpatch(b):\n",
        "                selectallfiles(files)\n",
        "                patchfiletable(filetable, files)\n",
        "            def selectseasonintervalandpatch(b):\n",
        "                selection = selectintervals_text.value.strip()\n",
        "                if selection:\n",
        "                    getfileselectionwithstr(files, selection)\n",
        "                    patchfiletable(filetable, files)\n",
        "            def handlefileselection(b):\n",
        "                status = selectdownloadfiles(handle, files)\n",
        "                color = '#018c01' if status else '#9c0c0c'\n",
        "                statusstr = \"Files selected successfully.\" if status else 'Files selection failed.'\n",
        "                selectstatus_html.value = gethtmltext(statusstr, fontsize= '14px', style=f'color:{color}')\n",
        "\n",
        "            selectall_button.on_click(selectallandpatch)\n",
        "            selectintervals_button.on_click(selectseasonintervalandpatch)\n",
        "            downloadfiles_button.on_click(handlefileselection)\n",
        "        else:\n",
        "            fileselectiontitle = widgets.HTML(gethtmltext(\"Download metadata aren't loaded yet.\", fontsize= '16px', style= fileselectiontitlestyle))\n",
        "            fileselectionview_vbox.children = (fileselectiontitle,)\n",
        "            appstate.metacheckerthread = threading.Thread(target= metacheck, args= (result, fileselectionview_vbox))\n",
        "            appstate.metacheckerthread.start()\n",
        "    return fileselectionview_vbox\n",
        "\n",
        "def metacheck(result, fileselectionview_vbox):\n",
        "    appstate.metacheckeralive = True\n",
        "    timeout = 600\n",
        "    while timeout >= 0 and appstate.metacheckeralive:\n",
        "        torrentfile = result.handle.torrent_file()\n",
        "        if torrentfile:\n",
        "            getfileselectionsubview(result, fileselectionview_vbox)\n",
        "            appstate.metacheckeralive = False\n",
        "            break\n",
        "        timeout -= 0.6\n",
        "        time.sleep(0.6)\n",
        "    appstate.metacheckeralive = False\n",
        "\n",
        "def patchfiletable(table, files):\n",
        "    patch = {\"Download\": []}\n",
        "    for i in range(len(files)):\n",
        "        patch[\"Download\"].append((i, files[i].selected))\n",
        "    table.patch(patch)\n",
        "\n",
        "### Monitor\n",
        "\n",
        "def setpatheshtml():\n",
        "    pathstr = \"<style>.path-str{margin: 0 0 0 80px; font-size: 14px}</style>\"\n",
        "    if general_path:\n",
        "        pathstr += f'<span class=\"path-str\">Downloads: {general_path}</span>'     \n",
        "    if movies_path:\n",
        "        pathstr += f'<span class=\"path-str\">Movies: {movies_path}</span>'\n",
        "    if tv_path:\n",
        "        pathstr += f'<span class=\"path-str\">TV: {tv_path}</span>'\n",
        "    if music_path:\n",
        "        pathstr += f'<span class=\"path-str\">Music: {music_path}</span>'        \n",
        "    t5view1r1pathes_html.value = pathstr\n",
        "\n",
        "def get_download_view(handle, hide = False):\n",
        "    status = handle.status()\n",
        "    progress_bar = widgets.FloatProgress(value= status.progress*100, min= 0, max= 100, step= 0.2, bar_style= 'info', orientation= 'horizontal', layout= layout_15)\n",
        "\n",
        "    title_label = widgets.Label(value= handle.name, layout= layout_10)\n",
        "    progress_label = widgets.Label(value= \"{:.2f}%\".format(status.progress*100), layout= layout_1)\n",
        "\n",
        "    monitortitle_labels.append(title_label)\n",
        "    monitorprogress_bars.append(progress_bar)\n",
        "    monitorprogress_labels.append(progress_label)\n",
        "\n",
        "    strs=[\n",
        "          f\"Rate:{whitespace3} {speed_str(status.download_rate)}{whitespace3} {speed_str(status.upload_rate)}\"  ,\n",
        "          f\"Transfered:{whitespace3} {data_str(status.total_wanted_done)}{whitespace3} {data_str(status.total_upload)}\" ,\n",
        "          f\"Remaining:{whitespace3}{data_str(status.total_wanted - status.total_wanted_done)}\" ,\n",
        "          get_eta(status), #All time upload doesn't work properly\n",
        "          ]\n",
        "\n",
        "    downloadlabels = [widgets.Label(value= v, layout= layout_4) for v in strs]\n",
        "    downloadlabels.insert(0, widgets.Label(value= downloadmonitorstatestrings[status.state], layout= layout_2))\n",
        "    downloadlabels.insert(1, widgets.Label(value= types[handle.attrs.type_], layout= layout_2))\n",
        "\n",
        "    monitorstates.append(downloadlabels[0])\n",
        "    monitortype_labels.append(1)\n",
        "    monitordownloadspeeds_labels.append(downloadlabels[2])\n",
        "    monitortotaldownloads_labels.append(downloadlabels[3])\n",
        "    monitorremainingbytes_labels.append(downloadlabels[4])  \n",
        "    monitoreta_labels.append(downloadlabels[5])\n",
        "\n",
        "    downloadrow1box = widgets.Box((title_label, progress_label, progress_bar, empty_label_1), layout = t5view1r3_layout, style = t5view1download_style)\n",
        "    downloadrow2box = widgets.Box(downloadlabels, layout= t5view1r3_layout, style= t5view1download_style)\n",
        "    downloadVBox = widgets.VBox((downloadrow1box,downloadrow2box), layout= t5view1column_layout)\n",
        "\n",
        "    #if hide: hideview(downloadVBox)\n",
        "    info(f'Download view created for: {handle.name}')\n",
        "    return downloadVBox\n",
        "\n",
        "def get_completed_download_view(handle):\n",
        "  status = handle.status()\n",
        "  progress_bar = widgets.FloatProgress(value = 100, min = 0, max = 100, bar_style = 'success', orientation = 'horizontal', layout = layout_15 )\n",
        "  download_label = widgets.Label(value = handle.name, layout = layout_10)\n",
        "  progress_label= widgets.Label(value = \"100%\", layout = layout_1E)\n",
        "  upload = status.all_time_upload\n",
        "  if upload == 0:\n",
        "    upload = status.total_upload\n",
        "  strs=[\n",
        "        f\"Completed at:{whitespace3}{time.strftime('%I:%M:%S %p', time.localtime(status.completed_time))}\",\n",
        "        \"Total time:{}{:.2f} m\".format(whitespace3, status.active_time/60),\n",
        "        f\"Download:{whitespace3}{data_str(status.total_wanted_done)} / {data_str(status.total_wanted)}\",\n",
        "        f\"Upload:{whitespace3}{data_str(upload)}\"]\n",
        "\n",
        "  downloadlabels = [widgets.Label(value = v, layout = layout_4) for v in strs]\n",
        "  downloadlabels.insert(0, widgets.Label(value = \"Completed\", layout = layout_2))\n",
        "  downloadlabels.insert(1, widgets.Label(value = types[handle.attrs.type_], layout = layout_2))\n",
        "\n",
        "  downloadrow1box = widgets.Box([ download_label,progress_label, progress_bar,empty_label_1],layout= t5view1r3_layout,style= t5view1download_style)\n",
        "  downloadrow2box = widgets.Box(downloadlabels, layout = t5view1r3_layout, style=t5view1download_style)\n",
        "  downloadVBox = widgets.VBox([downloadrow1box,downloadrow2box],layout= t5view1column_layout)\n",
        "  info(f'Completed view created for: {handle.name}')\n",
        "  return downloadVBox\n",
        "\n",
        "### Handling\n",
        "\n",
        "t4addsourcetype_dropdown.observe(addsource_change, names= \"value\")\n",
        "t4source_text.observe(addinput_change, 'value')\n",
        "t4source_file.observe(addfile_change, names= 'value')\n",
        "t4add_button.on_click(adddownload_handler)\n",
        "\n",
        "def search_handler(obj):\n",
        "    pass\n",
        "\n",
        "def imdb_handler(obj):\n",
        "    pass\n",
        "\n",
        "btn_ui = widgets.Button(description=\"uiclicker\", layout={'display':'none'})\n",
        "btn_ui.on_click(lambda b: btn_ui.notify_change({'name': 'value', 'type':'update'}))\n",
        "if env_colab:\n",
        "    output.eval_js(\"\"\"function findclicker() {\n",
        "    els = Array.prototype.slice.call(document.getElementsByTagName('button')).filter(el => el.textContent.trim() === 'uiclicker'.trim());\n",
        "    if(els.length > 0){els[0].click();}}setInterval(findclicker, 300);\"\"\") \n",
        "\n",
        "display(main_tabs, btn_ui)\n",
        "\n",
        "release()"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "include_colab_link": true,
      "name": "Hydraulic",
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3.9.7 64-bit",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.11"
    },
    "vscode": {
      "interpreter": {
        "hash": "c347c8f9a7ef94e4c9e03b4513be7835ed18f45b99a2a817fb579f408b867b16"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
