{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "cellView": "form",
        "id": "6mYSH1yDOwvw"
      },
      "outputs": [],
      "source": [
        "#@title { form-width: \"2%\" }\n",
        "#@markdown\n",
        "# chk 00\n",
        "\n",
        "dev = False\n",
        "\n",
        "import os, sys, platform, pytz, time, traceback, unicodedata, re, requests, random\n",
        "from bs4 import BeautifulSoup as Soup, element\n",
        "from datetime import date, datetime, timedelta\n",
        "from threading import Thread\n",
        "from ipywidgets import Output\n",
        "pytz.timezone('Turkey')\n",
        "    \n",
        "# Platform\n",
        "\n",
        "td_id = \"TD1\"\n",
        "td_email = \"default@mail.com\"\n",
        "tz = pytz.timezone('Turkey')\n",
        "os.environ['TZ'] = 'Turkey'\n",
        "\n",
        "nowstr = lambda separete = False: datetime.now(tz).strftime(\"%y-%m-%d-%H-%M-%S\") if separete else str(round(time.time()))\n",
        "rand = lambda: str(random.randint(10000000, 100000000))\n",
        "tb = lambda e: ''.join(traceback.format_tb(e.__traceback__))\n",
        "ex = traceback.format_exc\n",
        "hide = Output()\n",
        "Tag = element.Tag\n",
        "\n",
        "IS_ENV_COLAB = 'google.colab' in sys.modules \n",
        "WINDOWS = 'Windows'\n",
        "LINUX = 'Linux'\n",
        "\n",
        "if IS_ENV_COLAB:\n",
        "    time.tzset()\n",
        "    from google.colab import output, drive\n",
        "    from google.colab.output import eval_js \n",
        "    if not os.path.exists(\"/content/drive\"):\n",
        "        with hide:\n",
        "            drive.mount('/content/drive')\n",
        "\n",
        "ENV_OS = platform.uname().system\n",
        "if ENV_OS == WINDOWS:\n",
        "    NULL_STREAM =  ' > NUL' \n",
        "elif ENV_OS == LINUX:\n",
        "    NULL_STREAM = ' > /dev/null 2>&1' \n",
        "\n",
        "UICLICKER_STOP = \"uiclicker\"\n",
        "UICLICKER_RUN = \"runuiclicker\"\n",
        "SIMULATECLICK_DESC = 'C' + nowstr()\n",
        "\n",
        "# Log\n",
        "LOG_FILENAME = f\"td-log-{nowstr()}\"\n",
        "LOG_DIR_LOCAL = '/content/tdlogs' if ENV_OS == 'Linux' else \"c:/td/logs\"\n",
        "LOG_FILE = f\"{LOG_DIR_LOCAL}/{LOG_FILENAME}.txt\"\n",
        "INFO_LOG = \"Info\"\n",
        "WARNING_LOG = \"Warning\"\n",
        "ERROR_LOG = \"Error\"\n",
        "MAIN = \"Main\"\n",
        "\n",
        "os.makedirs(LOG_DIR_LOCAL, exist_ok=True)\n",
        "def append_lines(filename, lines = None):\n",
        "    if lines:\n",
        "        try:\n",
        "            with open(filename, \"a+\") as file:\n",
        "                file.seek(0)\n",
        "                data = file.read(100)\n",
        "                if len(data) > 0:\n",
        "                    file.write(\"\\n\")\n",
        "                if lines:\n",
        "                    for ln in lines:\n",
        "                        file.write(ln + \"\\n\")\n",
        "        except Exception as e:\n",
        "            return False\n",
        "        return True\n",
        "    return False \n",
        "  \n",
        "class Logger: \n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def getInstance():\n",
        "        if Logger._instance == None:\n",
        "            Logger()\n",
        "        return Logger._instance\n",
        "\n",
        "    def __init__(self):\n",
        "        if Logger._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")\n",
        "        else:\n",
        "            Logger._instance = self\n",
        "\n",
        "    logs = []\n",
        "    log_drv = \"\"\n",
        "    def init(self, hold = False):\n",
        "        if hold:\n",
        "            self.logs.append(self.makelog('Log started.', INFO_LOG, MAIN))\n",
        "        else:\n",
        "            self.log('Log started.', INFO_LOG,  MAIN)\n",
        "\n",
        "    def makelog(self, text: str, log_type: str= 'Info', source: str= MAIN) -> str:\n",
        "        now = datetime.now(tz).strftime(\"%y:%m:%d:%H:%M:%S\")\n",
        "        source = source.replace('_', ' ').title()\n",
        "        start = \"{} {:^7} {}:\". format(now, log_type, source)\n",
        "        text = text.replace(\"\\n\", f\"\\n{len(start)*' '} \")\n",
        "        lg = f\"{start} {text}\"\n",
        "        return lg\n",
        "\n",
        "    def queue(self, text: str, log_type: str= 'Info', source= MAIN):\n",
        "        self.logs.append(self.makelog(text, log_type = log_type, source = source))\n",
        "\n",
        "    def info(self, text: str= \"\", lines = None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "                self.queue(line, INFO_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, INFO_LOG, src)\n",
        "\n",
        "    def warning(self, text: str= \"\", lines= None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "\n",
        "        if lines:\n",
        "            for line in lines:\n",
        "              self.queue(line, WARNING_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, WARNING_LOG, src)  \n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def error(self, text: str= \"\", lines = None, v= False):\n",
        "        src = sys._getframe(1).f_code.co_name\n",
        "        if src == '<module>':\n",
        "            src = MAIN\n",
        "\n",
        "        if lines: \n",
        "            for line in lines:\n",
        "                self.queue(line, ERROR_LOG, src)\n",
        "        if text:\n",
        "            self.queue(text, ERROR_LOG, src)\n",
        "            if  v:\n",
        "                print(text)\n",
        "\n",
        "    def release(self):\n",
        "        if (self.logs):\n",
        "            if self.log(logs = self.logs):\n",
        "                self.logs.clear()\n",
        "            else:\n",
        "                print(\"Logger: An error happend while trying to write log. logs are preserved.\")\n",
        "\n",
        "    def log(self, text = '', log_type= INFO_LOG,  source = MAIN, logs = []): \n",
        "        if not logs and not text:\n",
        "            return True\n",
        "        res = False\n",
        "        if text:\n",
        "            logs.append(self.makelog(text, log_type, source))\n",
        "        res = append_lines(filename = LOG_FILE, lines = logs)\n",
        "\n",
        "        if res:\n",
        "            #self.save_log()\n",
        "            return True\n",
        "        else:\n",
        "            print(\"Logger: log: An error happened while trying to write log.\")\n",
        "            return False\n",
        "\n",
        "    def save_log(self):\n",
        "        if self.log_drv and os.path.exists(self.log_drv) and os.path.isfile(LOG_FILE):\n",
        "            !rsync -I \"$log_file\" \"$log_drv_file\"\n",
        "\n",
        "logger = Logger.getInstance()   \n",
        "info = logger.info \n",
        "error = logger.error\n",
        "warning = logger.warning\n",
        "release = logger.release\n",
        "\n",
        "if not os.path.isfile(LOG_FILE):\n",
        "    logger.init(True)\n",
        "    info(f\"New Session.\")\n",
        "\n",
        "#### Setup\n",
        "\n",
        "downloads_dict = {}\n",
        "active = []\n",
        "completed = [] \n",
        "uncompleted = []\n",
        "watched_list_url = \"https://www.imdb.com/search/title/?title_type=feature&lists=ls047519430&view=simple&sort=alpha,asc&count=250&start=\"\n",
        "\n",
        "checkpoint = '.ipynb_checkpoints'\n",
        "\n",
        "class SystemConfig():\n",
        "    _instance = None\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if SystemConfig._instance == None:\n",
        "            SystemConfig()\n",
        "        return SystemConfig._instance\n",
        "    def __init__(self):\n",
        "        if SystemConfig._instance != None:\n",
        "            raise Exception(\"Logger is a singleton.\")            \n",
        "        else:\n",
        "            SystemConfig._instance = self\n",
        "\n",
        "    savetoftpconst = 1\n",
        "    savetogdriveconst = 2\n",
        "    savetoftp = False\n",
        "    driveenabled = False\n",
        "    ltenabled = True\n",
        "    activedownloads = 5\n",
        "    spotifyenabled = False\n",
        "    gdriveenabled = False\n",
        "    ftpenabled = True\n",
        "    backupenabled = False\n",
        "    ftpuser = None\n",
        "    ftppassword = None\n",
        "    ftphost = None\n",
        "    localdownloadbase = None\n",
        "    remotedownloadbase = None\n",
        "    general_path = None\n",
        "    music_path = None\n",
        "    movies_path = None\n",
        "    tv_path = None\n",
        "    moviesbackups = None\n",
        "    tvbackups = None\n",
        "    musicbackups = None\n",
        "    generalbackups = None\n",
        "    uncompleted_sources = None\n",
        "    setupthreads= set()\n",
        "    pkgs = set()\n",
        "    international_titles_list = \"ls560608427\"\n",
        "    indian_titles_list= \"ls560456074\"\n",
        "    animation_titles_list = \"ls560333050\"\n",
        "    watch_list = \"ls021271524\" # original ls021271524 or https://www.imdb.com/user/ur84959930/watchlist\n",
        "    watched_movies_list_id =\"ls047519430\"\n",
        "    watched_series_list = \"ls047701980\"\n",
        "    watched_movies_list = []\n",
        "    movie_skip_list = \"\"\n",
        "\n",
        "if not 'config' in globals():\n",
        "    config = SystemConfig.instance()\n",
        "\n",
        "def get_installed_pip_pkgs():\n",
        "    with hide:\n",
        "        cmd = !pip list\n",
        "        hide.clear_output()\n",
        "        return cmd[2:]\n",
        "\n",
        "config.pkgs = get_installed_pip_pkgs()\n",
        "\n",
        "def storageandpathes():\n",
        "    if os.path.exists(\"/content/drive\"):\n",
        "        info(\"Google drive is mounted.\")\n",
        "        config.driveenabled = True\n",
        "    else:\n",
        "        config.driveenabled = False\n",
        "    setuppathes()\n",
        "\n",
        "def setuppathes():    \n",
        "    global LOCALBASE_DEFAULT, FTPBASE_DEFAULT, DOWNLLOADSBASE_DEFAULT, MOVIES_PATH_DEFAULT, TV_PATH_DEFAULT, GENERAL_PATH_DEFAULT, MUSIC_PATH_DEFAULT\n",
        "    LOCALBASE_DEFAULT = '/content' if ENV_OS == LINUX else \"c:/td\"\n",
        "    FTPBASE_DEFAULT = '/'\n",
        "    if IS_ENV_COLAB and config.driveenabled:  DOWNLLOADSBASE_DEFAULT = \"/drive/MyDrive\"\n",
        "    else:  DOWNLLOADSBASE_DEFAULT = \"/Downloads\"\n",
        "    MOVIES_PATH_DEFAULT = f'{LOCALBASE_DEFAULT + DOWNLLOADSBASE_DEFAULT}/Movies' \n",
        "    TV_PATH_DEFAULT = f'{LOCALBASE_DEFAULT + DOWNLLOADSBASE_DEFAULT}/TV' \n",
        "    GENERAL_PATH_DEFAULT = f'{LOCALBASE_DEFAULT + DOWNLLOADSBASE_DEFAULT}'\n",
        "    MUSIC_PATH_DEFAULT = f'{LOCALBASE_DEFAULT + DOWNLLOADSBASE_DEFAULT}/Music'\n",
        "\n",
        "    config.localdownloadbase = LOCALBASE_DEFAULT\n",
        "    config.movies_path = MOVIES_PATH_DEFAULT\n",
        "    config.tv_path = TV_PATH_DEFAULT\n",
        "    config.general_path = GENERAL_PATH_DEFAULT\n",
        "    config.music_path = MUSIC_PATH_DEFAULT\n",
        "    config.moviesbackups = set()\n",
        "    config.tvbackups = set()\n",
        "    config.musicbackups = set()\n",
        "    config.generalbackups = set()\n",
        "    config.uncompleted_sources = set()    \n",
        "\n",
        "    if IS_ENV_COLAB:\n",
        "        if config.general_path:    \n",
        "            info(f\"General saving path: {config.general_path}\")\n",
        "        else:\n",
        "            error(f\"General saving path isn't set.\")\n",
        "            config.general_path = f\"{config.localdownloadbase}/Downloads\"\n",
        "\n",
        "        if config.movies_path: \n",
        "            info(f\"Movies saving path: {config.movies_path}\")\n",
        "        else:\n",
        "            error(f\"Movies saving path isn't set.\")\n",
        "            config.movies_path = f\"{config.localdownloadbase}/Movies\"\n",
        "\n",
        "        if config.tv_path:\n",
        "            info(f\"TV saving path: {config.tv_path}\")\n",
        "        else: \n",
        "            error(f\"TV saving path isn't set\")\n",
        "            config.tv_path = f\"{config.localdownloadbase}/TV Shows\"\n",
        "\n",
        "        if config.music_path:\n",
        "            info(f\"Music saving path: {config.music_path}\")\n",
        "        else:\n",
        "            error(f\"Music saving path isn't set\")\n",
        "            config.music_path = f\"{config.localdownloadbase}/Music\"\n",
        "    else:\n",
        "        config.general_path = f\"{config.localdownloadbase}/Downloads\"\n",
        "        config.movies_path = f\"{config.localdownloadbase}/Movies\"\n",
        "        config.tv_path = f\"{config.localdownloadbase}/TV Shows\"\n",
        "        config.music_path = f\"{config.localdownloadbase}/Music\"\n",
        "    os.makedirs(config.general_path, exist_ok= True)\n",
        "    os.makedirs(config.movies_path, exist_ok= True)\n",
        "    os.makedirs(config.tv_path, exist_ok= True)\n",
        "    os.makedirs(config.music_path, exist_ok= True)\n",
        "    info(f\"Downloads base is set to: {config.localdownloadbase}\")\n",
        "    if config.general_path:\n",
        "        checkuncompletesources()        \n",
        " \n",
        "def checkuncompletesources():\n",
        "    info(f\"Checking uncomplete downloads sources in: {config.general_path}/.uncomplete\")\n",
        "    p0 = config.general_path + \"/\" + \".uncomplete\"\n",
        "    if os.path.exists(p0):\n",
        "        if is_empty(p0): \n",
        "            !rm -r \"$p0\"\n",
        "        else:\n",
        "            info(f\"Adding uncomplete downloads sources: {p0}\")\n",
        "            config.uncompleted_sources.append(p0)\n",
        "\n",
        "def enablelt():\n",
        "    if  not 'ses' in globals():\n",
        "        global ses\n",
        "        ses = lt.session()\n",
        "        User_Agent = '\"Utorrent\"/3.5.5' \n",
        "        sett = {'allow_multiple_connections_per_ip': True, 'active_downloads': config.activedownloads, 'active_seeds':1, 'active_checking': 3, 'active_limit':10, 'announce_to_all_tiers': True, 'announce_to_all_trackers':True, 'allow_multiple_connections_per_ip':True, 'auto_sequential':True, 'auto_manage_interval': 30, 'connections_limit':2330, 'connection_speed': 80, 'connections_slack':50, 'close_redundant_connections':True, 'file_pool_size':20, 'local_service_announce_interval':200, 'max_rejects':8, 'max_peerlist_size': 5000, 'max_paused_peerlist_size': 2000, 'max_failcount':3, 'min_announce_interval':30, 'min_reconnect_time': 20, 'peer_timeout':20, 'request_timeout':10, 'half_open_limit': 100, 'send_buffer_watermark':5*1024*1024, 'strict_end_game_mode':True, 'seed_time_limit': 60, 'tracker_completion_timeout':30, 'upload_rate_limit':0} #'user_agent': User_Agent,'inactivity_timeout':20, 'ban_web_seeds':False,\n",
        "        ses.apply_settings(sett)\n",
        "        info(f\"LT Client session started.\\nListening ports: 6881, 6891. User agent: {User_Agent}, Active downloads: {config.activedownloads}.\")\n",
        "        for item in config.uncompleted_sources:\n",
        "            info(f\"Uncomplete source: {item}\")\n",
        "\n",
        "def normalizestring(input_str):\n",
        "    nfkd_form = unicodedata.normalize('NFKD', input_str)\n",
        "    return u\"\".join([c for c in nfkd_form if not unicodedata.combining(c)])\n",
        "\n",
        "year_pt = re.compile(r\"\\d{4}\")\n",
        "def find_title(title_raw, year_raw):\n",
        "    year = year_pt.search(year_raw)\n",
        "    year = year.group() if year else \"\"\n",
        "    title = \"{0} {1}\".format(title_raw, year)\n",
        "    table = title.maketrans(\"/\",\" \",\":'(,?)\")\n",
        "    title = title.translate(table)\n",
        "    return normalizestring(title.replace(\"&\", \"and\"))\n",
        "\n",
        "def scrape_watched_movies_list(startpage= 1, endpage = 1):\n",
        "    info(f\"Scrapping watched movies list from IMDB. URL:{watched_list_url}.\")\n",
        "    try:\n",
        "        for i in range(startpage-1, endpage):\n",
        "            currentpageurl = watched_list_url + str(i*251)\n",
        "            imdbresponse = requests.get(currentpageurl, headers = {\"Accept-Language\": \"en-US\"})\n",
        "            soup = Soup(imdbresponse.text,'html.parser')    \n",
        "            scrape = soup.find(\"div\", {\"class\":\"lister-list\"})\n",
        "            if not scrape :\n",
        "                return\n",
        "            all_items = scrape.findAll(class_=\"lister-item-header\")\n",
        "            for i in range(len(all_items)):\n",
        "                year_raw = all_items[i].find(class_=\"lister-item-year\").text\n",
        "                title_raw = all_items[i].a.text\n",
        "                title = find_title(title_raw, year_raw)      \n",
        "                config.watched_movies_list.append(title)\n",
        "        info(f\"Scrapped watched movies: {len(config.watched_movies_list)} movie.\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    \n",
        "def installpippkg(pkg):\n",
        "    with hide:\n",
        "        cmd = f\"pip install {pkg} {NULL_STREAM}\"\n",
        "        o = !$cmd \n",
        "        hide.clear_output()\n",
        "    return True\n",
        "\n",
        "def uninstallpippkg(pkg):\n",
        "    with hide:\n",
        "        cmd = f\"pip uninstall {pkg} -y {NULL_STREAM}\"\n",
        "        o = !$cmd\n",
        "        hide.clear_output()\n",
        "    return True\n",
        "\n",
        "SETUP_LT = \"setup_lt\"\n",
        "DRIVE_AND_PATHES = \"enable_drive\"\n",
        "SCRAPE_WATCHED_LIST = \"scrape_watched_list\"\n",
        "\n",
        "if IS_ENV_COLAB and not 'init' in globals():   \n",
        "    info(\"Installing requirments packages.\")\n",
        "    # pathestask = Thread(target= storageandpathes)\n",
        "    # pathestask.name = DRIVE_AND_PATHES\n",
        "    # config.setupthreads.add(pathestask)\n",
        "    # pathestask.start()\n",
        "    def setup_lt():\n",
        "        if not 'libtorrent' in config.pkgs:\n",
        "            try:\n",
        "                info(\"Installing package 'libtorrent'\")\n",
        "                installpippkg('libtorrent')\n",
        "                config.pkgs.append('libtorrent')\n",
        "            except Exception as e:\n",
        "                error(ex())\n",
        "                updatestatushtml('An error happened while enabling lt.', ERROR_EVENT)\n",
        "        if not 'lt' in globals():  \n",
        "                global  lt\n",
        "                import libtorrent as lt\n",
        "                info(\"Package 'libtorrent' was installed and in imported to environment.\")\n",
        "                enablelt()      \n",
        "        else:\n",
        "            info(\"Package 'lt' is already installed.'\")\n",
        "        appstate.ltready = True                \n",
        "        release()\n",
        "\n",
        "    enable_lt_task = Thread(target= setup_lt)\n",
        "    enable_lt_task.name = SETUP_LT\n",
        "    config.setupthreads.add(enable_lt_task)\n",
        "    enable_lt_task.start()\n",
        "    if not config.watched_movies_list:\n",
        "        scrape_watchedmovielist_task = Thread(target= scrape_watched_movies_list, args=(1,2))\n",
        "        scrape_watchedmovielist_task.name = SCRAPE_WATCHED_LIST\n",
        "        config.setupthreads.add(scrape_watchedmovielist_task)\n",
        "        scrape_watchedmovielist_task.start()\n",
        "\n",
        "storageandpathes()\n",
        "\n",
        "def arethreadsworking(threadset: set[Thread], v= False):\n",
        "    alivethreads = set()\n",
        "    for thread in threadset:\n",
        "        if thread.is_alive():\n",
        "            alivethreads.add(thread.name)\n",
        "            if v:  print(f'Alive: {thread.name}')\n",
        "    return alivethreads if alivethreads else False\n",
        "\n",
        "##\n",
        "\n",
        "import urllib\n",
        "import pandas as pd\n",
        "import panel as pn\n",
        "from bokeh.models.widgets.tables import CheckboxEditor, HTMLTemplateFormatter\n",
        "pn.extension('tabulator')\n",
        "from IPython.display import Javascript\n",
        "import ipywidgets as widgets\n",
        "from ipywidgets import VBox, HBox, Box, HTML, Text, FloatProgress, Button, Label, Dropdown, DatePicker, Checkbox, Layout\n",
        "import __main__ as main\n",
        "main.__file__ = \"main_file\"\n",
        "\n",
        "# init UI\n",
        "\n",
        "INFO_EVENT = 0\n",
        "ERROR_EVENT = 10\n",
        "SUCCUSS = 20\n",
        "\n",
        "BLUE_COLOR = '#085fb1'\n",
        "LIGHTBLUE_COLOR = '#469dff'\n",
        "LIGHTGREY_COLOR = '#c2c2c2'\n",
        "DARKGERYCOLOR = '#474747'\n",
        "ORANGE_500 = '#FF9800'\n",
        "\n",
        "ACCENT_COLOR = BLUE_COLOR\n",
        "SUCCESS_COLOR = '#039129'\n",
        "FAIL_COLOR = '#9c0909'\n",
        "LOADING_COLOR = '#d96d1a'\n",
        "WARNING_COLOR = ORANGE_500\n",
        "\n",
        "FONTFAMILY_GLOBAL = 'system-ui'\n",
        "MESSAGE_CONTAINER_HEIGHT = '250px'\n",
        "MESSAGE_CONTAINER_PADDING = '15% 0 0 0' \n",
        "MAINBOX_HEIGHT = '800px'\n",
        "\n",
        "def gethtmltext(text, tag= \"span\", elid=\"\", elclass= \"\", fontsize= \"18px\", style= \"\", color= ACCENT_COLOR, animated= False):\n",
        "    if not elid:\n",
        "        elid = 'el' + rand()\n",
        "    colorstyle = f\"color: {color};\" if color != ACCENT_COLOR else ''\n",
        "    animation = getcssblinkanimation(color= color, elementid= elid) if animated else ''\n",
        "    return f'<{tag} id=\"{elid}\" class=\"{elclass}\" style=\"font-size: {fontsize}; {colorstyle} {style}\">{text}</{tag}>{animation}'\n",
        "\n",
        "def getcssblinkanimation(color, elementid = \"\", elementclass = \"\"):\n",
        "    if not elementclass and not elementid:\n",
        "        return None\n",
        "    shadecolor = color[:-2] + '2c' if len(color) == 9 else color + '2c'\n",
        "    styletag = '<style>'\n",
        "    idpart = f'#{elementid}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementid else \"\"\n",
        "    animationpart = f' @keyframes color-change {{ 0% {{ color: {color}; }} 50% {{ color: {shadecolor}; }} 100% {{ color: {color} ; }} }}</style>'\n",
        "    classpart = f'.{elementclass}{{'f' color: {color}; animation: color-change 2s infinite; transition: .4s}}' if elementclass else \"\"\n",
        "    return styletag + idpart + classpart + animationpart\n",
        "\n",
        "def getloadingview(text):\n",
        "    elid= 'el-' + rand()\n",
        "    t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    spinnerhtml = \"<div class=loadingio-spinner-spinner-m4dbaxm5cdf><div class=ldio-orkmsj9nbq><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><style>@keyframes ldio-orkmsj9nbq{0%{opacity:1}100%{opacity:0}}.ldio-orkmsj9nbq div{left:47px;top:16px;position:absolute;animation:ldio-orkmsj9nbq linear 1.1111111111111112s infinite;background:#184cad;width:6px;height:12px;border-radius:2.16px;transform-origin:3px 34px}.ldio-orkmsj9nbq div:first-child{transform:rotate(0);animation-delay:-1.0185185185185184s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(2){transform:rotate(30deg);animation-delay:-.9259259259259258s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(3){transform:rotate(60deg);animation-delay:-.8333333333333333s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(4){transform:rotate(90deg);animation-delay:-.7407407407407407s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(5){transform:rotate(120deg);animation-delay:-.6481481481481481s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(6){transform:rotate(150deg);animation-delay:-.5555555555555555s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(7){transform:rotate(180deg);animation-delay:-.4629629629629629s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(8){transform:rotate(210deg);animation-delay:-370.3703703703703ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(9){transform:rotate(240deg);animation-delay:-277.7777777777777ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(10){transform:rotate(270deg);animation-delay:-.18518518518518517s;background:#184cad}.ldio-orkmsj9nbq div:nth-child(11){transform:rotate(300deg);animation-delay:-92.59259259259258ms;background:#184cad}.ldio-orkmsj9nbq div:nth-child(12){transform:rotate(330deg);animation-delay:0s;background:#184cad}.loadingio-spinner-spinner-m4dbaxm5cdf{width:100px;height:100px;display:inline-block;overflow:hidden;background:0 0}.ldio-orkmsj9nbq{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-orkmsj9nbq div{box-sizing:content-box}</style>\"\n",
        "    loading_container = f'<div style=\"height:{MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text + \" \", elid= elid, style= t1style, fontsize= \"32px\")} {spinnerhtml}</div>' + getcssblinkanimation(color= ACCENT_COLOR, elementid=elid)\n",
        "    loadingview = HTML(loading_container)\n",
        "    loadingview.name = \"Loading\"\n",
        "    return loadingview\n",
        "\n",
        "\n",
        "#### Init / utils\n",
        "\n",
        "def check_pip_pgks_installed(check_pkgs, installmissing = False, v= False):\n",
        "    pkgre = r'^[A-Za-z0-9\\-]+'\n",
        "    for pkg in config.pkgs:\n",
        "        mch = re.search(pkgre, pkg)\n",
        "        res = mch.group()\n",
        "        if res in check_pkgs:\n",
        "            check_pkgs.remove(res)\n",
        "        if len(check_pkgs) == 0:\n",
        "            break\n",
        "    if check_pkgs:\n",
        "        if installmissing:\n",
        "            for pkg in check_pkgs:\n",
        "                installpippkg(pkg)\n",
        "            return True            \n",
        "        else:    \n",
        "            msg = f'Missing packages: {\", \".join(check_pkgs)}'\n",
        "            if v:\n",
        "                print(msg)\n",
        "            return check_pkgs\n",
        "    else:\n",
        "        return True\n",
        "    \n",
        "def getattrs(obj):\n",
        "    attrs = []\n",
        "    for attrs in dir(obj):\n",
        "        if not attrs.startswith(\"__\"):\n",
        "            attrs.append((attrs, getattr(obj, attrs)))\n",
        "    return attrs\n",
        "\n",
        "def getattrstr(obj, filter = True, filter_empty = False, add_line = False):\n",
        "    attrstr = ''\n",
        "    pre = '\\n' if add_line else ', '\n",
        "    i = True\n",
        "    for attrs in dir(obj):\n",
        "        if filter and attrs.startswith(\"__\"):\n",
        "            continue\n",
        "        val = getattr(obj, attrs)\n",
        "        if filter_empty and not val:\n",
        "            continue\n",
        "        if i :\n",
        "            attrstr += \"%s =  %r\" % (attrs, val)\n",
        "            i = False\n",
        "        else:\n",
        "            attrstr += \"%s%s =  %r\" % (pre, attrs, getattr(obj, attrs))\n",
        "    return attrstr\n",
        "\n",
        "from collections.abc import Iterable\n",
        "from types import NoneType\n",
        "\n",
        "def dump(obj, filterprefixed = True, getvalues= True, gettypes= False, types= set(), filtertypes= set()):\n",
        "    output = ''\n",
        "    i = 0\n",
        "    if isinstance(obj, dict):\n",
        "        iterables = dict()\n",
        "        for key in obj.keys():\n",
        "            val = obj[key]\n",
        "            if (not type(val) == str) and isinstance(val, Iterable):\n",
        "                iterables[key] = val \n",
        "                continue\n",
        "            val = str(val)\n",
        "            val = val[:45] + '...' if len(val) > 45 else val\n",
        "            output += f\"{key:>25}:    {val:<50}\"\n",
        "            if not (i + 1) % 2:\n",
        "                output += '\\n'\n",
        "            i += 1\n",
        "        if iterables:\n",
        "            output += f\"\\n   {(' ' * 25).join(iterables)}\\n\"\n",
        "            check = True\n",
        "            while check:\n",
        "                output = ''\n",
        "                check = False\n",
        "                for key in iterables:\n",
        "                    iter = iterables[key]\n",
        "                    if i < len(iter):\n",
        "                        check = True\n",
        "                        val = f\"{i:>3}  {iter[i]}\"\n",
        "                    else:\n",
        "                        val = ''\n",
        "                    output += f\"{val:<35}\"\n",
        "                i += 1  \n",
        "\n",
        "    elif isinstance(obj, Iterable):\n",
        "        for item in obj:\n",
        "            val = str(item)\n",
        "            val = val[:30] + '...' if len(val) > 30 else val\n",
        "            output += f\"{i:>3}  {val:<35}\"\n",
        "            if not (i + 1) % 3:\n",
        "                output += '\\n'\n",
        "            i += 1\n",
        "\n",
        "    elif isinstance(obj, object):\n",
        "        attrs = dir(obj)\n",
        "        attrs.sort()\n",
        "        class_pt = re.compile(r\"(?<=<class ')([^']+)\")\n",
        "        for attrname in attrs:\n",
        "            try:\n",
        "                attrval = getattr(obj, attrname)\n",
        "                type1 = type(attrval)\n",
        "                typestr = class_pt.search(str(type1)).group()\n",
        "                if (filterprefixed and attrname.startswith(\"_\")) or (types and not type1 in types) or (filtertypes and (type1 in filtertypes)):\n",
        "                    continue\n",
        "            except:\n",
        "                attrval = \"couldn't get value.\"\n",
        "\n",
        "            if getvalues:\n",
        "                val = str(attrval)\n",
        "                val = val[:42] + '...' if len(val) > 42 else val\n",
        "                val = f\"   {val:<45}\"\n",
        "            else:\n",
        "                val = ''\n",
        "\n",
        "            typestr = f'   {typestr:<30}' if gettypes else ''\n",
        "            if getvalues and gettypes: name = f\"{attrname:>25}\" \n",
        "            elif getvalues: name = f\"{attrname:>60}\" \n",
        "            else: name = f\"{attrname:>25}\"\n",
        "\n",
        "            if (getvalues and not (i + 1) % 2) or (not getvalues and not (i + 1) % 3):\n",
        "                out = name + typestr + val + '\\n'\n",
        "            else:\n",
        "                out = name + typestr + val\n",
        "            output += out\n",
        "            i += 1\n",
        "    print(output)\n",
        "\n",
        "def list_lines(lines, str = False):\n",
        "    if lines:\n",
        "        if str:\n",
        "            rtn = ''\n",
        "            for r in lines:\n",
        "                if r:\n",
        "                    rtn += (r +'\\n')\n",
        "            return rtn\n",
        "        if not str:  \n",
        "            for line in lines:\n",
        "                print(line)\n",
        "#\n",
        "\n",
        "import string\n",
        "SMALL = r'a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v\\.?|via|vs\\.?'\n",
        "PUNCT = r\"\"\"!\"“#$%&'‘()*+,\\-–‒—―./:;?@[\\\\\\]_`{|}~\"\"\"\n",
        "\n",
        "SMALL_WORDS = re.compile(r'^(%s)$' % SMALL, re.I)\n",
        "SMALL_FIRST = re.compile(r'^([%s]*)(%s)\\b' % (PUNCT, SMALL), re.I)\n",
        "SMALL_LAST = re.compile(r'\\b(%s)[%s]?$' % (SMALL, PUNCT), re.I)\n",
        "SUBPHRASE = re.compile(r'([:.;?!\\-–‒—―][ ])(%s)' % SMALL)\n",
        "MAC_MC = re.compile(r\"^([Mm]c|MC)(\\w.+)\")\n",
        "MR_MRS_MS_DR = re.compile(r\"^((m((rs?)|s))|Dr)$\", re.I)\n",
        "INLINE_PERIOD = re.compile(r'[\\w][.][\\w]', re.I)\n",
        "UC_ELSEWHERE = re.compile(r'[%s]*?[a-zA-Z]+[A-Z]+?' % PUNCT)\n",
        "CAPFIRST = re.compile(r\"^[%s]*?([\\w])\" % PUNCT)\n",
        "APOS_SECOND = re.compile(r\"^[dol]['‘][\\w]+(?:['s]{2})?$\", re.I)\n",
        "UC_INITIALS = re.compile(r\"^(?:[A-Z]\\.|[A-Z]\\.[A-Z])+$\")\n",
        "\n",
        "class Immutable(object):\n",
        "    pass\n",
        "class ImmutableString(str, Immutable):\n",
        "    pass\n",
        "class ImmutableBytes(bytes, Immutable):\n",
        "    pass\n",
        "\n",
        "def _mark_immutable(text):\n",
        "    if isinstance(text, bytes):\n",
        "        return ImmutableBytes(text)\n",
        "    return ImmutableString(text)\n",
        "\n",
        "def set_small_word_list(small=SMALL):\n",
        "    global SMALL_WORDS, SMALL_FIRST, SMALL_LAST, SUBPHRASE\n",
        "    SMALL_WORDS = re.compile(r'^(%s)$' % small, re.I)\n",
        "    SMALL_FIRST = re.compile(r'^([%s]*)(%s)\\b' % (PUNCT, small), re.I)\n",
        "    SMALL_LAST = re.compile(r'\\b(%s)[%s]?$' % (small, PUNCT), re.I)\n",
        "    SUBPHRASE = re.compile(r'([:.;?!][ ])(%s)' % small)\n",
        "\n",
        "def title(text, callback=None, small_first_last=True):\n",
        "    \"\"\"\n",
        "    text: Titlecases input text\n",
        "    callback: Callback function that returns the title-case version of a specific word\n",
        "    small_first_last: Capitalize small words (e.g. 'A') at the beginning; disabled when recursing\n",
        "\n",
        "    Changes all words to Title Caps, and attempts to be clever about capitalizing SMALL words like a/an/the in the input.\n",
        "    The list of \"SMALL words\" which are not capped comes from the New York Times Manual of Style, plus 'vs' and 'v'.\n",
        "    \"\"\"\n",
        "    lines = re.split('[\\r\\n]+', text)\n",
        "    processed = []\n",
        "    for line in lines:\n",
        "        all_caps = line.upper() == line\n",
        "        words = re.split('[\\t ]', line)\n",
        "        tc_line = []\n",
        "        for word in words:\n",
        "            if callback:\n",
        "                new_word = callback(word, all_caps=all_caps)\n",
        "                if new_word:\n",
        "                    # Address #22: If a callback has done something\n",
        "                    # specific, leave this string alone from now on\n",
        "                    tc_line.append(_mark_immutable(new_word))\n",
        "                    continue\n",
        "\n",
        "            if all_caps:\n",
        "                if UC_INITIALS.match(word):\n",
        "                    tc_line.append(word)\n",
        "                    continue\n",
        "\n",
        "            if APOS_SECOND.match(word):\n",
        "                if len(word[0]) == 1 and word[0] not in 'aeiouAEIOU':\n",
        "                    word = word[0].lower() + word[1] + word[2].upper() + word[3:]\n",
        "                else:\n",
        "                    word = word[0].upper() + word[1] + word[2].upper() + word[3:]\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "\n",
        "            match = MAC_MC.match(word)\n",
        "            if match:\n",
        "                tc_line.append(\"%s%s\" % (match.group(1).capitalize(),\n",
        "                                         title(match.group(2), callback, True)))\n",
        "                continue\n",
        "\n",
        "            match = MR_MRS_MS_DR.match(word)\n",
        "            if match:\n",
        "                word = word[0].upper() + word[1:]\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "\n",
        "            if INLINE_PERIOD.search(word) or (not all_caps and UC_ELSEWHERE.match(word)):\n",
        "                tc_line.append(word)\n",
        "                continue\n",
        "            if SMALL_WORDS.match(word):\n",
        "                tc_line.append(word.lower())\n",
        "                continue\n",
        "\n",
        "            if \"/\" in word and \"//\" not in word:\n",
        "                slashed = map(\n",
        "                    lambda t: title(t,callback,False),\n",
        "                    word.split('/')\n",
        "                )\n",
        "                tc_line.append(\"/\".join(slashed))\n",
        "                continue\n",
        "\n",
        "            if '-' in word:\n",
        "                hyphenated = map(\n",
        "                    lambda t: title(t, callback, False),\n",
        "                    word.split('-')\n",
        "                )\n",
        "                tc_line.append(\"-\".join(hyphenated))\n",
        "                continue\n",
        "\n",
        "            if all_caps:\n",
        "                word = word.lower()\n",
        "\n",
        "            # A term with all consonants should be considered an acronym.  But if it's\n",
        "            # too short (like \"St\", don't apply this)\n",
        "            CONSONANTS = ''.join(set(string.ascii_lowercase)\n",
        "                                 - {'a', 'e', 'i', 'o', 'u', 'y'})\n",
        "            is_all_consonants = re.search('\\A[' + CONSONANTS + ']+\\Z', word,\n",
        "                                             flags= re.IGNORECASE)\n",
        "            if is_all_consonants and len(word) > 2:\n",
        "                tc_line.append(word.upper())\n",
        "                continue\n",
        "\n",
        "            # Just a normal word that needs to be capitalized\n",
        "            tc_line.append(CAPFIRST.sub(lambda m: m.group(0).upper(), word))\n",
        "\n",
        "        if small_first_last and tc_line:\n",
        "            if not isinstance(tc_line[0], Immutable):\n",
        "                tc_line[0] = SMALL_FIRST.sub(lambda m: '%s%s' % (\n",
        "                    m.group(1),\n",
        "                    m.group(2).capitalize()\n",
        "                ), tc_line[0])\n",
        "\n",
        "            if not isinstance(tc_line[-1], Immutable):\n",
        "                tc_line[-1] = SMALL_LAST.sub(lambda m: m.group(0).capitalize(), tc_line[-1])\n",
        "\n",
        "        result = \" \".join(tc_line)\n",
        "        result = SUBPHRASE.sub(lambda m: '%s%s' % (\n",
        "            m.group(1),\n",
        "            m.group(2).capitalize()\n",
        "        ), result)\n",
        "        processed.append(result)\n",
        "    result = \"\\n\".join(processed)\n",
        "    return result\n",
        "\n",
        "##\n",
        "\n",
        "size_limit = 40000\n",
        "def pathsize(path, string = False):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "      for path, dirs, files in os.walk(path):\n",
        "          for f in files:\n",
        "              fp = os.path.join(path, f)\n",
        "              size += os.path.getsize(fp)\n",
        "    if string:\n",
        "        return data_str(size)\n",
        "    else:\n",
        "        return size\n",
        "\n",
        "def has_size(path, only_check = True):\n",
        "    size = 0\n",
        "    if not os.path.exists(path):\n",
        "        return 0\n",
        "    if os.path.isfile(path):\n",
        "        size = os.path.getsize(path)\n",
        "    else:  \n",
        "        for path, dirs, files in os.walk(path):\n",
        "            for f in files:\n",
        "                fp = os.path.join(path, f)\n",
        "                size += os.path.getsize(fp)\n",
        "                if only_check and size >= size_limit:\n",
        "                    return size\n",
        "    if size >= size_limit:\n",
        "        return size\n",
        "    else:\n",
        "        return 0\n",
        "\n",
        "def compare_files_with_size(file1, file2):\n",
        "    if not (os.path.isfile(file1) and os.path.isfile(file2)):\n",
        "        return False\n",
        "    return os.path.getsize(file1) == os.path.getsize(file2)\n",
        "\n",
        "def is_hidden(path):\n",
        "    return True if path[0] == '.' else False\n",
        "\n",
        "def filter_checks(dirs):\n",
        "    for dir in dirs:\n",
        "        if dir.endswith('ipynb_checkpoints'):\n",
        "            dirs.remove(dir)\n",
        "    return dirs\n",
        "\n",
        "def print_files(drs, range_start , range_end):\n",
        "    for i in range(range_start, range_end):\n",
        "        print(\"   {0}-  {1}\".format(i+1, drs[i])) \n",
        "\n",
        "def data_str(byte_val):\n",
        "    size = ByteToGB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} GB\".format(size)\n",
        "    size = ByteToMB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} MB\".format(size)\n",
        "    size = ByteToKB(byte_val)\n",
        "    if (size >= 1):\n",
        "        return \"{:.1f} KB\".format(size)\n",
        "    return \"{:.1f} B\".format(size)\n",
        "\n",
        "def speed_str(byte_val):\n",
        "    size_mb = ByteToMB(byte_val)\n",
        "    if (size_mb >= 1):\n",
        "        return \"{:.1f} MB\".format(size_mb)\n",
        "    else:\n",
        "        return \"{:.1f} KB\".format(ByteToKB(byte_val))\n",
        "    \n",
        "def RoundTo1(n) :\n",
        "    if n < 1 and (n - 0.9765625) >= 0 :\n",
        "        return 1\n",
        "    else: \n",
        "        return n\n",
        "\n",
        "def is_empty(path):  \n",
        "    if os.path.isdir(path):\n",
        "        dircontent = os.listdir(path)\n",
        "        if len(dircontent) == 0 or (len(dircontent) == 1 and contains(checkpoint, dircontent[0])):\n",
        "            return True      \n",
        "    return False\n",
        "\n",
        "def startswith(a: str, b: str):\n",
        "    a = a.strip()\n",
        "    b = b.strip()\n",
        "    if len(a) >= len(b):\n",
        "        a1 = a\n",
        "        b1 = b\n",
        "    else:\n",
        "        a1 = b\n",
        "        b1 = a\n",
        "    if a1.startswith(b1):\n",
        "        return True\n",
        "    return b1.startswith(a1)\n",
        "\n",
        "contains = lambda string, search: search.lower() in string.lower()\n",
        "time_str = lambda sec: time.strftime('%H:%M:%S', time.gmtime(sec))\n",
        "ByteToGB = lambda n: RoundTo1(n / 1073741824)\n",
        "ByteToMB = lambda n: RoundTo1(n/ 1048576)\n",
        "ByteToKB = lambda n: RoundTo1(n/ 1024)\n",
        "\n",
        "class AppState:\n",
        "    @staticmethod\n",
        "    def instance():\n",
        "        if not AppState._state:\n",
        "            AppState._state = AppState()\n",
        "        return AppState._state\n",
        "    def __init__(self):\n",
        "        if AppState._state:\n",
        "            raise('AppState is singlton.')\n",
        "        AppState._state = self\n",
        "    _state = None\n",
        "    running = False\n",
        "    ltready = False\n",
        "    watchedlistready = False\n",
        "    driveready = False\n",
        "    ftpready = False\n",
        "    currentviewcontainer = None\n",
        "    monitorthread: Thread = None\n",
        "    monitoralive= False\n",
        "    transferthread: Thread = None\n",
        "    transferalive= False\n",
        "    addthread: Thread = None\n",
        "    addalive = False\n",
        "    metacheckerthread: Thread = False\n",
        "    metacheckeralive= False\n",
        "    total_wanted = total_up = total_progress = active_down = active_up = completed_up = completed_down = 0\n",
        "    total_downloads= downloadings = deads = transferings = completed = 0\n",
        "    addresults = []\n",
        "    bulksearch = None\n",
        "    searchresults = []\n",
        "    backthreads = {}\n",
        "    clicktasks = []\n",
        "    clicktaskstates = {}\n",
        "    navactions = []\n",
        "    tab_indices = {}\n",
        "\n",
        "appstate = AppState.instance()\n",
        "nav = {}\n",
        "CONFIG_TAB = 'configuration'\n",
        "SEARCH_TAB = 'search'\n",
        "IMDB_TAB = 'IMDB search'\n",
        "ADD_TAB = 'adding'\n",
        "MONITOR_TAB = 'monitor'\n",
        "\n",
        "#### Init / Reqs\n",
        "\n",
        "def setupreqs():\n",
        "    reqs = set()\n",
        "    if config.ftpenabled:\n",
        "        reqs.add('ftputil')\n",
        "        if IS_ENV_COLAB:\n",
        "            !sudo apt-get install lftp $NULL_STREAM \n",
        "    if config.spotifyenabled:\n",
        "        reqs.add('savify')\n",
        "    if config.ftpenabled:\n",
        "        global ftputil\n",
        "        import ftputil \n",
        "    check_pip_pgks_installed(reqs, True)\n",
        "\n",
        "#### Init / Pathes\n",
        "\n",
        "done_path = \"/content/done\"\n",
        "temp_save=\"/content/d-0\" \n",
        "added_path = \"/content/added\"\n",
        "if IS_ENV_COLAB:\n",
        "    os.makedirs(done_path, exist_ok=True)\n",
        "    os.makedirs(added_path, exist_ok=True) \n",
        "    os.makedirs(temp_save, exist_ok=True)\n",
        "\n",
        "path_movie = lambda mv: config.movies_path + \"/\" + mv\n",
        "path_tvshow = lambda tvshow: config.tv_path + \"/\" + tvshow\n",
        "path_season = lambda tvshow, season: config.tv_path + \"/\" + tvshow + \"/\" + season\n",
        "path_episode = lambda tvshow, season, eps: config.tv_path + \"/\" + tvshow + \"/\" + season + \"/\" + eps\n",
        "joinpath = lambda start, dir: start + \"/\" + dir \n",
        "\n",
        "def getsdbackup(path: str, bakid = \"\", bak_index = 0): #fix backup\n",
        "    return\n",
        "\n",
        "#### API / Consts\n",
        "\n",
        "skip_list = ['.txt','.inf','.info','.nfo','www.yts','rarbg_do_not']\n",
        "subtitlefile_extensions = {\".srt\", \".vtt\", \".sbv\", \".ssa\", \".dfxp\", \".ttml\", \".sup\", \".idx\"}\n",
        "\n",
        "today = date.today()\n",
        "thisyear = str(today.year)\n",
        "\n",
        "SUCCUSS = 200\n",
        "FAIL = 300\n",
        "GENERAL = 101\n",
        "SOFTWARE = 102\n",
        "GAMES = 103\n",
        "MOVIE = 201\n",
        "TV = 300\n",
        "SHOW = 301\n",
        "SEASON = 302\n",
        "EPISODE = 303\n",
        "MUSIC = 401\n",
        "ALBUM = 402\n",
        "TRACK = 403\n",
        "X1337X = '1337x'\n",
        "IMDB = 'IMDB'\n",
        "RARBG = 'rarbg'\n",
        "\n",
        "ALLCATEGORIES_TD = ''\n",
        "MOVIESCATEGORY_TD = \"movies\"\n",
        "TVCATEGORY_TD = \"tv\"\n",
        "APPSCATEGORY_TD = \"apps\"\n",
        "GAMESCATEGORY_TD = \"games\"\n",
        "\n",
        "SEEDERSSORT = \"td-seeders\"\n",
        "TIMESORT = \"td-time\"\n",
        "SIZESORT = \"td-size\"\n",
        "ASCORDER = \"td-asc\"\n",
        "DESCORDER = \"td-desc\"\n",
        "\n",
        "type_category = {MOVIE: MOVIESCATEGORY_TD , TV: TVCATEGORY_TD, SHOW: TVCATEGORY_TD, SEASON: TVCATEGORY_TD, EPISODE: TVCATEGORY_TD, SOFTWARE :APPSCATEGORY_TD, GAMES :GAMESCATEGORY_TD, GENERAL: ALLCATEGORIES_TD}\n",
        "\n",
        "HASH_ADDSOURCE = \"download hash\"\n",
        "LOCALFILE_ADDSOURCE = \"local file\"\n",
        "UPLOADFILE_ADDSOURCE = \"uploaded file\"\n",
        "MAGNET_ADDSOURCE = \"magnet\"\n",
        "FILEURL_ADDSOURCE = \"file url\"\n",
        "\n",
        "## 1337x\n",
        "\n",
        "X1337XPROXEY_BASE = 'https://1337x.unblockit.esq'\n",
        "X1337X_BASE = 'https://1337x.to'\n",
        "X1337X_TV = \"TV\"\n",
        "X1337X_MOVIES = \"Movies\"\n",
        "X1337X_APPS = \"Apps\"\n",
        "X1337X_GAMES = \"Games\"\n",
        "X1337X_SEEDERS = \"seeders/desc\"\n",
        "X1337X_SIZE_ASC = \"size/asc\"\n",
        "X1337X_SIZE_DESC = \"size/desc\"\n",
        "X1337X_TIME_ASC = \"time/asc\"\n",
        "X1337X_TIME_DESC = \"time/desc\"\n",
        "\n",
        "## RARBG\n",
        "\n",
        "RARBG_MOVIE_XVID = 14\n",
        "RARBG_MOVIE_XVID_720P = 48\n",
        "RARBG_MOVIE_H264 = 17\n",
        "RARBG_MOVIE_H264_720P = 45\n",
        "RARBG_MOVIE_H264_1080P = 44\n",
        "RARBG_MOVIE_H264_3D = 47\n",
        "RARBG_MOVIE_H265_1080P = 54\n",
        "RARBG_MOVIE_H264_4K = 50\n",
        "RARBG_MOVIE_H265_4K = 51\n",
        "RARBG_MOVIE_H264_4K_HDR = 52\n",
        "RARBG_MOVIE_H265 = [RARBG_MOVIE_H265_1080P, RARBG_MOVIE_H265_4K,  RARBG_MOVIE_H264_4K_HDR]\n",
        "RARBG_MOVIE_ISOFULL_HD = 42\n",
        "RARBG_MOVIE_HD_REMUX = 46\n",
        "RARBG_TV_EPISODES = 18\n",
        "RARBG_TV_EPISODES_HD = 41\n",
        "RARBG_TV_EPISODES_UHD = 49\n",
        "RARBG_MUSIC_MP3 = 23\n",
        "RARBG_MUSIC_FLAC = 25\n",
        "RARBG_GAMES_PC_ISO = 27\n",
        "RARBG_GAMES_PC_RIP = 28\n",
        "RARBG_GAMES_PS3 = 40\n",
        "RARBG_GAMES_PS4 = 53\n",
        "RARBG_GAMES_XBOX = 32\n",
        "RARBG_SOFTWARE = 33\n",
        "RARBG_EBOOK = 35\n",
        "RARBG_MOVIE = [RARBG_MOVIE_H264] + RARBG_MOVIE_H265\n",
        "RARBG_TV = [RARBG_TV_EPISODES, RARBG_TV_EPISODES_HD, RARBG_TV_EPISODES_UHD]\n",
        "SORTRARBG_SEEDERS = 'seeders'\n",
        "SORTRARBG_TIME = 'last'\n",
        "\n",
        "## IMDB\n",
        "\n",
        "IMDB_BASE = \"https://www.imdb.com\"\n",
        "IMDB_MOVIE_TITLE = \"feature\"\n",
        "IMDB_TV_TITLE = \"tv_series\"\n",
        "IMDB_ANY_TITLE = \"\"\n",
        "IMDB_URI_HEAD = \"https://www.imdb.com/title/\"    \n",
        "IMDB_EXCULDE_MARK=\"%21\"\n",
        "IMDB_DATE_SORT = \"release_date\"\n",
        "IMDB_RATING_SORT = \"user_rating\"\n",
        "IMDB_ALPHABETICAL_SORT = \"alpha\"\n",
        "IMDB_TOP_250 =\"top_250\"\n",
        "IMDB_TOP_1000 = \"top_1000\"\n",
        "IMDB_OSCAR_WINNER = \"oscar_winner\"\n",
        "IMDB_BEST_PICTURE_WINNER = \"best_picture_winner\"\n",
        "IMDB_BEST_DIRECTOR_WINNER = \"best_director_winner\"\n",
        "\n",
        "##\n",
        "\n",
        "new_trackers = [\"udp://tracker.opentrackr.org:1337/announce\", \"udp://tracker.internetwarriors.net:1337/announce\", \"udp://exodus.desync.com:6969/announce\", \"udp://tracker.cyberia.is:6969/announce\", \"udp://3rt.tace.ru:60889/announce\", \"http://5rt.tace.ru:60889/announce\", \"udp://explodie.org:6969/announce\", \"udp://47.ip-51-68-199.eu:6969/announce\", \"udp://opentracker.i2p.rocks:6969/announce\", \"http://open.acgnxtracker.com:80/announce\", \"udp://www.torrent.eu.org:451/announce\", \"udp://tracker.torrent.eu.org:451/announce\", \"udp://tracker.tiny-vps.com:6969/announce\", \"udp://tracker.ds.is:6969/announce\", \"udp://retracker.lanta-net.ru:2710/announce\", \"udp://open.stealth.si:80/announce\", \"udp://tracker.moeking.me:6969/announce\", \"udp://ipv4.tracker.harry.lu:80/announce\", \"http://tracker.dler.org:6969/announce\", \"http://rt.tace.ru:80/announce\", \"udp://93.158.213.92:1337/announce\", \"udp://138.255.103.83:1337/announce\", \"udp://208.83.20.20:6969/announce\", \"udp://193.218.118.220:6969/announce\", \"udp://79.111.118.59:60889/announce\", \"http://93.157.234.32:60889/announce\", \"udp://184.105.151.164:6969/announce\", \"udp://51.68.199.47:6969/announce\", \"udp://51.81.46.170:6969/announce\", \"udp://91.216.110.52:451/announce\", \"udp://89.234.156.205:451/announce\", \"udp://5.206.60.196:6969/announce\", \"udp://5.226.148.20:6969/announce\", \"udp://37.235.174.46:2710/announce\", \"udp://185.181.60.67:80/announce\", \"udp://138.201.150.56:6969/announce\", \"udp://51.15.40.114:80/announce\", \"http://168.119.237.9:6969/announce\", \"http://195.201.31.194:80/announce\", \"https://trakx.herokuapp.com:443/announce\", \"https://w.wwwww.wtf:443/announce\", \"https://tracker.tamersunion.org:443/announce\", \"https://tracker.sloppyta.co:443/announce\", \"https://tracker.renfei.net:443/announce\", \"https://tracker.nitrix.me:443/announce\",\n",
        "              \"https://tracker.nanoha.org:443/announce\", \"https://tracker.lelux.fi:443/announce\", \"https://tracker.imgoingto.icu:443/announce\", \"https://tracker.hama3.net:443/announce\", \"https://tracker.foreverpirates.co:443/announce\", \"http://tracker2.wasabii.com.tw:6969/announce\", \"udp://tracker.sktorrent.net:6969/announce\", \"http://www.wareztorrent.com:80/announce\", \"udp://bt.xxx-tracker.com:2710/announce\", \"udp://tracker.eddie4.nl:6969/announce\", \"udp://tracker.grepler.com:6969/announce\", \"udp://tracker.mg64.net:2710/announce\", \"udp://wambo.club:1337/announce\", \"udp://tracker.dutchtracking.com:6969/announce\", \"udp://tc.animereactor.ru:8082/announce\", \"udp://tracker.justseed.it:1337/announce\", \"udp://tracker.leechers-paradise.org:6969/announce\", \"https://open.kickasstracker.com:443/announce\", \"udp://tracker.coppersurfer.tk:6969/announce\", \"http://87.253.152.137/announce\", \"http://91.216.110.47/announce\", \"http://91.217.91.21:3218/announce\", \"http://91.218.230.81:6969/announce\", \"http://93.92.64.5/announce\", \"http://atrack.pow7.com/announce\", \"http://bt.henbt.com:2710/announce\", \"http://bt.pusacg.org:8080/announce\", \"https://tracker.bt-hash.com:443/announce\", \"udp://tracker.leechers-paradise.org:6969\", \"https://182.176.139.129:6969/announce\", \"udp://zephir.monocul.us:6969/announce\", \"https://tracker.dutchtracking.com:80/announce\", \"https://grifon.info:80/announce\", \"udp://tracker.kicks-ass.net:80/announce\", \"udp://p4p.arenabg.com:1337/announce\", \"udp://tracker.aletorrenty.pl:2710/announce\", \"https://tracker.parrotsec.org:443/announce\", \"https://tracker.moxing.party:6969/announce\", \"https://tracker.ipv6tracker.ru:80/announce\", \"https://tracker.fastdownload.xyz:443/announce\", \"https://gwp2-v19.rinet.ru:80/announce\", \"https://tr.kxmp.cf:80/announce\", \"https://explodie.org:6969/announce\"]\n",
        "\n",
        "types = {GENERAL:  \"General\",\n",
        "        SOFTWARE:  \"Software\",\n",
        "        GAMES:  \"Games\",\n",
        "        MOVIE:  \"Movie\",\n",
        "        SHOW:  \"Show\",\n",
        "        SEASON:  \"Season\",\n",
        "        EPISODE:  \"Episode\",\n",
        "        MUSIC : \"Music\",\n",
        "        ALBUM : \"Album\",\n",
        "        TRACK : \"Track\"}\n",
        "\n",
        "#### API / abstraction \n",
        "\n",
        "REPLACE_DOWNLOAD = 'REPLACE'\n",
        "MERGE_DOWNLOAD = 'MERGE'\n",
        "CANCEL_DOWNLOAD = 'CANCEL'\n",
        "RENAME_DOWNLOAD = 'RENAME'\n",
        "\n",
        "#url_pt = re.compile(r\"^((http[s]?):\\/\\/)?([^:\\/\\s]+)((\\/\\w+\\/)*\\/)([\\w\\-\\.]+[^#?\\s]+)(.*)?(#[\\w\\-]+)?\")\n",
        "#sm_pt = re.compile(r\"(?<=Shareddrives\\/)[A-Z]*(?=\\/)\")\n",
        "#sn2num_pt = re.compile(r\"[1-9][0-9]?(?=[Xx]\\d{1,2}\\b)\")\n",
        "#eps2num_pt = re.compile(r\"(?<=\\d{1}[Xx])\\d{1,2}\\b\")\n",
        "#skip_re = re.compile(r\"(.txt)|(.i?nfo?)|(www.yts)|(RARBG_DO_NOT|rarbg_do_not)\")\n",
        "\n",
        "featurettes_pt = re.compile(r\"[F,f]eature[a-z]*|[E,e]xtras?\")\n",
        "mf_pt = re.compile(r\"((?<=\\b[S,s])|(?<=[S,s]eason)|(?<=[S,s]eason[\\s,\\.]))([1-9][0-9]?|0?[1-9])\")\n",
        "eps_pt = re.compile(r\"\\b([Ss]\\d{1,2}[Ee]\\d{1,2}|\\d{1,2}[xX]\\d{1,2}|[Ss]n?\\d{1,2}\\s?[Ee](ps?)?\\d{1,2})(?=[\\s\\.])\")\n",
        "check_sn_pt = re.compile(r\"[\\s,\\.]([S,s]\\d{1,2}|[Ss][Ee][Aa][Ss][Oo][Nn]([\\s,\\.]?)\\d{1,2})(?=[\\s,\\.]|e\\d{1,2}-\\d{1,2})(?!\\sto)\")\n",
        "yearsuff_pt = re.compile(r\"\\d{4}$\")\n",
        "langs_pt = re.compile(r\"(?<=\\_|-|\\.|\\s)(Arabic|ar|English|en|French|fr|german|de|Finnish|fi|dutch|nl|Danish|da|greek|el|hindi|hi|Indonesian|id|italian|it|Japanese|ja|Korean|ko|Norwegian|no|Persian|fa|Polish|pl|Portuguese|pt|Russian|ru|Swedish|sv|Thai|th|Ukrainian|uk|Urdu|ur|Vietnamese|vi|spanish|es|Romanian|ro|Hungarian|hu)\", flags= re.IGNORECASE)\n",
        "digitssuff_pt = re.compile(r\"\\s\\d{1,2}$\")\n",
        "season_pt0 = re.compile(r\"([S,s]|([S,s]easons?\\s?))\\d{1,2}\")\n",
        "season_pt1 = re.compile(r\"\\b([S,s]|[S,s]eason([\\s,\\.]?))\\d{1,2}\")\n",
        "season_number_pt = re.compile(r\"([1-9][0-9]?)\")\n",
        "sd_pt = re.compile(r\"(\\/content\\/drive\\/Shareddrives\\/)[A-Za-z0-9]+(?=\\/)\")\n",
        "imdbcount_pt = re.compile(r\"\\d+(?=\\stitles?)\")\n",
        "l337xpages_pt = re.compile(r'(?<=/)\\d+(?=/)')\n",
        "stars_pt = re.compile(r\"(?<=Stars:)<a href.*</a>\")\n",
        "director_pt = re.compile(r\"(((?<=Director:)<a href.*</a>)|((?<=Directors:)<a href.*</a>))(?=<span)\")\n",
        "split_musictitle_pt = re.compile(r\"[\\[\\]\\(]\")\n",
        "\n",
        "class DownloadAttrs:\n",
        "    def __init__(self, type_ = GENERAL, existing_mode = False, backup = False, save_name = \"\", sequential= False, \n",
        "        uncomplete_source = \"\", imdb_name = \"\", imdb_rating = \"\", imdb_votes = \"\", partial = False, name= '', torfile= ''):\n",
        "        self.type_ = type_ \n",
        "        self.existing_mode =  existing_mode\n",
        "        self.backup =  backup\n",
        "        self.save_name =  save_name\n",
        "        self.sequential = sequential \n",
        "        self.uncomplete_source  =  uncomplete_source\n",
        "        self.imdb_name =  imdb_name\n",
        "        self.imdb_rating =  imdb_rating\n",
        "        self.imdb_votes =  imdb_votes\n",
        "        self.partial = partial\n",
        "        self.name = name\n",
        "        self.torfile = torfile\n",
        "    torfile = \"\"\n",
        "    artist = \"\"\n",
        "    album = \"\"\n",
        "    track = \"\"\n",
        "    partial = False\n",
        "    backup = False\n",
        "    completed = False\n",
        "    existing_mode = MERGE_DOWNLOAD\n",
        "    ready = False\n",
        "    name = \"\"\n",
        "    hash = ''\n",
        "    save_name = \"\"\n",
        "    save_path = \"\"\n",
        "    target_save_dir = \"\"\n",
        "    imdb_name = \"\"\n",
        "    type_ = GENERAL\n",
        "    save_type = 0\n",
        "    sequential = False\n",
        "    full_size = 0\n",
        "    download_size = 0\n",
        "    allfiles = 0\n",
        "    selectedfilescount = 0\n",
        "    files = None\n",
        "    uncomplete_source = \"\"\n",
        "    show = \"\"\n",
        "    season = \"\"\n",
        "    existing_savingdir = \"\"\n",
        "    existing_path = \"\"\n",
        "    baksv = None\n",
        "    year = 0\n",
        "    imdb_rating = \"\"\n",
        "    imdb_votes = \"\"\n",
        "    quality = \"1080\"\n",
        "    site_source = \"\"\n",
        "    uploader = \"\"\n",
        "    format = \"\"\n",
        "    duration = \"\"\n",
        "    video_width = \"\"\n",
        "    video_height = \"\"\n",
        "    frame_rate = \"\"\n",
        "    bit_rate = \"\"\n",
        "    color_bit_depth = \"\"\n",
        "    video_bit_rate = \"\"\n",
        "    magnet = \"\"\n",
        "    add_source = ''\n",
        "    audio_tracks = None\n",
        "    downloaded_diritems = None\n",
        "    selectedfilenames = None\n",
        "    total_downloaded = 0\n",
        "    verify_download = None\n",
        "    old_files_dirs = None\n",
        "    hasmetadata = False\n",
        "    addmethod = None\n",
        "    \n",
        "    def copy(self):\n",
        "        return DownloadAttrs(type_= self.type_,\n",
        "                    existing_mode= self.existing_mode,\n",
        "                    backup= self.backup,\n",
        "                    sequential= self.sequential,\n",
        "                    uncomplete_source= self.uncomplete_source,\n",
        "                    imdb_name= self.imdb_name,\n",
        "                    imdb_rating= self.imdb_rating,\n",
        "                    imdb_votes= self.imdb_votes)\n",
        "\n",
        "class DownloadFile():\n",
        "    def __init__(self, index, name, size, selected = True):\n",
        "        self.index = index\n",
        "        self.name = name\n",
        "        self.size = size\n",
        "    index = 0\n",
        "    name = \"\"\n",
        "    size = 0\n",
        "    selected = True\n",
        "\n",
        "class SearchParams: #NOT USED\n",
        "    def __init__(self, sites= None, search= \"\", category= None, sort= \"\", order= \"\", attrs= None) -> None:\n",
        "        self.sites = sites\n",
        "        self.search = search\n",
        "        self.attrs = attrs\n",
        "        self.category = category\n",
        "        self.sort = sort\n",
        "        self.order = order\n",
        "    sites = None\n",
        "    search = \"\"\n",
        "    category = None\n",
        "    sort = \"\"\n",
        "    order = \"\"\n",
        "    attrs = None\n",
        "\n",
        "class IMDBParams:\n",
        "    def __init__(self, keyword= \"\" , titletype= \"\", startdate= \"\", enddate= \"\", minrating= 0, maxrating= 0, minvotes= 0, maxvotes= 0,\n",
        "                 minruntime= 0, maxruntime= 0, inlists= \"\", notinlists= \"\", imdbsort= \"\", imdborder= \"\", filterwatched= False,\n",
        "                filterdownloaded= False, top250= False, top1000= False, oscarwinner= False, bestpicturewinner= False,\n",
        "                bestdirectorwinner= False, englishonly= False, animationtitles= False, internationaltitles= False, indianmovies= False,\n",
        "                sites= None, sitecategory= \"\", siteparameters= \"\", attrs= None):\n",
        "        self.keyword = keyword\n",
        "        self.titletype = titletype\n",
        "        self.startdate = startdate\n",
        "        self.enddate = enddate\n",
        "        self.minrating = minrating\n",
        "        self.maxrating = maxrating\n",
        "        self.minvotes = minvotes\n",
        "        self.maxvotes = maxvotes\n",
        "        self.minruntime = minruntime\n",
        "        self.maxruntime = maxruntime\n",
        "        self.inlists = inlists\n",
        "        self.notinlists = notinlists\n",
        "        self.imdbsort = imdbsort\n",
        "        self.imdborder = imdborder\n",
        "        self.filterwatched = filterwatched\n",
        "        self.filterdownloaded = filterdownloaded\n",
        "        self.top250 = top250\n",
        "        self.top1000 = top1000\n",
        "        self.oscarwinner = oscarwinner\n",
        "        self.bestpicturewinner = bestpicturewinner\n",
        "        self.bestdirectorwinner = bestdirectorwinner\n",
        "        self.englishonly = englishonly\n",
        "        self.animationtitles = animationtitles\n",
        "        self.internationaltitles = internationaltitles\n",
        "        self.indiantitles = indianmovies\n",
        "        self.sites = sites\n",
        "        self.sitecategory = sitecategory\n",
        "        self.siteparameters = siteparameters \n",
        "        self.attrs = attrs\n",
        "    keyword = \"\"\n",
        "    titletype = \"\"\n",
        "    startdate = \"\"\n",
        "    enddate = \"\"\n",
        "    minrating = \"\"\n",
        "    maxrating = \"\"\n",
        "    minvotes = \"\"\n",
        "    maxvotes = \"\"\n",
        "    minruntime = \"\"\n",
        "    maxruntime = \"\"\n",
        "    inlists = \"\"\n",
        "    notinlists = \"\"\n",
        "    imdbsort = \"\"\n",
        "    imdborder = \"\"\n",
        "    filterwatched = False\n",
        "    filterdownloaded = False\n",
        "    top250 = False\n",
        "    top1000 = False\n",
        "    oscarwinner = False\n",
        "    bestpicturewinner = False\n",
        "    bestdirectorwinner = False\n",
        "    englishonly = False\n",
        "    animationtitles = False\n",
        "    internationaltitles = False\n",
        "    indiantitles = False\n",
        "    sites = None\n",
        "    sitecategory = None\n",
        "    siteparameters = None \n",
        "    attrs = None\n",
        "    rarbgauto = False\n",
        "    labels = \"\"\n",
        "\n",
        "class IMDBTitle:\n",
        "    def __init__(self, title_text, title_link= '', runtime= '', rating= '', votes= '', genres= \"\", directors= \"\", stars= \"\"):\n",
        "        self.title_text = title_text\n",
        "        self.title_link = title_link\n",
        "        self.runtime = runtime\n",
        "        self.rating = rating\n",
        "        self.votes = votes\n",
        "        self.director = directors\n",
        "        self.stars = stars\n",
        "        self.genres = genres\n",
        "\n",
        "    title_text = None\n",
        "    title_link = None\n",
        "    runtime = None\n",
        "    rating = None\n",
        "    votes = None\n",
        "    director = None\n",
        "    stars = None\n",
        "    genres = None\n",
        "    downloaded = False\n",
        "    watched = False\n",
        "\n",
        "class DownloadResult: \n",
        "    def __init__(self, resulturl= \"\", size = 0, date = \"\", seeders = \"\", leechers = \"\", uploader = \"\", href = \"\", downloaded= False, watched= False, attrs= None):\n",
        "        self.resulturl = resulturl\n",
        "        self.size = size\n",
        "        self.date = date \n",
        "        self.seeders = seeders\n",
        "        self.leechers = leechers\n",
        "        self.uploader = uploader\n",
        "        self.href = href\n",
        "        self.downloaded = downloaded\n",
        "        self.watched = watched\n",
        "        self.attrs = attrs\n",
        "\n",
        "    resulturl: str\n",
        "    size = 0\n",
        "    magnet = date = seeders = leechers = uploader = href = \"\"\n",
        "    downloaded = watched = False\n",
        "    attrs: DownloadAttrs = None\n",
        "\n",
        "htmlformatter = HTMLTemplateFormatter()\n",
        "searchsortdropdowns_style = {\"description_width\": \"40px\"}\n",
        "searchsortbtn_layout = {\"width\": \"80px\", \"margin\": \"0 10px\"}\n",
        "searchdownloadbtn_layout = {\"width\": \"180px\"}\n",
        "pagebtn_layout= {'width':'29px', 'height':'29px', 'padding': '2px', 'margin': '0 6px 0 0'}\n",
        "resultsrowfontsize = '16px'\n",
        "downloadbtn = '<i class=\"ico ico-download\"></i>'\n",
        "searchresultstableformatters = {'Name': htmlformatter, 'Uploader': htmlformatter}\n",
        "searchresultstablecolumnwidths={'Name': '52%', 'Date': '9%', 'Size': '8%', 'Seeders': '8%', 'Leechers': '8%', 'Uploader': '10%', \" \": \"5%\"}\n",
        "searchresultstablecolumnalignments={'Name': 'left', 'Date': 'center', 'Size': 'center', 'Seeders': 'center', 'Leechers': 'center', 'Uploader': 'center', \" \": \"center\"}\n",
        "resultstablebuttons = {\"Download\": downloadbtn}\n",
        "\n",
        "imdbresultstableformatters = {\"Title\": htmlformatter,  \"Director\": htmlformatter, \"Stars\": htmlformatter}\n",
        "imdbresultstablesorters = [{'field': 'Downloaded', 'dir': 'desc'},]\n",
        "imdbresultstablecolumnwidths ={\"Title\":'21%',  \"Director\": '10%', \"Stars\": '20%',\"Genres\": '13%', \"Rating\": '5%', \"Votes\": '5%', \"Runtime\": '5%', \"Downloaded\": '7%', \"Watched\": '6%', \" \": '3%'}\n",
        "imdbresultstablecolumnalignments ={'Title': 'left', 'Director': 'left', 'Stars': 'left', 'Genres': 'left', 'Rating': 'center', 'Votes': 'center', \"Runtime\": 'center', \"Downloaded\": 'center', \"Watched\": 'center', \" \": \"center\"}\n",
        "\n",
        "icon_css = \"\"\"background: url( \"data:image/svg+xml,%3Csvg%20id%3D%22download-svg%22%20width%3D%2225px%22%20height%3D%2225px%22%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20opacity%3D%220.5%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M3%2014.25C3.41421%2014.25%203.75%2014.5858%203.75%2015C3.75%2016.4354%203.75159%2017.4365%203.85315%2018.1919C3.9518%2018.9257%204.13225%2019.3142%204.40901%2019.591C4.68577%2019.8678%205.07435%2020.0482%205.80812%2020.1469C6.56347%2020.2484%207.56459%2020.25%209%2020.25H15C16.4354%2020.25%2017.4365%2020.2484%2018.1919%2020.1469C18.9257%2020.0482%2019.3142%2019.8678%2019.591%2019.591C19.8678%2019.3142%2020.0482%2018.9257%2020.1469%2018.1919C20.2484%2017.4365%2020.25%2016.4354%2020.25%2015C20.25%2014.5858%2020.5858%2014.25%2021%2014.25C21.4142%2014.25%2021.75%2014.5858%2021.75%2015V15.0549C21.75%2016.4225%2021.75%2017.5248%2021.6335%2018.3918C21.5125%2019.2919%2021.2536%2020.0497%2020.6517%2020.6516C20.0497%2021.2536%2019.2919%2021.5125%2018.3918%2021.6335C17.5248%2021.75%2016.4225%2021.75%2015.0549%2021.75H8.94513C7.57754%2021.75%206.47522%2021.75%205.60825%2021.6335C4.70814%2021.5125%203.95027%2021.2536%203.34835%2020.6517C2.74643%2020.0497%202.48754%2019.2919%202.36652%2018.3918C2.24996%2017.5248%202.24998%2016.4225%202.25%2015.0549C2.25%2015.0366%202.25%2015.0183%202.25%2015C2.25%2014.5858%202.58579%2014.25%203%2014.25Z%22%20fill%3D%22%231C274C%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M12%2016.75C12.2106%2016.75%2012.4114%2016.6615%2012.5535%2016.5061L16.5535%2012.1311C16.833%2011.8254%2016.8118%2011.351%2016.5061%2011.0715C16.2004%2010.792%2015.726%2010.8132%2015.4465%2011.1189L12.75%2014.0682V3C12.75%202.58579%2012.4142%202.25%2012%202.25C11.5858%202.25%2011.25%202.58579%2011.25%203V14.0682L8.55353%2011.1189C8.27403%2010.8132%207.79963%2010.792%207.49393%2011.0715C7.18823%2011.351%207.16698%2011.8254%207.44648%2012.1311L11.4465%2016.5061C11.5886%2016.6615%2011.7894%2016.75%2012%2016.75Z%22%20fill%3D%22%231C274C%22%2F%3E%3C%2Fsvg%3E\" );\"\"\"\n",
        "download_css = \"\"\"  font-size: 20px;\n",
        "                    font-weight: 500;\n",
        "                    padding: 1px 0;\n",
        "                    transition: .4s; \n",
        "                    color: #001dd5;\n",
        "                \"\"\"\n",
        "wordwrap_css = \"white-space: pre-wrap;\"\n",
        "\n",
        "getpagekey = lambda sort, order, page: f\"{sort}|{order}|{page}\"\n",
        "\n",
        "class WebResult:\n",
        "    def __init__(self, search=\"\", category= None, results= None, attrs= None, sort= None, order= None, url= None, resultcount= 0, page= None,\n",
        "                 pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None: \n",
        "        self.search = search\n",
        "        self.category = category\n",
        "        self.results = results\n",
        "        self.attrs = attrs\n",
        "        self.sort = sort\n",
        "        self.order = order\n",
        "        self.url = url\n",
        "        self.resultcount = resultcount\n",
        "        self.page = page\n",
        "        self.pageresultcount = pageresultcount\n",
        "        self.totalpages = totalpages\n",
        "        self.nextpage = nextpage\n",
        "        self.previouspage = previouspage\n",
        "        self.resultpages = dict()\n",
        "        \n",
        "    attrs: DownloadAttrs \n",
        "    sort = None\n",
        "    order = DESCORDER\n",
        "    results: list[DownloadResult|IMDBTitle] = None\n",
        "    url = None\n",
        "    currentpageurl = None\n",
        "    result = None\n",
        "    request = None\n",
        "    status = None\n",
        "    error = None\n",
        "    attrs: DownloadAttrs = None    \n",
        "    search = \"\"\n",
        "    category = None\n",
        "    resultcount = 0\n",
        "    totalpages = 0\n",
        "    page = 0\n",
        "    nextpage = -1\n",
        "    previouspage = -1\n",
        "    pageresultcount = 0\n",
        "    table: pn.widgets.Tabulator = None\n",
        "    tableoutput: Output = None\n",
        "    pagination_container: HBox = None\n",
        "    resultscount = 0\n",
        "    site = ''\n",
        "    tab = None\n",
        "    resultpages = None\n",
        "\n",
        "    def pagination_handler(self, btn): \n",
        "        page = int(btn.description)\n",
        "        updatesearchresults(self, page= page)\n",
        "\n",
        "    def actionhandler(self, e):\n",
        "        pass\n",
        "\n",
        "    def getdataframe(self):\n",
        "        pass\n",
        "\n",
        "    def getresultcontrols(self):\n",
        "        pass\n",
        "\n",
        "    def getresultstable(self):\n",
        "        pass\n",
        "\n",
        "    def applytablestyle(self):\n",
        "        pass\n",
        "\n",
        "    def getresultcontrols(self):\n",
        "        pass\n",
        "\n",
        "    def updateresults(self, page, sort= None, order= None):\n",
        "        pass\n",
        "\n",
        "class IMDBResult(WebResult): #obj values used in class attribute definitions should be defined before, in function/methods it shouldn't be.\n",
        "    def __init__(self, imdbparams= None, search=\"\", category= None, results= None, attrs= None, sort= \"\", order= None, url= \"\", resultcount= 0,\n",
        "                 page= None, pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None:\n",
        "        super().__init__(search, category, results, attrs, sort, order, url, resultcount, page, pageresultcount, totalpages, nextpage, previouspage)\n",
        "        self.imdbparams = imdbparams\n",
        "        self.tab = nav[IMDB_TAB]\n",
        "        self.site = IMDB\n",
        "        self.downloadedtitlespages = dict()\n",
        "        self.watchedtitlespages = dict()\n",
        "\n",
        "    results: list[IMDBTitle] = None\n",
        "    imdbparams: IMDBParams \n",
        "    downloadedcount = 0\n",
        "    watchedcount = 0\n",
        "    downloadedtitles: list[IMDBTitle] = None\n",
        "    watchedtitles: list[IMDBTitle] = None\n",
        "    sort = IMDB_DATE_SORT\n",
        "    order = ASCORDER\n",
        "\n",
        "    def actionhandler(self, e):\n",
        "        params = self.imdbparams\n",
        "        if e.column == ' ':\n",
        "            result: IMDBTitle = self.results[e.row]\n",
        "            info(f'Searching download {result.title_link} from IMDB search.')\n",
        "            search = f\"{result.title_text} {self.imdbparams.siteparameters}\"\n",
        "            switchview(nav[SEARCH_TAB], getloadingview( f'Search for {types[self.attrs.type_]} \"{result.title_link}\" site: {params.sites[0]} page: 1.'), temp= True)\n",
        "            maintabs.selected_index = appstate.tab_indices[SEARCH_TAB]\n",
        "            search_process(site= params.sites[0], search= search, attrs= self.attrs, category= params.sitecategory, sort= SEEDERSSORT, order= DESCORDER, page= 1, source= IMDB_TAB)\n",
        "\n",
        "    def getdataframe(self):\n",
        "        resulttablesource = {\"Title\":[],  \"Director\": [], \"Stars\": [],\"Genres\": [], \"Rating\": [], \"Votes\": [], \"Runtime\": [], \"Downloaded\": [], \"Watched\": [],\" \": []}\n",
        "        for result in self.results:\n",
        "            resulttablesource['Title'].append(result.title_link)\n",
        "            resulttablesource['Director'].append(result.director)\n",
        "            resulttablesource['Stars'].append(result.stars)\n",
        "            resulttablesource['Genres'].append(result.genres)\n",
        "            resulttablesource['Rating'].append(result.rating)\n",
        "            resulttablesource['Votes'].append(result.votes)\n",
        "            resulttablesource['Runtime'].append(result.runtime)\n",
        "            resulttablesource['Downloaded'].append(\"Downloaded\" if result.downloaded else \"\")\n",
        "            resulttablesource['Watched'].append(\"Watched\" if result.watched else \"\")\n",
        "            resulttablesource[' '].append(' ⤓ ')\n",
        "        return pd.DataFrame(resulttablesource)\n",
        "\n",
        "    def getresultstable(self):\n",
        "        dataframe = self.getdataframe()\n",
        "        self.table = pn.widgets.Tabulator(dataframe,\n",
        "                                                disabled= True,\n",
        "                                                sizing_mode= 'stretch_width',\n",
        "                                                widths= imdbresultstablecolumnwidths,\n",
        "                                                header_align='center',\n",
        "                                                text_align= imdbresultstablecolumnalignments,\n",
        "                                                show_index= False, \n",
        "                                                pagination= None,\n",
        "                                                formatters= imdbresultstableformatters,\n",
        "                                                sorters= imdbresultstablesorters,\n",
        "                                                selectable='checkbox', \n",
        "                                                theme= 'bootstrap4', #or: semantic-ui\n",
        "                                                configuration= {\n",
        "                                                'rowHeight': 60,\n",
        "                                                'columnDefaults': {'headerSort': False,}})\n",
        "        self.applytablestyle()\n",
        "        self.table.on_click(self.actionhandler)  \n",
        "        return self.table  \n",
        "\n",
        "    def applytablestyle(self):\n",
        "        self.table.style.apply(lambda s: [download_css for i in range(len(s))], subset=[' '])\n",
        "        self.table.style.apply(lambda s: [wordwrap_css for i in range(len(s))])\n",
        "\n",
        "    def getresultcontrols(self):\n",
        "        sort_dropdown = Dropdown(description= \"Sort\", value= self.sort ,options= [(\"By User Rating\", IMDB_RATING_SORT), (\"By Date\", IMDB_DATE_SORT), (\"Alphabetically\", IMDB_ALPHABETICAL_SORT)], layout= {}, style= searchsortdropdowns_style)\n",
        "        order_dropdown = Dropdown(description= \"Order\", value= self.order, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= {}, style= searchsortdropdowns_style)\n",
        "        sort_btn = Button(description= \"Sort\", layout= searchsortbtn_layout)\n",
        "        sort_btn.on_click(lambda btn: updatesearchresults(self, 1, sort= sort_dropdown.value, order= order_dropdown.value))\n",
        "        download_btn = Button(description= \"Download Selected\", layout= searchdownloadbtn_layout)\n",
        "        download_btn.on_click(self.handlebulkdownload)\n",
        "        return (sort_dropdown, order_dropdown, sort_btn, download_btn)\n",
        "    \n",
        "    def handlebulkdownload(self, btn):\n",
        "        appstate.bulksearch = [self.results[index].title_text for index in self.table.selection]\n",
        "        \n",
        "        # call bulk download handle func\n",
        "        # handler pops next downloaditem, displays site decision view (temp) with handler\n",
        "        # on input handler searches in the site\n",
        "        # on download, adds donwloadload, pops next download item and shows site decesion view ()\n",
        "        # display result\n",
        "\n",
        "    def updateresults(self, page, sort= None, order= None):\n",
        "        if not sort:\n",
        "            sort= self.sort\n",
        "        if not order:\n",
        "            order= self.order\n",
        "        pagekey = getpagekey(sort, order, page)\n",
        "        if pagekey in self.resultpages:\n",
        "            self.results = self.resultpages[pagekey]\n",
        "            self.downloadedtitles = self.downloadedtitlespages[page]\n",
        "            self.watchedtitles = self.watchedtitlespages[page]\n",
        "            self.page = page\n",
        "            self.sort = sort\n",
        "            self.order = order\n",
        "            self.pageresultcount = len(self.results)\n",
        "            self.previouspage = page - 1\n",
        "            self.nextpage = page + 1 if page + 1 <= self.totalpages else 0\n",
        "        else:\n",
        "            self.imdbparams.imdbsort = sort\n",
        "            self.imdbparams.imdborder = order\n",
        "            searchIMDB(self.imdbparams, page= page, result= self)\n",
        "\n",
        "class SearchResult(WebResult):\n",
        "    def __init__(self, site= X1337X, search=\"\", category= ALLCATEGORIES_TD, results= None, attrs= None, sort= \"\", order= None, url= \"\",\n",
        "                 resultcount= 0, page= None, pageresultcount= 0, totalpages= 0, nextpage= -1, previouspage= -1) -> None:\n",
        "        super().__init__(search, category, results, attrs, sort, order, url, resultcount, page, pageresultcount,\n",
        "                         totalpages, nextpage, previouspage)\n",
        "        self.site = site\n",
        "        self.sorters = []\n",
        "        self.tab = nav[SEARCH_TAB]\n",
        "\n",
        "    sort = SEEDERSSORT\n",
        "    def actionhandler(self, e):\n",
        "        if e.column == ' ':\n",
        "            res: DownloadResult = self.results[e.row]\n",
        "            download1337x(res, self.attrs)\n",
        "\n",
        "    def getdataframe(self):\n",
        "        resulttablesource = {\"Name\":[],  \"Date\": [], \"Size\": [],\"Seeders\": [], \"Leechers\": [], \"Uploader\": [], \" \": []}\n",
        "        for result in self.results:\n",
        "            resulttablesource['Name'].append(result.resulturl)\n",
        "            resulttablesource['Size'].append(result.size)\n",
        "            resulttablesource['Date'].append(result.date)\n",
        "            resulttablesource['Seeders'].append(result.seeders)\n",
        "            resulttablesource['Leechers'].append(result.leechers)\n",
        "            resulttablesource['Uploader'].append(result.uploader)\n",
        "            resulttablesource[' '].append(' ⤓ ')\n",
        "        return pd.DataFrame(resulttablesource)\n",
        "    \n",
        "    def getresultstable(self):\n",
        "        dataframe = self.getdataframe()\n",
        "        self.table: pn.widgets.Tabulator = pn.widgets.Tabulator(dataframe,\n",
        "                                                disabled= True,\n",
        "                                                sizing_mode= 'stretch_width',\n",
        "                                                widths= searchresultstablecolumnwidths,\n",
        "                                                header_align='center',\n",
        "                                                text_align= searchresultstablecolumnalignments,\n",
        "                                                show_index= False, \n",
        "                                                pagination= None,\n",
        "                                                formatters= searchresultstableformatters,\n",
        "                                                theme = \"bootstrap4\",\n",
        "                                                configuration= {\n",
        "                                                'rowHeight': 30,\n",
        "                                                'columnDefaults': {'headerSort': False,}})\n",
        "        self.applytablestyle()\n",
        "        self.table.on_click(self.actionhandler)\n",
        "        return self.table\n",
        "       \n",
        "    def applytablestyle(self):\n",
        "        self.table.style.apply(lambda s: [\"color: #03ba00\" for i in range(len(s))], subset=['Seeders'])\n",
        "        self.table.style.apply(lambda s: [\"color: #d40404\" for i in range(len(s))], subset=[\"Leechers\"])\n",
        "        self.table.style.apply(lambda s: [download_css for i in range(len(s))], subset=[' '])\n",
        "\n",
        "    def getresultcontrols(self):\n",
        "        sort_dropdown =  Dropdown(description= \"Sort\", value= self.sort, options = [('By Seeders', SEEDERSSORT), ('By Time', TIMESORT), ('By Size', SIZESORT)], layout= {}, style= searchsortdropdowns_style)\n",
        "        order_dropdown = Dropdown(description= \"Order\", value= self.order, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= {}, style= searchsortdropdowns_style)\n",
        "        sort_btn = Button(description= \"Sort\", layout= searchsortbtn_layout)\n",
        "        sort_btn.on_click(lambda btn: updatesearchresults(self, 1, sort= sort_dropdown.value, order= order_dropdown.value))\n",
        "        return (sort_dropdown, order_dropdown, sort_btn)\n",
        "    \n",
        "    def updateresults(self, page, sort= None, order= None):\n",
        "        if not sort:\n",
        "            sort = self.sort\n",
        "        if not order:\n",
        "            order = self.order\n",
        "        pagekey = getpagekey(sort, order, page)\n",
        "        if pagekey in self.resultpages:\n",
        "            self.results = self.resultpages[pagekey]\n",
        "            self.pageresultcount = len(self.results)\n",
        "            self.page = page\n",
        "            self.sort = sort\n",
        "            self.order = order\n",
        "            self.previouspage = page - 1\n",
        "            self.nextpage = page + 1 if page + 1 <= self.totalpages else 0\n",
        "        else:\n",
        "            search1337x(self.search, sort= sort, order= order, category= self.category, page= page, attrs= self.attrs, result= self)\n",
        "\n",
        "#### API / Download library management\n",
        "\n",
        "def transstring(name): \n",
        "    if not name:\n",
        "        error('String is empty.')\n",
        "        raise Exception('String is empty.')\n",
        "    table = name.maketrans(\"\",\"\",\" ,.;:!?'&#$%`!@^*_-/\\\\|'\\\"<>())[]{}\")\n",
        "    return name.translate(table).lower()\n",
        "\n",
        "def transtitle(name, show = False): \n",
        "    if not name:\n",
        "        error('Name is empty.')\n",
        "        raise Exception('Trans title,name is empty.')\n",
        "    name = name.replace(\"&\",\"and\")\n",
        "    dgts = year_pt.findall(name)\n",
        "    year = \"\"\n",
        "    if dgts: \n",
        "        if len(dgts) == 1 :\n",
        "            name = name.split(dgts[0])[0]\n",
        "            year = dgts[0]\n",
        "        else:\n",
        "            name.split(dgts[-1])[0]\n",
        "            year = dgts[-1]\n",
        "    table = name.maketrans(\"\",\"\",\" '(#$%-,.;:!?)\")\n",
        "    return name.translate(table).lower() + year         # if not show else name.translate(table).lower()\n",
        "\n",
        "def get_year(name): \n",
        "    dgts = year_pt.findall(name.split('1080')[0])\n",
        "    if dgts: \n",
        "        return dgts[-1]\n",
        "    else:\n",
        "        return thisyear\n",
        "\n",
        "def get_season(name, allow_year = True):\n",
        "    info(f'Retrieving season from: {name}')\n",
        "    lookup = mf_pt.search(name)\n",
        "    if lookup:\n",
        "        sn = lookup.group()\n",
        "        sn = 'S' + sn if len(sn) != 1 else 'S0' + sn\n",
        "        info(f'Found season: {sn}')\n",
        "        return sn\n",
        "\n",
        "    lookup = featurettes_pt.search(name)\n",
        "    if lookup:\n",
        "        ft = lookup.group()\n",
        "        info(f'Extra folder: {ft}')\n",
        "        return \"Extras\"\n",
        "\n",
        "    if allow_year:\n",
        "        sn = get_year(name)  \n",
        "        info(f'Season retrieved as a year: {sn}')\n",
        "        return sn\n",
        "    else:\n",
        "        info(f'No season was retrieved.')\n",
        "        return ''\n",
        "\n",
        "def name_movie(name, quality = \"1080\"): \n",
        "    if quality in name:\n",
        "        name = name.split(quality)[0]\n",
        "    elif '720p' in name:\n",
        "        name = name.split('720p')[0]\n",
        "    table = name.maketrans({\".\": \" \",\"(\": None, \")\": None})\n",
        "    trans = name.translate(table)\n",
        "    dgts = year_pt.findall(trans)\n",
        "    if dgts and len(dgts) >= 1:\n",
        "         res = f\"{trans.split(dgts[-1])[0].strip()} {dgts[-1]}\"\n",
        "    else:\n",
        "        res = trans.strip()\n",
        "    return title(res)\n",
        "\n",
        "def name_show(name, quality = \"1080\"): \n",
        "    if quality in name:\n",
        "        name = name.split(quality)[0]\n",
        "    elif \"720p\" in name:\n",
        "        name = name.split(\"720p\")[0]    \n",
        "    table = name.maketrans(\".\",\" \",\"'()\")\n",
        "    trans = name.translate(table)\n",
        "    search = year_pt.search(trans)\n",
        "    if search: \n",
        "        year = search.group()\n",
        "        res = f\"{trans.split(year)[0].strip()} {year}\"\n",
        "    else:\n",
        "        search = season_pt1.search(trans)\n",
        "        if search: \n",
        "            res = trans.split(search.group())[0].strip()\n",
        "        else: \n",
        "            res = trans.strip()\n",
        "    return title(res)\n",
        "\n",
        "def name_episode(name, quality = \"1080\", keepDot = False):\n",
        "    if quality in name:\n",
        "        name = name.split(quality)[0]\n",
        "    elif \"720p\" in name:\n",
        "        name = name.split(\"720p\")[0]\n",
        "    if keepDot: \n",
        "        r = s = \"\"\n",
        "    else:\n",
        "        r =\".\"\n",
        "        s = \" \"\n",
        "    table = name.maketrans(r, s, \"()\")\n",
        "    name = name.translate(table)\n",
        "    if name[-1] == \".\":\n",
        "        name = name[:-1]\n",
        "    return title(name)\n",
        "\n",
        "def movie_exists(name):\n",
        "    if not name.strip():\n",
        "        error('Movie name is empty')\n",
        "        return           \n",
        "    info(f\"Checking if the movie {name} is downloaded.\")\n",
        "    try:\n",
        "        movies_raw = filter_checks(next(os.walk(config.movies_path))[1])\n",
        "    except:\n",
        "        return False\n",
        "    name_s = transtitle(name)\n",
        "    for i in range(len(movies_raw)):\n",
        "        targetpath = path_movie(movies_raw[i])\n",
        "        targetname = movies_raw[i]\n",
        "        if name_s == transtitle(movies_raw[i]):\n",
        "            foundfile =  get_movie_file_path(targetpath, targetname)\n",
        "            if foundfile:\n",
        "                info(f\"Found {name} as {targetname}\")\n",
        "                return {'type': 'movie', \"foundname\": targetname, \"foundpath\": targetpath, \"foundshow\": '', 'foundfile': foundfile, \"founddir\": config.movies_path}\n",
        "    info(f\"{name} is not found\")\n",
        "    return False\n",
        "\n",
        "def show_exists(searchshow: str):\n",
        "    if not searchshow.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "    info(f\"Checking if the show {searchshow} is downloaded\")\n",
        "    try:\n",
        "        shows_raw = filter_checks(next(os.walk(config.tv_path))[1])\n",
        "    except:\n",
        "        return False\n",
        "    name_trans = transtitle(searchshow, True)\n",
        "    for i in range(len(shows_raw)):\n",
        "        targetpath = path_tvshow(shows_raw[i])\n",
        "        targetname = shows_raw[i]\n",
        "        trans1 = transtitle(shows_raw[i], True)\n",
        "        if startswith(trans1, name_trans) and not is_empty(targetpath):\n",
        "            info(f\"{searchshow} is downloaded as {targetname}\")\n",
        "            return {'type': 'TV show', \"foundname\": targetname, \"foundpath\": targetpath, \"foundshow\": targetname, 'foundfile': '', \"founddir\": config.tv_path}\n",
        "    info(f\"{searchshow} is not found.\")\n",
        "    return False\n",
        "\n",
        "def season_exists(targetshow, targetseason):\n",
        "    if not targetseason.strip():\n",
        "        error('Season name is empty')\n",
        "        return\n",
        "    if not targetshow.strip():\n",
        "        error('Show name is empty')\n",
        "        return\n",
        "    info(f\"Checking if the season {targetseason} of {targetshow} is downloaded\")\n",
        "    showsearch = show_exists(targetshow)\n",
        "    targetpath = \"\"\n",
        "    if showsearch:\n",
        "        targetshow = showsearch['foundname']\n",
        "        showpath = path_tvshow(targetshow)\n",
        "        targetpath = path_season(targetshow, targetseason)\n",
        "        if os.path.exists(targetpath) and not is_empty(targetpath):\n",
        "            info(f\"Season {targetseason} of {targetshow} is downloaded\")\n",
        "            return {'type': 'TV season', \"foundname\": targetseason, \"foundpath\": targetpath, \"foundshow\": targetshow, 'foundfile': '', \"founddir\": showpath}\n",
        "    info(f\"Season {targetseason} of {targetshow} is not downloaded\")\n",
        "    return False\n",
        "\n",
        "def episode_exists(targetshow, season, searchepisode): \n",
        "    info(f\"Checking if the episode: {searchepisode} is downloaded\")\n",
        "    showsearch = show_exists(targetshow)\n",
        "    targetepisode = \"\"\n",
        "    targetpath= \"\"\n",
        "    if showsearch:\n",
        "        targetshow = showsearch['foundname']\n",
        "        seasonpath = path_season(targetshow, season)\n",
        "        if os.path.exists(seasonpath) and not is_empty(seasonpath):\n",
        "            check = eps_pt.search(searchepisode)\n",
        "            eps = check.group() if check else searchepisode\n",
        "            epses = next(os.walk(seasonpath))[2]\n",
        "            for targetepisode in epses:\n",
        "                splt = os.path.splitext(targetepisode)\n",
        "                if splt[1] == \".mp4\" or splt[1] == \".mkv\": \n",
        "                    if contains(splt[0], eps):\n",
        "                        targetpath = path_episode(targetshow, season, targetepisode)\n",
        "                        info(f\"Episode: {searchepisode} is downloaded as {targetpath}\")\n",
        "                        return {'type': 'TV episode', \"foundname\": targetepisode, \"foundpath\": targetpath, \"foundshow\": targetshow, 'foundfile': targetpath, \"founddir\": seasonpath}\n",
        "    info(f\"Episode: {searchepisode} is not downloaded.\")\n",
        "    return False\n",
        "\n",
        "def check_download(type_, name):\n",
        "    if type_ == MOVIE:\n",
        "        name = name_movie(name)\n",
        "        return movie_exists(name)\n",
        "    if type_ == SHOW:\n",
        "        name = name_show(name)\n",
        "        return show_exists(name)\n",
        "\n",
        "def get_movie_file_path(path, name):\n",
        "    if path and os.path.exists(path):\n",
        "        files = next(os.walk(path))[2]\n",
        "        for file in files:\n",
        "            splt = os.path.splitext(file)\n",
        "            ext = splt[1]\n",
        "            title: str = splt[0].lower()\n",
        "            if (ext == \".mp4\" or ext == \".mkv\" or ext == \".av\" or ext == \".ts\") and name.lower().startswith(title):\n",
        "                return path + \"/\" + file\n",
        "    return \"\"\n",
        "\n",
        "def rename_title(newname):\n",
        "    inp = input().lower()\n",
        "    if inp:\n",
        "        words = inp.split()\n",
        "    else:\n",
        "        words: list[str] = newname.split()\n",
        "    check1 = \" \".join(words[:2])\n",
        "    check2 = len(words[0]) > 3\n",
        "    movies = filter_checks(next(os.walk(config.movies_path))[1])\n",
        "    res = []\n",
        "\n",
        "    for mv in movies:\n",
        "        if mv.startswith(check1) or (check2 and mv.startswith(words[0])) or any(not check3.isdigit() and len(check3) > 3 and contains(mv, check3) for check3  in words):\n",
        "            res.append(mv)\n",
        "    if len(res) == 1:\n",
        "        title = res[0]\n",
        "    elif res:\n",
        "        res.sort()\n",
        "        i = 0\n",
        "        for mv in res:\n",
        "            i += 1\n",
        "            print(f\"{i} {mv}\")       \n",
        "        c = input()\n",
        "        if c == \"\" or c == \" \" or c == \"q\" or c == \"s\":\n",
        "            return\n",
        "        else:\n",
        "            try:\n",
        "                title = res[int(c)-1]\n",
        "            except Exception as e:\n",
        "                print(e)\n",
        "                return\n",
        "    else:\n",
        "        return\n",
        "    if input() != \"n\":\n",
        "        p0 = config.movies_path + \"/\" + title\n",
        "        p1 = config.movies_path + \"/\" + newname\n",
        "        !mv \"$p0\" \"$p1\"\n",
        "\n",
        "        for p3 in config.moviesbackups:\n",
        "            p0 = joinpath(p3, title)\n",
        "            if os.path.exists(p0):\n",
        "                p1 = joinpath(p3, newname) \n",
        "                !mv \"$p0\" \"$p1\"\n",
        "\n",
        "def replace_download(path):\n",
        "    if path and os.path.exists(path):\n",
        "        parent = os.path.dirname(path)\n",
        "        rp = parent + \"/\" + \".replace\"\n",
        "        os.makedirs(rp, exist_ok=True)\n",
        "        !mv \"$path\" \"$rp\"\n",
        "\n",
        "def get_tv_type(attrs: DownloadAttrs):\n",
        "    search = eps_pt.search(attrs.name)\n",
        "    if search:\n",
        "        return EPISODE\n",
        "    search = check_sn_pt.search(attrs.name)\n",
        "    if search:\n",
        "        return SEASON  \n",
        "    \n",
        "def music_title(name: str):\n",
        "    search = split_musictitle_pt.search(name)\n",
        "    if search:\n",
        "        name = name.split(search.group())[0]\n",
        "    splt = name.split(\"-\")\n",
        "    if splt:\n",
        "        artist = splt[0].strip() \n",
        "        name = splt[1].strip()\n",
        "        title = f\"{artist} - {name}\"\n",
        "    else:\n",
        "        artist = \"\"\n",
        "        name = title = name.strip()\n",
        "    return (artist, name, title)\n",
        "\n",
        "def get_season_backup_pathes(show):\n",
        "    backuppathes = set()\n",
        "    for item in config.tvbackups:\n",
        "        pt1 = joinpath(item, show)\n",
        "        backuppathes.add(pt1)\n",
        "        os.makedirs(pt1, exist_ok=True)\n",
        "    return backuppathes\n",
        "\n",
        "def get_episode_backup_pathes(show, season):\n",
        "    itemdir = f\"{show}/{season}\"\n",
        "    backuppathes = set()\n",
        "    for item in config.tvbackups:\n",
        "        pt1 = joinpath(item, itemdir)\n",
        "        backuppathes.add(pt1)\n",
        "        os.makedirs(pt1, exist_ok=True) \n",
        "    return backuppathes\n",
        "\n",
        "def prepare_download(attrs: DownloadAttrs):\n",
        "    info(f\"Preparing {types[attrs.type_]} download info for: {attrs.name}\")\n",
        "    Type = attrs.type_\n",
        "    res= Prepare_Result(attrs)\n",
        "    if Type == MOVIE:\n",
        "        newname = name_movie(attrs.name, attrs.quality)\n",
        "        searchresult = movie_exists(newname)\n",
        "        savepath = config.movies_path\n",
        "        backuppathes = config.moviesbackups\n",
        "    elif Type == SHOW:\n",
        "        newname = name_show(attrs.name, attrs.quality)\n",
        "        searchresult = show_exists(newname)\n",
        "        savepath = config.tv_path\n",
        "        backuppathes = config.tvbackups\n",
        "        attrs.show = newname\n",
        "    elif Type == SEASON:\n",
        "        newname = get_season(attrs.name)\n",
        "        show = name_show(attrs.name, attrs.quality)\n",
        "        searchresult = season_exists(show, newname) \n",
        "        if searchresult:\n",
        "            show = searchresult['foundshow']           \n",
        "        savepath = path_tvshow(show)\n",
        "        backuppathes = get_season_backup_pathes(show)\n",
        "        attrs.show = show\n",
        "        attrs.season = newname\n",
        "    elif Type == EPISODE:\n",
        "        newname = name_episode(attrs.name, attrs.quality)\n",
        "        show = name_show(attrs.name, attrs.quality)\n",
        "        season = get_season(attrs.name)\n",
        "        searchresult = episode_exists(show, season, newname)        \n",
        "        if searchresult:\n",
        "            show = searchresult['foundshow']\n",
        "        savepath = path_season(show, season)\n",
        "        backuppathes = get_episode_backup_pathes(show, season)\n",
        "        attrs.show = show\n",
        "        attrs.season = season\n",
        "        attrs.save_path = path_season(show, season)\n",
        "    else:\n",
        "        attrs.save_path = config.general_path\n",
        "        backuppathes = config.generalbackups\n",
        "    if searchresult:\n",
        "        res.exists = True\n",
        "        res.typestr = searchresult['type']\n",
        "        res.foundname = searchresult['foundname']\n",
        "        res.foundpath = searchresult['foundpath']\n",
        "        res.foundfile = searchresult['foundfile']\n",
        "        res.founddir = searchresult['founddir']\n",
        "        res.foundshow = searchresult['foundshow']\n",
        "        foundpath = searchresult['foundpath']\n",
        "        attrs.existing_savingdir = searchresult['founddir']\n",
        "        attrs.existing_path = foundpath\n",
        "    if not attrs.save_name:\n",
        "        attrs.save_name = newname ##\n",
        "    attrs.save_path = savepath\n",
        "    attrs.target_save_dir = attrs.save_path if attrs.type_ == EPISODE else f'{attrs.save_path}/{attrs.save_name}'\n",
        "    if attrs.backup:\n",
        "        attrs.baksv = backuppathes\n",
        "    attrs.ready = True\n",
        "    info(f\"Finished preparing download successfully.\\nDownload attributes: {getattrstr(attrs, filter_empty = True, add_line= True)}\")\n",
        "    return res\n",
        "\n",
        "#### API / Download management\n",
        "\n",
        "ADDSUCCUSS = 100\n",
        "ADDERROR = 101\n",
        "ADDPENDING = 102\n",
        "ALREADYADDED = 103\n",
        "\n",
        "class AddResult():\n",
        "    attrs = None\n",
        "    handle = None\n",
        "    status = ADDSUCCUSS\n",
        "    awaiting_decision = False\n",
        "    errormessage = \"\"\n",
        "    succussmessage = \"\"\n",
        "    name = \"\"\n",
        "    savename = \"\"\n",
        "    size = 0\n",
        "    backuppath = \"\"\n",
        "    savepath = \"\"\n",
        "    hash = \"\"\n",
        "    selectedfiles_count = \"\"\n",
        "    files: list[DownloadFile] = None\n",
        "    filetable: pn.widgets.Tabulator = None\n",
        "    filetableoutput: Output = None\n",
        "    selectintervals_button = None\n",
        "    selectall_button = None\n",
        "    sizehtml: HTML = None\n",
        "    selectedfileshtml: HTML = None\n",
        "    hasmetadata = False\n",
        "\n",
        "class Prepare_Result:\n",
        "    def __init__(self, attrs, exists= False, type_= 'general', foundname= '', foundpath= '', foundshow= '', foundfile= '', founddir= ''):\n",
        "        self.attrs = attrs\n",
        "        self.exists = exists\n",
        "        self.typestr     = type_ \n",
        "        self.foundname = foundname \n",
        "        self.foundpath = foundpath \n",
        "        self.foundshow = foundshow \n",
        "        self.foundfile = foundfile \n",
        "        self.founddir  = founddir  \n",
        "    attrs = None\n",
        "    exists = False\n",
        "    typestr = 'general'\n",
        "    foundname = ''\n",
        "    foundpath = ''\n",
        "    foundshow = ''\n",
        "    foundfile = ''\n",
        "    founddir  = ''\n",
        "\n",
        "def get_magnet_name(magnet):\n",
        "    return urllib.parse.unquote(magnet.split(\"dn=\")[1].split(\"&tr=\")[0], encoding='utf-8', errors='replace').replace('+',\".\")\n",
        "\n",
        "def add_local_files(path= '.', files = set(), attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "      attrs = DownloadAttrs()\n",
        "    result = AddResult()\n",
        "    pathinvalid =  path != \".\" and not os.path.isdir(path) and not files\n",
        "    if path.endswith('.torrent'):\n",
        "        files= {path}\n",
        "    elif pathinvalid:\n",
        "        result.status = ADDERROR\n",
        "        result.errormessage = f\"Path {path} isn't a directory or a torrent file.\"\n",
        "        error(result.errormessage)\n",
        "        return result\n",
        "    files = files if files else next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        attrs = attrs.copy()\n",
        "        attrs.torfile = file\n",
        "        attrs.add_source = LOCALFILE_ADDSOURCE\n",
        "        splited = os.path.splitext(file)\n",
        "        if splited[1] == \".torrent\":\n",
        "            info(f\"Found a file to download: {file}\")\n",
        "            return add_download(attrs) # add multi file isn't correct\n",
        "\n",
        "def get_adddownload_error(result: AddResult, message):\n",
        "    error(message)\n",
        "    result.status = ADDERROR\n",
        "    result.errormessage = message\n",
        "    return result\n",
        "\n",
        "def add_download(attrs: DownloadAttrs):\n",
        "    if not (attrs.add_source == LOCALFILE_ADDSOURCE or attrs.add_source == MAGNET_ADDSOURCE):\n",
        "        raise(\"add_source should be LOCALFILE_ADDSOURCE or MAGNET_ADDSOURCE\")\n",
        "    result = AddResult() \n",
        "    result.attrs = attrs\n",
        "    appstate.addresults.append(result)  \n",
        "    if attrs.add_source == MAGNET_ADDSOURCE and not attrs.magnet:\n",
        "        return get_adddownload_error(result, f\"Download magnet is empty. {attrs.name}\")\n",
        "    if attrs.add_source == LOCALFILE_ADDSOURCE and (not attrs.torfile or not os.path.isfile(attrs.torfile)):\n",
        "        return get_adddownload_error(result, f\"Tor file path is empty, or file doesn't exists {attrs.name}\")\n",
        "    try:\n",
        "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
        "            ti = lt.torrent_info(attrs.torfile)\n",
        "            infohash_sha1 = ti.info_hash()\n",
        "            attrs.name = ti.name()\n",
        "            if not ti.is_valid():\n",
        "                return get_adddownload_error(result, f\"Invalid torrent: {attrs.name}\")\n",
        "            result.selectedfiles_count = ti.num_files()\n",
        "            params = {\"save_path\": temp_save, \"ti\": ti}\n",
        "        else:\n",
        "            attrs.name = get_magnet_name(attrs.magnet)\n",
        "            params = lt.parse_magnet_uri(attrs.magnet)\n",
        "            params.save_path = temp_save\n",
        "            infohash_sha1 = params.info_hash\n",
        "        info(f\"Adding download: {attrs.name} with {attrs.add_source}.\")\n",
        "        if not attrs.ready: \n",
        "            prep: Prepare_Result = prepare_download(attrs)\n",
        "            if prep.exists:\n",
        "                result.awaiting_decision = True\n",
        "                result.status = ADDPENDING\n",
        "                replace_download_decision(prep)\n",
        "                return result\n",
        "        sha1keystr = str(infohash_sha1)\n",
        "        result.name = attrs.name\n",
        "        #result.handle = handle\n",
        "        result.files = [] \n",
        "        info(f\"Download info: {attrs.name}\\nHash: {sha1keystr}\")\n",
        "        if sha1keystr in downloads_dict:\n",
        "            return get_adddownload_error(result, f\"{attrs.name} is already added.\")\n",
        "        handlecheck = ses.find_torrent(infohash_sha1)\n",
        "        if handlecheck.is_valid():\n",
        "            ses.remove_torrent(handlecheck)\n",
        "        handle: lt.torrent_handle = ses.add_torrent(params)\n",
        "        handle.name = attrs.name\n",
        "        if not handle.is_valid():\n",
        "            return get_adddownload_error(result, f\"Invalid torrent {attrs.name}\")\n",
        "        result.handle = handle\n",
        "        result.hash = sha1keystr\n",
        "        result.savepath = attrs.save_path\n",
        "        result.savename = attrs.save_name\n",
        "        attrs.hash = sha1keystr\n",
        "        handle.attrs = attrs\n",
        "        handle.progress = 0.0\n",
        "        downloads_dict[sha1keystr] = handle\n",
        "        add_trackers(handle)\n",
        "        torrentfile = handle.torrent_file()\n",
        "        if torrentfile:\n",
        "            handle.name = attrs.name = torrentfile.name()\n",
        "            set_download_filtered_files(result)\n",
        "            handle.attrs.hasmetadata = True\n",
        "            result.hasmetadata = True\n",
        "        else:\n",
        "            handle.attrs.hasmetadata = False\n",
        "            result.hasmetadata = False\n",
        "        if attrs.add_source == LOCALFILE_ADDSOURCE:\n",
        "            cmd = f'mv \"{attrs.torfile}\" \"{added_path}\"'\n",
        "            !$cmd\n",
        "        result.status = ADDSUCCUSS\n",
        "        result.succussmessage = \"Added Successfully \" + attrs.name\n",
        "        info(f\"{attrs.name} is added succussfully. Save name: {attrs.save_name}\")\n",
        "        return result\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while adding download.', ERROR_EVENT)\n",
        "        return get_adddownload_error(result, f\"Download wasn't added {attrs.name}\")\n",
        "\n",
        "def add_hash_download(hash, attrs: DownloadAttrs, name = ''):\n",
        "    if not name:\n",
        "        name = hash\n",
        "    download_link = f\"https://itorrents.org/torrent/{hash}.torrent\"\n",
        "    filename = f\"/content/{name}.torrent\"\n",
        "    cmd = f'wget \"{download_link}\" -O \"{filename}\" {NULL_STREAM}'\n",
        "    !$cmd\n",
        "    attrs.torfile = filename\n",
        "    attrs.add_source = LOCALFILE_ADDSOURCE\n",
        "    return add_download(attrs)\n",
        "\n",
        "def set_download_filtered_files(result: AddResult): \n",
        "    handle = result.handle\n",
        "    status = handle.status()\n",
        "    files = result.files\n",
        "    handle.attrs.full_size = status.total_wanted\n",
        "    handle.full_size = status.total_wanted\n",
        "    handle.selectedfilenames = []\n",
        "    info(f\"Filtering download files for: {handle.name}.\")\n",
        "    totalfiles = selectedfilescount = total_download = 0\n",
        "    tor_file = handle.torrent_file()\n",
        "    if tor_file:\n",
        "        handle.attrs.hasmetadata = True\n",
        "        allfiles = tor_file.files()\n",
        "        total_download = 0\n",
        "        totalfiles = allfiles.num_files()\n",
        "        selectedfilescount = 0\n",
        "\n",
        "        for i in range(totalfiles):\n",
        "            file = DownloadFile(i, allfiles.file_name(i), allfiles.file_size(i))\n",
        "            if any(contains(file.name, check) for check in skip_list):\n",
        "                info(f\"{allfiles.file_name(i)} is filtered.\")\n",
        "                handle.file_priority(i,0)\n",
        "                file.selected = False\n",
        "            else:\n",
        "                selectedfilescount += 1\n",
        "                handle.file_priority(i,6)\n",
        "                total_download += file.size\n",
        "                file.selected = True\n",
        "                handle.selectedfilenames.append(file.name)\n",
        "            files.append(file)\n",
        "    else:\n",
        "        info(handle.name + \" has no metadata.\")\n",
        "        handle.attrs.hasmetadata = False\n",
        "    result.size = total_download\n",
        "    result.selectedfiles_count = selectedfilescount\n",
        "    handle.selected_files_count = selectedfilescount\n",
        "    handle.attrs.download_size = total_download\n",
        "    handle.attrs.allfiles = totalfiles\n",
        "    handle.attrs.selectedfilescount = selectedfilescount\n",
        "    handle.attrs.selectedfilenames = handle.selectedfilenames\n",
        "    handle.attrs.files = files\n",
        "\n",
        "def selectdownloadfiles(handle, files):\n",
        "    if not handle:\n",
        "        return\n",
        "    totaldownload = 0\n",
        "    select_files_count = 0\n",
        "    handle.selectedfilenames.clear()\n",
        "    for file in files:\n",
        "        if file.selected:\n",
        "            handle.file_priority(file.index, 6)\n",
        "            handle.selectedfilenames.append(file.name)\n",
        "            totaldownload += file.size\n",
        "            select_files_count += 1\n",
        "        else:\n",
        "            handle.file_priority(file.index, 0)\n",
        "    handle.total_download = totaldownload\n",
        "    handle.selected_files_count = select_files_count\n",
        "    return True\n",
        "  \n",
        "def add_trackers(handle):\n",
        "    for x in range(len(new_trackers)):\n",
        "        annouce_entry = {'url': new_trackers[x], 'tier': 2}\n",
        "        handle.add_tracker(annouce_entry) \n",
        " \n",
        "#### API / After Download Operations \n",
        "\n",
        "def shave_download(handle, path, maindir) :\n",
        "    tf = handle.torrent_file()\n",
        "    files = tf.files()\n",
        "    priorities = handle.get_file_priorities()\n",
        "    cmd = ''\n",
        "    for i in range(files.num_files()):              # Delete files if they are not selected\n",
        "        file_path = path + \"/\" + files.file_path(i)\n",
        "        if os.path.isfile(file_path) and priorities[i] == 0:\n",
        "            cmd = f'rm \"{file_path}\"'\n",
        "            !$cmd\n",
        "            dirpath = os.path.dirname(file_path)\n",
        "            if is_empty(dirpath):\n",
        "                cmd = f'rm -r \"{dirpath}\"'\n",
        "                !$cmd\n",
        "    if os.path.isdir(maindir):\n",
        "        dircontent = next(os.walk(maindir))[1]\n",
        "        for path in dircontent:                     # Delete empty dirs\n",
        "            if is_empty(path):\n",
        "                cmd = f'rm -r \"{path}\"'\n",
        "                !$cmd\n",
        "    if cmd: pass\n",
        "\n",
        "def clean_download(attrs: DownloadAttrs, localsavingpath):\n",
        "    info(f\"Cleaning type: {types[attrs.type_]} name: {attrs.name}\")\n",
        "    attrs.downloaded_diritems = []\n",
        "    if attrs.type_ == MOVIE:\n",
        "        return after_shave_movie(localsavingpath, attrs.save_name, attrs.selectedfilenames, attrs.downloaded_diritems)\n",
        "    elif attrs.type_ == SHOW:\n",
        "        return clean_tvshow(localsavingpath, diritems= attrs.downloaded_diritems)\n",
        "    elif attrs.type_ == SEASON or attrs.type_ == EPISODE:\n",
        "        diritem =  ('', clean_season(localsavingpath))\n",
        "        attrs.downloaded_diritems.append(diritem)\n",
        "\n",
        "def after_shave_movie(localsavingpath, newname, selectedfilenames= [], downloaded_diritems = []):\n",
        "    if not os.path.isdir(localsavingpath):\n",
        "        raise(Exception(f\"Path isn't a dir: {localsavingpath}\\nExists: {os.path.exists(localsavingpath)}\"))\n",
        "    maindircontent = next(os.walk(localsavingpath))                                 #       TODO fix bug\n",
        "    originaldiritems = [('', maindircontent[2])]\n",
        "    for dirname in maindircontent[1]:\n",
        "        if 'sub' in dirname.lower():\n",
        "            subspath = f\"{localsavingpath}/{dirname}\" \n",
        "            originaldiritems.append((dirname, next(os.walk(subspath))[2]))\n",
        "            info(f\"Movies subtites found: {dirname}\")\n",
        "            break\n",
        "    try:\n",
        "        for diritem in originaldiritems:\n",
        "            originalfilenames = diritem[1].copy()\n",
        "            diritem[1].clear()\n",
        "            dirpath =  f\"{localsavingpath}/{diritem[0]}/\" if diritem[0] else f'{localsavingpath}/'\n",
        "            info(f\"Checking dir at {dirpath}\")\n",
        "            for filename in originalfilenames:\n",
        "                if filename in selectedfilenames or not selectedfilenames:\n",
        "                    suffix = ''\n",
        "                    langsuffix = ''\n",
        "                    suffixfilecount = 0\n",
        "                    filename_split = os.path.splitext(filename)\n",
        "                    filenamewithoutextension = filename_split[0]\n",
        "                    fileextension = filename_split[1].lower()\n",
        "                    originalfilepath = dirpath + filename\n",
        "                    if any(contains(filename, check) for check in skip_list):\n",
        "                        info(f\"Deleting: {originalfilepath}\")\n",
        "                        cmd = f'rm \"{originalfilepath}\"'\n",
        "                        !$cmd\n",
        "                    elif  (fileextension == \".mp4\" or fileextension == \".mkv\" or fileextension in subtitlefile_extensions):\n",
        "                        if fileextension in subtitlefile_extensions: \n",
        "                            langsearch = langs_pt.findall(filenamewithoutextension)\n",
        "                            if langsearch:  \n",
        "                                langsuffix = f\".{title(langsearch[-1])}\"\n",
        "                        if filenamewithoutextension != newname:\n",
        "                            filenewname = newname + langsuffix + fileextension\n",
        "                            renamedfilepath = dirpath + filenewname\n",
        "                            while os.path.exists(renamedfilepath):\n",
        "                                suffixfilecount += 1\n",
        "                                suffix = f\".{suffixfilecount}{langsuffix}\"\n",
        "                                filenewname = newname + suffix + fileextension\n",
        "                                renamedfilepath = dirpath + filenewname\n",
        "                            info(f\"Renaming: {filename} to {filenewname}\")\n",
        "                            cmd = f'mv \"{originalfilepath}\" \"{renamedfilepath}\"'\n",
        "                            !$cmd\n",
        "                            filename = filenewname\n",
        "                        diritem[1].append(filename)\n",
        "            downloaded_diritems.append(diritem)\n",
        "        release()\n",
        "        return True\n",
        "    except:\n",
        "        error(ex())\n",
        "        release()\n",
        "        return False\n",
        "    cmd\n",
        "\n",
        "def clean_movies_dir(movie_path= config.movies_path, v= False, backup= False, delete_empty = False, clean = True) :\n",
        "    dir_content = filter_checks(next(os.walk(movie_path))[1])\n",
        "    path = \"\"\n",
        "    for dir in dir_content :\n",
        "        path = movie_path + \"/\" + dir\n",
        "        if delete_empty:\n",
        "            size = pathsize(path)\n",
        "            if size < size_limit:\n",
        "                !rm -r \"$path\"\n",
        "                if backup and config.moviesbackups: #fixbackup\n",
        "                    for mvdir in config.moviesbackups:\n",
        "                        if not mvdir in movie_path:\n",
        "                            path0 = \"bk path\"\n",
        "                            size = pathsize(path0)\n",
        "                            if size < size_limit:\n",
        "                                if v:\n",
        "                                    print(f\"Deleting: {path0} size: {data_str(size)}\")\n",
        "                                !rm -r \"$path0\" \n",
        "                continue\n",
        "        if clean:\n",
        "            clean_movie(path, dir, movie_path)\n",
        "\n",
        "def clean_movie(path, name, movie_path = config.movies_path):\n",
        "    newname = name\n",
        "    search = yearsuff_pt.search(name)\n",
        "    if not search:\n",
        "        newname = name_movie(name)\n",
        "        p1 = path\n",
        "        p2 = f\"{movie_path}/{newname}\"\n",
        "        cmd = f'mv \"{p1}\" \"{p2}\"'\n",
        "        !$cmd\n",
        "        path = p2\n",
        "        print(newname)\n",
        "    after_shave_movie(path, newname)\n",
        "\n",
        "def clean_tvshows(path = \"\"):\n",
        "    if not path:\n",
        "        path = config.tv_path\n",
        "    shows = next(os.walk(path))[1]\n",
        "    for show in shows:\n",
        "        print(show)\n",
        "        path = path + \"/\" + show\n",
        "        clean_tvshow(path)\n",
        "\n",
        "def clean_tvshow(path, keepChar = \"\", diritems = []):\n",
        "    dircontent = next(os.walk(path))[1]\n",
        "    if len(dircontent) != 0:\n",
        "        for dir in dircontent:\n",
        "            p0 = f\"{path}/{dir}\"\n",
        "            if not has_size(p0, True):\n",
        "                cmd = f'rm -r \"{p0}\"'\n",
        "                !$cmd\n",
        "                continue\n",
        "            newname = get_season(dir, False)\n",
        "            if newname:\n",
        "                if newname != dir:\n",
        "                    p0 =  f\"{path}/{dir}\"\n",
        "                    p1 = f\"{path}/{newname}\"\n",
        "                    cmd = f'mv \"{p0}\" \"{p1}\"'\n",
        "                    !$cmd\n",
        "                    dir = newname\n",
        "            seasonpath = f\"{path}/{dir}\"\n",
        "            files = clean_season(seasonpath, keepChar)\n",
        "            item = (dir, files)\n",
        "            diritems.append(item)\n",
        "    else:\n",
        "        files = clean_season(path, keepChar)\n",
        "        item = ('', files)\n",
        "        diritems.append(item)\n",
        "    return\n",
        "\n",
        "def clean_season(path, keepDot = False):\n",
        "    clean = []\n",
        "    info(f'Cleaning show season in path: {path}')\n",
        "    if not os.path.exists(path):\n",
        "        return\n",
        "    files = next(os.walk(path))[2]\n",
        "    for file in files:\n",
        "        splitted = os.path.splitext(file)\n",
        "        eps = splitted[0]\n",
        "        ext = splitted[1]\n",
        "        p1 = f\"{path}/{file}\"\n",
        "        if ext == \".mkv\" or ext == \".mp4\" or ext == \".srt\":\n",
        "            newname = name_episode(eps, keepDot= keepDot) + ext\n",
        "            if newname != file:\n",
        "                p2 = f\"{path}/{newname}\"\n",
        "                cmd = f'mv \"{p1}\" \"{p2}\"'\n",
        "                !$cmd\n",
        "            clean.append(newname)\n",
        "        elif any(contains(file.lower(), check) for check in skip_list):\n",
        "            cmd = f'rm \"{p1}\"'\n",
        "            !$cmd\n",
        "    info(f'Cleaned files: {len(clean)}')   \n",
        "    return clean\n",
        "\n",
        "#### API / IMDB \n",
        "\n",
        "from math import ceil\n",
        "linkhtmlstr = 'target=\"_blank\" style= \"color: rgb(1, 74, 118); text-decoration: none;\"'\n",
        "def process_external_link(title, suff_text= \"\", base= \"\"):\n",
        "    if title:\n",
        "        title = str(title)\n",
        "        if suff_text:\n",
        "            title = title.replace(\"</a>\", f\" {suff_text}</a>\")\n",
        "        title = title.replace('<a href=\"', f'<a {linkhtmlstr} href=\"{base}') \n",
        "        return title\n",
        "    return ''\n",
        "    \n",
        "def searchIMDB(imdbparams: IMDBParams, page= 1, perpage= 40, result: IMDBResult= None):\n",
        "    if page < 1: page = 1\n",
        "    imdbgroupsandlabels = \"\"\n",
        "    if imdbparams.top250:\n",
        "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_TOP_250 + \",\"\n",
        "    if imdbparams.top1000:\n",
        "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_TOP_1000 + \",\"\n",
        "    if imdbparams.oscarwinner:\n",
        "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_OSCAR_WINNER + \",\"\n",
        "    if imdbparams.bestpicturewinner:\n",
        "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_BEST_PICTURE_WINNER + \",\"\n",
        "    if imdbparams.bestdirectorwinner: \n",
        "        imdbgroupsandlabels = imdbgroupsandlabels + IMDB_BEST_DIRECTOR_WINNER \n",
        "\n",
        "    lists = ''\n",
        "    if imdbparams.inlists: lists = imdbparams.inlists\n",
        "    if imdbparams.notinlists:\n",
        "        lists = (lists + \",\" if lists else lists) + IMDB_EXCULDE_MARK + imdbparams.notinlists.replace(',', ',' + IMDB_EXCULDE_MARK) \n",
        "    if imdbparams.englishonly: \n",
        "        lists = (lists + \",\" if lists else lists) + IMDB_EXCULDE_MARK + config.international_titles_list + \",\" + IMDB_EXCULDE_MARK \\\n",
        "            + config.indian_titles_list + \",\" + IMDB_EXCULDE_MARK + config.animation_titles_list + \"&languages=en\"\n",
        "    else:\n",
        "        if imdbparams.internationaltitles: \n",
        "            lists = (lists + \",\" if lists else lists) + config.international_titles_list \n",
        "        if imdbparams.indiantitles: \n",
        "            lists = (lists + \",\" if lists else lists) + config.indian_titles_list\n",
        "        if imdbparams.animationtitles: \n",
        "            lists = (lists + \",\" if lists else lists) + config.animation_titles_list \n",
        "    \n",
        "    sortandorder = imdbparams.imdbsort\n",
        "    if imdbparams.imdborder == ASCORDER:   \n",
        "        sortandorder = sortandorder + \",asc\"\n",
        "    else:   sortandorder = sortandorder + \",desc\" \n",
        "    releasedates = f\"&release_date={imdbparams.startdate},{imdbparams.enddate}\" if imdbparams.startdate or imdbparams.enddate else ''\n",
        "    ratings = f\"&user_rating={imdbparams.minrating if imdbparams.minrating else ''},{imdbparams.maxrating if imdbparams.maxrating else ''}\" if imdbparams.minrating or imdbparams.maxrating else ''\n",
        "    votes = f\"&num_votes={imdbparams.minvotes if imdbparams.minvotes else ''},{imdbparams.maxvotes if imdbparams.maxvotes else ''}\" if imdbparams.minvotes or imdbparams.maxvotes else ''\n",
        "    runtime = f\"&runtime={imdbparams.minruntime if imdbparams.minruntime else ''},{imdbparams.maxruntime if imdbparams.maxruntime else ''}\" if imdbparams.minruntime or imdbparams.maxruntime else ''\n",
        "    userwatched = '' # \"&my_ratings=exclude\" if params.filterwatched else ''\n",
        "    pagestr= f\"start={1+((page-1)*perpage)}\"\n",
        "    url = f'{IMDB_BASE}/search/title/?title={imdbparams.keyword}&title_type={imdbparams.titletype}{releasedates}{ratings}{votes}{runtime}{userwatched}&lists={lists}&groups={imdbgroupsandlabels}&sort={sortandorder}&view=advanced&count={perpage}&{pagestr}'\n",
        "    if not result:\n",
        "        result = IMDBResult(search= imdbparams.keyword, imdbparams= imdbparams, url= url, sort=imdbparams.imdbsort,\n",
        "                            order= imdbparams.imdborder, attrs= imdbparams.attrs)\n",
        "        appstate.searchresults.append(result)\n",
        "    response = requests.get(url, headers = {\"Accept-Language\": \"en-US\"})\n",
        "    result.currentpageurl = url\n",
        "    result.page = page\n",
        "    result.sort = imdbparams.imdbsort\n",
        "    result.order = imdbparams.imdborder\n",
        "    result.request = response \n",
        "    if response.status_code == 200:\n",
        "        info(\"\\n IMDB Search Done Successfully.\\n\")\n",
        "        soup = Soup(response.text,'html.parser')    \n",
        "        main = soup.find(\"div\", id= \"main\")\n",
        "        if not main :\n",
        "            error(\"AdvancedIMDBSearch: Error: An error occured while performing the web scrapping.\")\n",
        "            return\n",
        "        countText = main.select_one(\"div.nav > div.desc > span\").text\n",
        "        countSearch = imdbcount_pt.search(countText)\n",
        "        if countSearch:\n",
        "            result.resultscount = int(countSearch.group())\n",
        "            result.totalpages = ceil(result.resultscount/perpage)\n",
        "            result.nextpage = page + 1 if page + 1 <= result.totalpages else 0  \n",
        "            result.previouspage = page - 1  \n",
        "        else:\n",
        "            result.previouspage = 0\n",
        "            result.nextpage = 0\n",
        "            result.totalpages = 1\n",
        "            \n",
        "        titles: list[IMDBTitle]= []\n",
        "        downloaded: list[IMDBTitle]= []\n",
        "        watched: list[IMDBTitle] = []\n",
        "        allitems = main.findAll(class_=\"lister-item\")\n",
        "        for item in allitems:\n",
        "            try:\n",
        "                title_tag  = item.find(class_=\"lister-item-header\").a\n",
        "                year_text  = item.find(class_=\"lister-item-year\").text\n",
        "                title_link = process_external_link(title_tag, year_text, IMDB_BASE)\n",
        "                title_text = find_title(title_tag.text, year_text)\n",
        "                runtime    = item.find(class_=\"runtime\")\n",
        "                rating     = item.find(class_=\"ratings-imdb-rating\")[\"data-value\"]\n",
        "                votes      = item.find(\"span\", {\"name\": \"nv\"}).text.strip()\n",
        "                if runtime: runtime = runtime.text.strip()\n",
        "                else: runtime = \"\"\n",
        "                genres = item.find(class_=\"genre\")\n",
        "                if genres: genres = genres.text.strip()\n",
        "                else: genres = \"\"\n",
        "                ppl = item.select_one(\"div.lister-item-content > p:nth-child(5)\")\n",
        "                pplstr = str(ppl).replace('\\n', '')\n",
        "                search = stars_pt.search(pplstr)\n",
        "                stars = search.group().replace('<a href=\"', f'<a {linkhtmlstr} href=\"{IMDB_BASE}') if search else \"\"\n",
        "                search = director_pt.search(pplstr)\n",
        "                directors = search.group().replace('<a href=\"', f'<a {linkhtmlstr} href=\"{IMDB_BASE}') if search else \"\"\n",
        "                title= IMDBTitle(title_text= title_text, title_link= title_link, runtime= runtime, rating= rating, votes= votes, genres= genres, directors= directors, stars= stars)\n",
        "                if title_text in config.watched_movies_list:\n",
        "                    title.watched = True\n",
        "                    watched.append(title)\n",
        "                if movie_exists(title_text):\n",
        "                    downloaded.append(title)\n",
        "                    title.downloaded= True\n",
        "                    if not imdbparams.filterdownloaded:\n",
        "                        titles.append(title) \n",
        "                else:\n",
        "                    titles.append(title)\n",
        "                info(f\"Scrapped IMDB title {title_link}\")\n",
        "            except:\n",
        "                error(ex())\n",
        "                continue       \n",
        "        result.results = titles\n",
        "        result.resultpages[getpagekey(imdbparams.imdbsort, imdbparams.imdborder, page)] = titles\n",
        "        result.watchedtitles = watched\n",
        "        result.watchedtitlespages[page] = watched\n",
        "        result.downloadedtitles = downloaded\n",
        "        result.downloadedtitlespages[page] = downloaded\n",
        "        result.pageresultcount = len(titles)\n",
        "        result.downloadedcount = len(downloaded)\n",
        "        result.watchedcount = len(watched)\n",
        "        result.status = SUCCUSS\n",
        "    else:\n",
        "        result.error = f\"AdvancedIMDBSearch: Error accessing the web page. Code error: {response.status_code}\"\n",
        "        error(result.error)\n",
        "        result.status = FAIL\n",
        "    release()\n",
        "    return result\n",
        "\n",
        "#### API / rarbg api\n",
        "\n",
        "tokens = {\"TD0\": \"anpfy1ko6z\", \"TD1\": \"b2nuip039q\", \"TD2\": \"84gy57ew3v\", \"TD3\": \"2kjweiogl5\", \"TD4\": \"e0bnj3xucl\", \"TD5\": \"cs4r9hvpkj\", \"TD6\": \"uso5jew6yh\", \"TD7\": \"yc82r5ogws\", \"TD8\": \"fhpkc0ivau\", 'TD9': 'm9ytpnkdxj'}\n",
        "rarbg_api = 'http://torrentapi.org/pubapi_v2.php'\n",
        "token = tokens[td_id]\n",
        "version = '2.6.0'\n",
        "app_id = 'TRD'\n",
        "user_agent = \"TRD/1.5.0 (Linux; c6afa4a080b9; 5.10.133+; #1 SMP Fri Aug 26 08:44:51 UTC 2022; x86_64; x86_64) python 3.7.13\"\n",
        "\n",
        "def get_user_agent():\n",
        "    uname = '; '.join(platform.uname())\n",
        "    pyver = platform.python_version()\n",
        "    return f'{app_id}/{version} ({uname}) python {pyver}'\n",
        "\n",
        "def rarbgrequest(method, url, params=None):\n",
        "    info(f\"Request {method}@{url}\\nParams: {params}\")\n",
        "    if not params:\n",
        "        params = {}\n",
        "    params.update({'app_id': app_id})\n",
        "    headers = {'user-agent': user_agent}\n",
        "    sess = requests.Session()\n",
        "    req = requests.Request(method, url, params=params, headers=headers)\n",
        "    preq = req.prepare()\n",
        "    res = sess.send(preq)\n",
        "    info(f\"Request status: {res.status_code}\")\n",
        "    res.raise_for_status()\n",
        "    return res\n",
        "\n",
        "def rarbg_token():\n",
        "    info('Refreshing rarbg token.')\n",
        "    params = {'get_token': 'get_token'}\n",
        "    res = rarbgrequest('GET', rarbg_api, params)\n",
        "    json_res = res.json() if res and res.status_code == 200 else None\n",
        "    if json_res and 'token' in json_res:\n",
        "        info(\"Rarbg token successfully refreshed.\")\n",
        "        global token, user_agent\n",
        "        token = json_res['token']\n",
        "        user_agent = get_user_agent()\n",
        "        info(f\"New rarbg token: {token} User agent: {user_agent}\")\n",
        "    else:\n",
        "        error(f'Error while getting a rarbg token. status code: {res.status_code()}\\nrequest result: {res}\\nUser agent: {user_agent}')\n",
        "\n",
        "def rarbg_rip(key= '', imdb = '', categories = None, sort = ''):\n",
        "    catstr = 'any' if categories == None else categories\n",
        "    info(f\"Searching for: {key} {imdb} in categories: {catstr}\")\n",
        "    category = ''\n",
        "    params = {'mode': 'search','token': token}\n",
        "    if key:\n",
        "        params['search_string'] = key\n",
        "    elif imdb:\n",
        "        params['search_imdb'] = imdb\n",
        "    else:\n",
        "        return None\n",
        "    if categories:\n",
        "        category = str(categories[0])\n",
        "        for i in range(1, len(categories)):\n",
        "            category += ';' + str(categories[i])\n",
        "        params['category'] = category \n",
        "    if sort:\n",
        "        params['sort'] = sort\n",
        "    try:\n",
        "        res = rarbgrequest('GET', rarbg_api, params)\n",
        "        json_res = res.json() if res.status_code == 200 else None\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while searching Rarbg.', ERROR_EVENT)\n",
        "        return None\n",
        "    if json_res:\n",
        "        if \"error_code\" in json_res.keys():\n",
        "            if json_res[\"error_code\"] == 20:\n",
        "                info(f\"Searching for {key if key else imdb} got no results. \\nRequest result: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\\nThe API may not be working check the link.\")\n",
        "            else:\n",
        "                error(f\"An error happened while requesting rarbg api. Error: {json_res['error']}. Error code: {json_res['error_code']}.\\nParams: {params}\")     \n",
        "            rarbg_token()\n",
        "            params['token'] = token\n",
        "            time.sleep(1)\n",
        "            info(f\"Retrying search for: {key} {imdb}\")\n",
        "            res = rarbgrequest('GET', rarbg_api, params)\n",
        "            json_res = res.json() if res.status_code == 200 else None  \n",
        "        if json_res and 'torrent_results' in json_res:\n",
        "            results = []\n",
        "            for rs in json_res['torrent_results']:\n",
        "                result: DownloadResult = DownloadResult(rs[\"filename\"])\n",
        "                result.magnet = rs[\"download\"]\n",
        "                results.append(result)\n",
        "            info(f\"Successfully searched: {key} {imdb} in categories: {catstr} {len(results)} results.\")\n",
        "            return results\n",
        "    error(f\"Search for: {key} {imdb} in categories: {catstr} wasn't completed.\\nResult: {str(json_res)}. Status code: {res.status_code}\\nParams: {params}\")\n",
        "    return False\n",
        "\n",
        "def Download_Rarbg(search, category = '', sort = SEEDERSSORT, rarbg_auto = False, attrs: DownloadAttrs = None):\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    info(f\"Searching for {search} in rarbg.com.\")\n",
        "    print(f\"\\nSearching for:  {search} in rarbg.com.\\n\")\n",
        "    rarbgsort = magnet = name = \"\"\n",
        "    if category == MOVIESCATEGORY_TD:\n",
        "        all_cat = RARBG_MOVIE\n",
        "        categories = RARBG_MOVIE\n",
        "    elif category == TVCATEGORY_TD : \n",
        "        all_cat = RARBG_TV\n",
        "        categories = RARBG_TV\n",
        "    else:\n",
        "        all_cat = None\n",
        "        categories = None\n",
        "    rarbgsort = SORTRARBG_SEEDERS  \n",
        "    if sort == TIMESORT:\n",
        "        rarbgsort = SORTRARBG_TIME\n",
        "    results: list[DownloadResult]\n",
        "    state = 1                                 # 1 init, 2 edit & redo search, 0 done, -1 bad search\n",
        "    while state != 0 :\n",
        "        if state == 1:\n",
        "            results = rarbg_rip(key = search, categories = categories, sort = rarbgsort)\n",
        "            if not results and categories and state != 2 :    \n",
        "                results = rarbg_rip(key = search, sort = rarbgsort)\n",
        "            state = 3\n",
        "        elif state == 2:\n",
        "            link = f\"https://rarbgenter.org/torrents.php?search={search.replace(' ', '+')}\"\n",
        "            warning(f\"Searching for {search} in rarbg.com. No results were found. Please check the link to ensure the results.\\n{link}\")\n",
        "            print(f\"No results were found. Please check the link to ensure the results.\\n{link}\\n\\nEnter e:[search] to edit, m:[magnet] to add magnet directly:, i < 7 to exit:\\n\")\n",
        "            newinput = input()\n",
        "            if len (newinput) < 7:\n",
        "                return -1\n",
        "\n",
        "            elif newinput.startswith(\"m:\"):\n",
        "                magnet = newinput[2:]\n",
        "                try:\n",
        "                    name = get_magnet_name(magnet)\n",
        "                except Exception as e:\n",
        "                    name = search\n",
        "                    error(ex())\n",
        "                    error(f\"Magnet name wasn't obtained\")\n",
        "                    updatestatushtml('An error happend while searhcing Rarbg.', ERROR_EVENT)\n",
        "                results = None\n",
        "                state = 4\n",
        "            elif newinput.startswith(\"e:\"):\n",
        "                newinput = newinput[2:]\n",
        "                results = rarbg_rip(key = newinput, sort = rarbgsort)\n",
        "                state = 1\n",
        "        if results: \n",
        "            print(\"\\n     {:<70}{:>10}{:>10}\\n\".format(\"Title\", \"Size\", \"Seeders\"))\n",
        "            for i in range(len(results)):\n",
        "                print(\" {:<2}- {:<70}\".format(i + 1 , results[i].title))\n",
        "            if len(results) == 1 and rarbg_auto:\n",
        "                magnet = results[0].magnet\n",
        "                name = results[0].title\n",
        "                state = 4\n",
        "            else:\n",
        "                print(\"\\nPlease choose one of the results to download             Format [single]     Enter q to exit, e to edit the search:\")\n",
        "                choice = -1\n",
        "                while choice == -1:                   #out of range get input again.\n",
        "                    choice = input().lower()\n",
        "                    if choice == \"\" or choice == \" \" or choice == \"s\" or choice == \"q\": \n",
        "                        return -1\n",
        "                    elif choice == \"e\":\n",
        "                        state = 2\n",
        "                        break\n",
        "                    choice = int(choice) - 1\n",
        "                    if choice < 0 or choice >= len(results):\n",
        "                        info(\"\\nChoice out of range.\")\n",
        "                        choice = -1\n",
        "                if state == 2:\n",
        "                    continue\n",
        "                else:\n",
        "                    magnet = results[choice].magnet\n",
        "                    name = results[choice].title\n",
        "                    results = None\n",
        "                    state = 4\n",
        "        if state == 4:      \n",
        "            attrs.site_source = RARBG\n",
        "            attrs.name = name\n",
        "            attrs.magnet = magnet\n",
        "            result: AddResult = None #add_magnet_download(magnet, attrs)\n",
        "            if result.status == ADDSUCCUSS:\n",
        "                state = 0\n",
        "                return 0\n",
        "            else:\n",
        "                return -1\n",
        "        else:\n",
        "            state = 2\n",
        "    return 0\n",
        "\n",
        "#### API / Search \n",
        "\n",
        "requests_header = {\"Accept-Language\": \"en-US\", 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'}\n",
        "\n",
        "def getsitesort(sort, order, site):\n",
        "    if site == X1337X:\n",
        "        if sort == SEEDERSSORT:\n",
        "            sort1337x = X1337X_SEEDERS\n",
        "        elif sort == TIMESORT:\n",
        "            if order == DESCORDER:\n",
        "                sort1337x = X1337X_TIME_DESC\n",
        "            else:\n",
        "                sort1337x = X1337X_TIME_ASC\n",
        "        elif sort == SIZESORT:\n",
        "            if order == DESCORDER:\n",
        "                sort1337x = X1337X_SIZE_DESC\n",
        "            else:\n",
        "                sort1337x = X1337X_SIZE_ASC\n",
        "        return sort1337x\n",
        "\n",
        "def getsitecategory(category, site):\n",
        "    if site == X1337X:\n",
        "        if category == TVCATEGORY_TD:\n",
        "            return X1337X_TV\n",
        "        if category == MOVIESCATEGORY_TD:\n",
        "            return X1337X_MOVIES \n",
        "        if category == APPSCATEGORY_TD:\n",
        "            return X1337X_APPS\n",
        "        if category == GAMESCATEGORY_TD:\n",
        "            return X1337X_GAMES  \n",
        "    return ALLCATEGORIES_TD\n",
        "        \n",
        "def search1337x(search, sort= SEEDERSSORT, order= DESCORDER, category = \"\", page = 1, attrs = None, result: SearchResult= None):\n",
        "    if page < 1: page = 1\n",
        "    if not attrs:\n",
        "        attrs = DownloadAttrs()\n",
        "    if not result:    \n",
        "        result = SearchResult(search= search, site= X1337X, category= ALLCATEGORIES_TD, attrs= attrs)\n",
        "        appstate.searchresults.append(result)\n",
        "    l337xsort = getsitesort(sort, order, X1337X)\n",
        "    search_s = search.replace(\"'\", \" \").replace(\" \",\"%20\")\n",
        "    parameters = f\"/sort-category-search/{search_s}/{category}/{l337xsort}/{page}/\" if category else f\"/sort-search/{search_s}/{l337xsort}/{page}/\"\n",
        "    url = X1337XPROXEY_BASE + parameters\n",
        "    info(f\"Scraping 1337x search for: {search} Page: {page}\\nURL: {url}.\")\n",
        "    download_state = \"downloaded\" if check_download(attrs.type_, search) else \"not downloaded\"\n",
        "    info(f\"{search} is {download_state}.\")\n",
        "    request = requests.get(url, headers= requests_header)\n",
        "    if request.status_code == 200 :\n",
        "        soup = Soup(request.text, 'html.parser' )\n",
        "        pagination = soup.find(attrs={\"class\":\"pagination\"})\n",
        "        if not pagination:\n",
        "            previouspage = 0\n",
        "            nextpage = 0\n",
        "            totalpages = 1\n",
        "        else:\n",
        "            lastpgelement = pagination.find(attrs= {'class':'last'})\n",
        "            if lastpgelement:\n",
        "                lastpg = lastpgelement.a\n",
        "                totalpages = int(l337xpages_pt.search(lastpg.get('href')).group())\n",
        "            else:\n",
        "                totalpages = page\n",
        "            previouspage = page - 1\n",
        "            nextpage = page + 1 if page + 1 <= totalpages else 0\n",
        "        result.page = page\n",
        "        result.previouspage = previouspage\n",
        "        result.nextpage = nextpage\n",
        "        result.totalpages = totalpages\n",
        "        result.sort = sort\n",
        "        result.order = order\n",
        "        main_element = soup.find(\"tbody\")\n",
        "        if main_element is None:\n",
        "            warning(\"\\nResults table is null search.\\n\")\n",
        "            result.status = FAIL\n",
        "            result.result = \"Null search. main element not found.\"\n",
        "            result.request = request\n",
        "        else:\n",
        "            result.status = SUCCUSS\n",
        "            all_res = main_element.findAll(\"tr\")\n",
        "            resulturl = size = uploader = seeders = leechers = \"\"\n",
        "            results = [] \n",
        "            if all_res:\n",
        "                info(f\"Results found: {len(all_res)}.\")\n",
        "                for i in  range(len(all_res)):\n",
        "                    alldata: list[Tag] = all_res[i].findAll(\"td\")\n",
        "                    resulturl = process_external_link(alldata[0].findAll(\"a\")[1], base= X1337X_BASE)\n",
        "                    size = alldata[4].contents[0]\n",
        "                    date = alldata[3].text\n",
        "                    seeders = alldata[1].text\n",
        "                    leechers = alldata[2].text\n",
        "                    uploader = alldata[5].a.text\n",
        "                    href = X1337XPROXEY_BASE + alldata[0].findAll(\"a\")[1]['href']\n",
        "                    res = DownloadResult(resulturl= resulturl, size= size, date= date, seeders= seeders, leechers= leechers, uploader= uploader, href= href)\n",
        "                    results.append(res)\n",
        "                result.resultcount = len(results)\n",
        "                result.results = results\n",
        "                result.resultpages[getpagekey(sort, order, page)] = results\n",
        "            else:\n",
        "                info(f\"No results found for {search}.\")\n",
        "                result.status = FAIL\n",
        "                result.result = f\"No results found for {search}.\"\n",
        "                result.request = request\n",
        "    else:\n",
        "        error(f\"An error occured while trying to access 1337x.com  status: {request.status_code}.\")\n",
        "    release()\n",
        "    return result\n",
        "\n",
        "def download1337x(result: DownloadResult, attrs: DownloadAttrs):\n",
        "    info(f'Adding download {attrs.name} from search.')\n",
        "    maintabs.selected_index = appstate.tab_indices[ADD_TAB]\n",
        "    switchview(nav[ADD_TAB], getloadingview(f'Adding download from search results.'), temp= True)\n",
        "    downloadpage = requests.get(result.href)\n",
        "    soup = Soup(downloadpage.text, \"html.parser\")\n",
        "    attrs.site_source = X1337X  \n",
        "    hash = soup.find(class_=\"infohash-box\").span.text.strip()  \n",
        "    if not hash:\n",
        "        error(\"Hash value couldn't be found.\")\n",
        "        switchview(nav[ADD_TAB])\n",
        "    else:\n",
        "        addresult =  add_hash_download(hash, attrs)\n",
        "        if not addresult.awaiting_decision:\n",
        "            process_adddownload_result(addresult)\n",
        "    release()\n",
        "     \n",
        "#### API / File Manager\n",
        "\n",
        "def mv(from_path, to_path, content=None, backup=False, movie_name=False, show_name=False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok=True)\n",
        "        if content:\n",
        "            info(f\"Moving batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to move [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0, len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input().lower().strip()\n",
        "            if inpt == \"q\":\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)\n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))\n",
        "                        if end > len(content) or start < 0:\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Moving: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            rename = \"\"\n",
        "            if movie_name:\n",
        "                rename = \"/\" + name_movie(content[i])\n",
        "            elif show_name:\n",
        "                rename = \"/\" + name_show(content[i])\n",
        "  \n",
        "            p1 = (from_path + \"/\" + content[i]) if content else from_path\n",
        "            p2 = to_path + rename\n",
        "            info(f\"Moving {p1} to: {p2}\")\n",
        "            os.makedirs(to_path, exist_ok=True)\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "            if backup and False:  # fixbackup\n",
        "                info(f\"Processing backup.\")\n",
        "                for i in range(1, 4):\n",
        "                    p11bak = \"bk path\"\n",
        "                    tpbak = \"bk path\"\n",
        "                    if not (p11bak[0] in from_path and tpbak[0] in to_path):\n",
        "                        tp = tpbak[1]\n",
        "                        p11 = p11bak[1]\n",
        "                        p21 = tp + rename\n",
        "                        if os.path.exists(p11):\n",
        "                            os.makedirs(tp, exist_ok=True)\n",
        "                            print(f\"Moving {p11} to {p21}\\n\")\n",
        "                            info(f\"Moving {p11} to {p21}\")\n",
        "                            !mv \"$p11\" \"$p21\"\n",
        "                        else:\n",
        "                            print(f\"Backup {p11} Doesn't exist.\\n\")\n",
        "                            warning(f\"Backup {p11} Doesn't exist.\")\n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(\"Moving done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\")\n",
        "        return\n",
        "\n",
        "def cp(from_path, to_path, content = None, backup = False, movie_name = False, show_name = False):\n",
        "    if to_path:\n",
        "        os.makedirs(to_path, exist_ok= True)  \n",
        "        if content:\n",
        "            info(f\"Copying batch of files to: {to_path}\")\n",
        "            print(\"\\n Enter selection to copy [item1,item2,start-end  All: . Exit: q]:\\n\")\n",
        "            print_files(content, 0 ,len(content))\n",
        "            print()\n",
        "            items: list[int] = []\n",
        "            start = end = 0\n",
        "            inpt = input()\n",
        "            if inpt == \"q\":\n",
        "                return\n",
        "            if '.' == inpt:\n",
        "                start = 0\n",
        "                end = len(rng)      \n",
        "            else:\n",
        "                rngs = inpt.split(',')\n",
        "                for rng in rngs:\n",
        "                    if '-' in rng:\n",
        "                        rngs = rng.split('-')\n",
        "                        start = int(rngs[0]) - 1\n",
        "                        end = int((rngs[1]))\n",
        "                        items.extend(range(start, end))      \n",
        "                        if end > len(content) or start < 0 :\n",
        "                            print(\"The ranges' ends are out of the directory file range.\")\n",
        "                        continue\n",
        "                    else:\n",
        "                        i = int(rng)-1\n",
        "                        items.append(i)\n",
        "        else:\n",
        "            info(f'Copying: {from_path}\\nProcess backup: {backup}')\n",
        "            items = [0]\n",
        "  \n",
        "        for i in items:\n",
        "            newname  = \"\"\n",
        "            if movie_name:\n",
        "                newname =  name_movie(items[i])\n",
        "            elif show_name:\n",
        "                newname = name_show(items[i]) \n",
        "  \n",
        "            p1 = from_path + \"/\" + content[i] if content else from_path\n",
        "            if newname:\n",
        "                p2 = from_path + \"/\" +  newname if content else os.path.dirname(from_path) + '/' + newname\n",
        "                print(\"  Renaming:  {} to {}\".format(items[i], newname))\n",
        "                !mv \"p1\" \"$p2\"\n",
        "                p1 = p2\n",
        "  \n",
        "            print(f\"Copying:  {p1} to {to_path}\")\n",
        "            info(f\"Copying:  {p1} to {to_path}\")\n",
        "            !rsync -r --size-only  \"$p1\" \"$to_path\"\n",
        "            if backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    p3bak = \"bk path\"\n",
        "                    if not (p3bak[0]in from_path and p3bak[0] in to_path):\n",
        "                        p3 =  p3bak[1]\n",
        "                        os.makedirs(p3, exist_ok= True)\n",
        "                        print(f\"Copying  {p1} to {p3}\\n\")\n",
        "                        info(f\"Copying:  {p1} to {p3}\")\n",
        "                        !rsync -r --size-only \"$p1\" \"$p3\" \n",
        "  \n",
        "        print(\"\\n   .....................\\n           Done\\n\")\n",
        "        info(f\"Copying done.\")\n",
        "        return\n",
        "    else:\n",
        "        error(\"No distination provided.\\n\")\n",
        "        return\n",
        "    \n",
        "def rename(path, newpath, backup, content = None):\n",
        "    print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "    !mv \"$path\" \"$newpath\" \n",
        "    if backup and False: #fixbackup\n",
        "        for i in range(1,4):\n",
        "            pathbu = \"bk path\"\n",
        "            newpathbu = \"bk\"\n",
        "            if not pathbu[0] in path and os.path.exists(pathbu[1]):\n",
        "                path = pathbu[1]\n",
        "                newpath = newpathbu[1]    \n",
        "                print(f\"Renaming:  {path[27:]} to {newpath[27:]}\")\n",
        "                !mv \"$path\" \"$newpath\"      \n",
        "\n",
        "        int(\"......................\")\n",
        "    print(\"       Done\")\n",
        "    return  \n",
        "  \n",
        "def rm(delpath, process_backup = False, replace = False, content = None):\n",
        "    if content:\n",
        "        content.sort()\n",
        "        info(f'Deleing files in from: {delpath}\\nProcess backup: {process_backup}')\n",
        "        items: list[int] = []\n",
        "        #print_files(content, 0 ,len(content))\n",
        "        start = end = 0\n",
        "        inpt = input()\n",
        "        if inpt == \"q\":\n",
        "            return\n",
        "        if '.' == inpt:\n",
        "            start = 0\n",
        "            end = len(rng)      \n",
        "        else:\n",
        "            rngs = inpt.split(',')\n",
        "            for rng in rngs:\n",
        "                if '-' in rng:\n",
        "                    rngs = rng.split('-')\n",
        "                    start = int(rngs[0]) - 1\n",
        "                    end = int((rngs[1]))\n",
        "                    items.extend(range(start, end))      \n",
        "                    if end > len(content) or start < 0 :\n",
        "                        print(\"The ranges' ends are out of the directory file range.\")\n",
        "                    continue\n",
        "                else:\n",
        "                    i = int(rng)-1\n",
        "                    items.append(i)\n",
        "  \n",
        "    elif delpath:\n",
        "        info(f'Deleing: {delpath}\\nProcess backup: {process_backup}')\n",
        "        items = [0]\n",
        "    else:\n",
        "        return -1\n",
        "  \n",
        "    if replace:\n",
        "        for i in items:\n",
        "            path = delpath +\"/\"+ content[i] if content else delpath\n",
        "            replace_download(path)\n",
        "            \n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt0 = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Moving to .replace:  {pt0}\")\n",
        "                        info(f\"Moving to .replace:  {pt0}\")\n",
        "                        replace_download(pt0)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt0} doesn't exist.\") \n",
        "  \n",
        "    else:\n",
        "        for i in items:\n",
        "            path = delpath + \"/\" + content[i] if content else delpath\n",
        "            info(f'Deleing path: {path}')\n",
        "            if os.path.exists(path):\n",
        "                rt = !rm -r \"$path\"\n",
        "                if rt:\n",
        "                    error(lines = rt)\n",
        "                    list_lines(rt)\n",
        "            else:\n",
        "                error(f\"{path} doesn't exist.\")\n",
        "                continue\n",
        "            if process_backup and False: #fixbackup\n",
        "                for i in range(1,4):\n",
        "                    pt = \"bk path\"\n",
        "                    if not pt[0] in delpath and os.path.exists(pt[1]):\n",
        "                        pt = pt[1]\n",
        "                        if v:\n",
        "                            print(f\"Deleting path: {pt}\")\n",
        "                        info(f'Deleing file: {pt}')\n",
        "                        rt = !rm -r \"$pt\"\n",
        "                        if rt:\n",
        "                            error(lines = rt)\n",
        "                            list_lines(rt)\n",
        "                    else:\n",
        "                        warning(f\"Backup path: {pt} doesn't exist.\") \n",
        "        return\n",
        "  \n",
        "def is_cp(name):\n",
        "    return True if contains(checkpoint, name) else False\n",
        "\n",
        "def del_cp(path):\n",
        "    p0 = f\"{path}/{checkpoint}\"\n",
        "    if os.path.exists(p0):\n",
        "        !rm -r \"$p0\"\n",
        "\n",
        "def dircontent(path):\n",
        "    del_cp(path)\n",
        "    return os.listdir(path)\n",
        "\n",
        "sizeDiffers = (1,'Size differs')\n",
        "doesntExist = (2,\"Doesn't Exist\")\n",
        "emptySizeLimit = 40000\n",
        "class Sync_Status:\n",
        "    def __init__(self, path, src: int, message = '', name1 = '', name2 = '', size1 = '', size2 = '', status = doesntExist):\n",
        "        self.path = path\n",
        "        self.src = src\n",
        "        self.message = message\n",
        "        self.name1 = name1\n",
        "        self.name2 = name2\n",
        "        self.size1 = size1\n",
        "        self.size2 = size2\n",
        "        self.status = status\n",
        "\n",
        "def compare_dirs(first, second, sync = False, syncNames = False, delEmpty = False):\n",
        "   info(f'Comparing sync status.\\nFirst path: {first}\\nSecond path: {second}')\n",
        "   if first and os.path.exists(first) and second and os.path.exists(second):\n",
        "       del_cp(first)\n",
        "       del_cp(second)\n",
        "       content1 = os.listdir(first)\n",
        "       content2 = os.listdir(second)\n",
        "       content1.sort()\n",
        "       content2.sort()\n",
        "       synced = []\n",
        "       sync_list: list[Sync_Status] = []\n",
        "       emty1 = emty2 = 0\n",
        "       if content1:\n",
        "           ln1 = len(content1)\n",
        "           ln2 = len(content2)\n",
        "           print(\"         {:<74}{:^43} {:^12}{:^12}{:^14}\\n\".format(\"In Dir 1\", \"In Dir 2\", \"Size in 1\",  \"Size in 2\", 'Sync Status'))\n",
        "           for item in content1:\n",
        "               path1 = f\"{first}/{item}\"\n",
        "               path2 = f\"{second}/{item}\"\n",
        "               size1_raw= pathsize(path1)\n",
        "               size1 = data_str(size1_raw)\n",
        "               size2 = \"\"\n",
        "               exists2 = False\n",
        "               status2 = ''\n",
        "               synced_ = 'Synced'\n",
        "               unsynced_ = 'Unsynced'\n",
        "               recheck = ''\n",
        "               if delEmpty and size1_raw <= emptySizeLimit:\n",
        "                   !rm -r \"$path1\"\n",
        "                   ln1 -= 1\n",
        "                   info(f\"Empty directory deleted {path1}\")\n",
        "                   emty1 += 1\n",
        "                   size1 = 0\n",
        "       \n",
        "               if item in content2:        \n",
        "                   exists2 = True \n",
        "                   status2 = \"Exists\"\n",
        "                   content2.remove(item)       \n",
        "               else:\n",
        "                   recheck = research_name(item, content2)\n",
        "                   if recheck:\n",
        "                       exists2 = True\n",
        "                       content2.remove(recheck)\n",
        "                       path2 = f\"{second}/{recheck}\"\n",
        "                       status2 = f'[{recheck}]'\n",
        "                       info(f\"{item} exists as {recheck} in 2.\")\n",
        "       \n",
        "               if exists2:\n",
        "                   size2_raw = pathsize(path2)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       ln2 -= 1\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1            \n",
        "                       continue\n",
        "       \n",
        "                   if recheck and syncNames:\n",
        "                       info(f\"Renaming {recheck} to {item}\")\n",
        "                       p0 = f\"{second}/{recheck}\"\n",
        "                       p1 = f\"{second}/{item}\"\n",
        "                       ot = !mv \"$p0\" \"$p1\"\n",
        "                       if ot:\n",
        "                           error(ot)\n",
        "                       else:\n",
        "                           path2 = p1\n",
        "                           status2 = 'Renamed'\n",
        "                           info(f\"Item {recheck} renamed to {item} in 2.\")\n",
        "       \n",
        "       \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   diff = False if abs(size1_raw - size2_raw) <= 50000 else True\n",
        "                   if not diff:\n",
        "                       msg = \"    {:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, synced_)\n",
        "                       synced.append(msg)\n",
        "                   else: \n",
        "                       s_status = sizeDiffers[1]\n",
        "                       msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status)\n",
        "                       if  size1_raw > size2_raw:\n",
        "                           status = Sync_Status(path= path1, src= 1, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 1: {path1}, size differs in path 2.\")\n",
        "                       else:\n",
        "                           status = Sync_Status(path= path2, src= 2, message= msg, status= sizeDiffers)\n",
        "                           info(f\"An item added to the sync list 2: {path2}, size differs in path 1.\")\n",
        "                       sync_list.append(status)\n",
        "               else:\n",
        "                   if not size1:\n",
        "                       continue\n",
        "                   status2 = ''\n",
        "                   s_status = doesntExist[1]\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(item, status2, size1, size2, s_status )\n",
        "                   status = Sync_Status(path= path1, src= 1, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 1: {path1}, doesn't exist in path 2.\")\n",
        "             \n",
        "           if content2:\n",
        "               for item in content2:                    \n",
        "                   path2 = f'{second}/{item}'\n",
        "                   size2_raw =  pathsize(path2, False)\n",
        "                   if delEmpty and size2_raw <= emptySizeLimit:\n",
        "                       !rm -r \"$path2\"\n",
        "                       info(f\"Empty directory deleted {path2}\")\n",
        "                       emty2 += 1\n",
        "                       ln2 -= 1\n",
        "                       continue          \n",
        "                   size2 = data_str(size2_raw)\n",
        "                   msg = \"{:<80}{:^40}{:>12}{:>12}{:^20}\".format(\"\", item, '', size2, \"Doesn't Exist\")\n",
        "                   status = Sync_Status(path= path2, src= 2, message= msg, status= doesntExist)\n",
        "                   sync_list.append(status)\n",
        "                   info(f\"An item added to the sync list 2: {path2}, doesn't exist in path 1.\")\n",
        "     \n",
        "           for item in synced:\n",
        "               info(item)\n",
        "     \n",
        "           if sync_list:\n",
        "               sync_list.sort(key= lambda obj: obj.status[0])\n",
        "               for i in range(len(sync_list)):\n",
        "                   item = sync_list[i]\n",
        "                   msg = f\"{str(i + 1)+' - ' if sync else '    '}{item.message}\"\n",
        "                   info(item.message)\n",
        "                    \n",
        "           msg = f\"\\nTotal items in path 1: {ln1}   Total items in path 2:  {ln2}   Unsynced items: {len(sync_list)}.\\n\"\n",
        "           msg += f\"{f'Deleted empty folders in path 1:  {emty1}  ' if emty1 else ''}{f'Deleted empty folders in path 2:  {emty2}' if emty2 else ''}\\n\"\n",
        "           info(msg)\n",
        "           \n",
        "           if sync and sync_list:\n",
        "               inp = input().strip().lower()\n",
        "               if (inp == \"q\" or inp.startswith('n')):\n",
        "                   return\n",
        "               rngs = []  \n",
        "               if inp == '.':\n",
        "                   rngs.extend(range(len(sync_list)))\n",
        "               else:\n",
        "                   selects = inp.split(',')\n",
        "                   for select in selects:\n",
        "                       try:          \n",
        "                           if '-' in select:\n",
        "                               splt = select.split('-')\n",
        "                               s = int(splt[0]) - 1\n",
        "                               e = int(splt[1])\n",
        "                               rngs.extend(range(s, e))\n",
        "                           else:\n",
        "                               rngs.append(int(select) - 1)\n",
        "                       except Exception as e:\n",
        "                           error(str(e))\n",
        "                           continue\n",
        "               msg = f\"Syncing {first} with {second}.\\nTotal copying items: {len(rngs)}\"\n",
        "               info(msg)\n",
        "               for i in rngs:\n",
        "                   p0 = sync_list[i].path\n",
        "                   p1 = second if sync_list[i].src == 1 else first\n",
        "                   info(f\"Copying: {os.path.basename(p0)} to {p1}\")\n",
        "                   !rsync --size-only -P -h -r \"$p0\" \"$p1\"\n",
        "   else:\n",
        "       msg = f\"{first} {'exists' if os.path.exists(first) else 'does not exist'}\\n{second} {'exists' if os.path.exists(second) else 'does not exist'}\"\n",
        "       error(msg)\n",
        "\n",
        "def research_name(key, content2):\n",
        "    key = key.strip()\n",
        "    if key:\n",
        "        key = os.path.splitext(key)[0]\n",
        "        keytrans = transstring(key)\n",
        "        ln = len(keytrans)\n",
        "        if ln >= 15:\n",
        "            for i in range(len(content2)):\n",
        "                trans = transstring(os.path.splitext(content2[i])[0])\n",
        "                ln1 = len(trans)\n",
        "                if ln1 < 15:\n",
        "                    continue\n",
        "                if ln1 <= ln:\n",
        "                    n0 = trans  \n",
        "                    n1 = keytrans\n",
        "                else:\n",
        "                    n0 = keytrans\n",
        "                    n1 = trans\n",
        "                if contains(n1, n0):\n",
        "                    return content2[i]\n",
        "    return False\n",
        "\n",
        "def mt(path, bd = None, ad = None, backup = False, prompt = False):\n",
        "    if not (bd or ad): return\n",
        "    info(f'Deleing files dated before {datetime.fromtimestamp(bd).strftime(\"%Y-%m-%d\")} in {path}')\n",
        "    files = next(os.walk(path))[2]\n",
        "    check = bd and ad\n",
        "    filter = []\n",
        "    for file in files:\n",
        "        p0 = os.path.join(path, file)\n",
        "        md = os.path.getmtime(p0)\n",
        "        if (check and md <= bd and md >= ad) or (bd and md <= bd) or (ad and md >= ad):\n",
        "            dstr = datetime.fromtimestamp(md).strftime('%Y-%m-%d')\n",
        "            size = data_str(os.path.getsize(p0))\n",
        "            msg = f'{dstr} - {size} {file}'\n",
        "            info(msg)\n",
        "            print(msg)\n",
        "            if prompt:\n",
        "                filter.append(file)\n",
        "                continue         \n",
        "            info(f\"Deleting {p0}..\")\n",
        "            rm(p0, backup, False)\n",
        "    if prompt:\n",
        "        rm(delpath= path, process_backup= backup, content= filter)\n",
        "\n",
        "def check_sd_base(path):\n",
        "  lookup = sd_pt.search(path)\n",
        "  if lookup:\n",
        "      p0 = lookup.group()  \n",
        "      if os.path.exists(p0):\n",
        "          return p0\n",
        "  return False\n",
        "\n",
        "def makedirs(path, backup = False):\n",
        "    if path:\n",
        "        info(f\"Creating dir: {path}\")\n",
        "        os.makedirs(path, exist_ok=True)\n",
        "\n",
        "def clean_general(Type) :\n",
        "    dirs = next(os.walk(config.general_path))[1]\n",
        "    if checkpoint in dirs: dirs.remove(checkpoint)\n",
        "    for name in dirs:\n",
        "        newname = \"\"\n",
        "        p1 = config.general_path + \"/\" + name\n",
        "        p0 = config.general_path\n",
        "        if not os.path.isdir(p1):\n",
        "            p0 = config.general_path + \"/\" + os.path.splitext(name)[0]\n",
        "            os.makedirs(p0, exist_ok= True)\n",
        "            !mv \"$p1\" \"$p0\"\n",
        "            p1 = p0\n",
        "        if Type == MOVIE:\n",
        "            newname = name_movie(name)\n",
        "            save_path = config.movies_path\n",
        "            after_shave_movie(p1, newname)\n",
        "        elif Type == SHOW:\n",
        "            newname = name_show(name)\n",
        "            clean_tvshow(p1)\n",
        "            save_path = config.tv_path\n",
        "            check = save_path + \"/\" + newname\n",
        "        elif Type == SEASON:\n",
        "            newname = get_season(name)\n",
        "            if not newname:\n",
        "                newname = name\n",
        "            show = name_show(name)\n",
        "            clean_season(p1)\n",
        "            save_path= path_tvshow(show)\n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        elif Type == EPISODE:\n",
        "            newname = name_episode(name)\n",
        "            show = name_show(name)\n",
        "            season= get_season(name)\n",
        "            if not season:\n",
        "                season = name\n",
        "            save_path= path_season(show, season) \n",
        "            os.makedirs(save_path, exist_ok= True)\n",
        "        else:\n",
        "            save_path = config.general_path\n",
        "        if newname:\n",
        "            p2 = config.general_path + \"/\" + newname\n",
        "            !mv \"$p1\" \"$p2\"\n",
        "        else:\n",
        "            p2 = p2 + name\n",
        "        if Type == EPISODE and os.path.isdir(p2):\n",
        "            clean_season(p2)\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\" \n",
        "        if Type == SHOW and os.path.isdir(check):\n",
        "            save_path = check\n",
        "            p02 = p2\n",
        "            p2 = p2 + \"/\"\n",
        "        !mv \"$p2\"* \"$save_path\"\n",
        "        if p02 and os.path.exists(p02): \n",
        "            !rm -r \"$p02\"\n",
        "      \n",
        "def clean_path(type_, path, process_backup = False, keepdot = False, multi = False, delete_empty = False, clean = True):\n",
        "    if multi:\n",
        "        if type_ == MOVIE:\n",
        "            if path :\n",
        "                clean_movies_dir(path, backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "            else:\n",
        "                clean_movies_dir(backup = process_backup, delete_empty = delete_empty, clean = clean)\n",
        "\n",
        "        elif type_ == SHOW:\n",
        "            clean_tvshows()\n",
        "            if process_backup:\n",
        "                for pt in config.tvbackups:\n",
        "                    clean_tvshows(pt)\n",
        "\n",
        "    else:\n",
        "            if type_ == MOVIE:\n",
        "                if path and os.path.exists(path):\n",
        "                    name = os.path.basename(path)\n",
        "                    clean_movie(path, name)\n",
        "                    if process_backup:          \n",
        "                        for dir in config.moviesbackups:\n",
        "                            path = f\"{dir}/{name}\"\n",
        "                            if os.path.exists(path):\n",
        "                                clean_movie(path, name)\n",
        "            elif type_ == SHOW:\n",
        "                if path and os.path.exists(path):\n",
        "                    clean_tvshow(path, keepdot)\n",
        "                    if process_backup:                                  #fixbackup\n",
        "                        for dir in config.tvbackups:\n",
        "                            path = f\"{dir}/{os.path.basename(path)}\"\n",
        "                            if os.path.exists(path):          \n",
        "                                clean_tvshow(path, keepdot)\n",
        "     \n",
        "\n",
        "#### API / Download files utils\n",
        "\n",
        "def move_download_old_files(attrs: DownloadAttrs): #disabled temporarly \n",
        "    info(f'Cleaning distination for: {attrs.save_name}')\n",
        "    attrs.old_files_dirs = set()\n",
        "    delstr = '.replaced-' + nowstr()\n",
        "    if 1 <= attrs.type_/TV < 1.1 :\n",
        "        for diritem in attrs.downloaded_diritems: #diritem is tuple of a dir and its content\n",
        "            season = get_season(diritem[0])\n",
        "            if season:\n",
        "                for filename in diritem[1]:\n",
        "                    lookup1 = episode_exists(attrs.show, season, filename)\n",
        "                    if lookup1:\n",
        "                        oldfilepath = lookup1['foundpath']\n",
        "                        oldfiletemppath = f\"{os.path.dirname(oldfilepath)}/{delstr}\"\n",
        "                        os.makedirs(oldfiletemppath, exist_ok=True)\n",
        "                        info(f'Moving: {oldfilepath} to {oldfiletemppath}')\n",
        "                        cmd = f'mv \"{oldfilepath}\" \"{oldfiletemppath}\"'\n",
        "                        output = !$cmd\n",
        "                        if output:  error(lines = output)\n",
        "                        attrs.old_files_dirs.add(oldfiletemppath)\n",
        "                        info(f'Old files found: {lookup1[\"foundname\"]}')\n",
        "\n",
        "    elif attrs.type_ == MOVIE:\n",
        "        if attrs.existing_path and os.path.isdir(attrs.existing_path):\n",
        "            oldfiletemppath = os.path.normpath(f\"{attrs.existing_path}/{delstr}\")\n",
        "            os.makedirs(oldfiletemppath, exist_ok=True)    \n",
        "            info(f'Moving files in {attrs.existing_path} to {oldfiletemppath}')\n",
        "            cmd = f'mv \"{attrs.existing_path}/\"* \"{oldfiletemppath}\"'\n",
        "            output = !$cmd\n",
        "            if output:  error(lines = output)\n",
        "            attrs.old_files_dirs.add(oldfiletemppath)\n",
        "    info('Cleaning distination done.')\n",
        "    return\n",
        "    cmd\n",
        "\n",
        "def verify_saving_download(attrs: DownloadAttrs):\n",
        "    fails = []\n",
        "    info(f\"Verifying downloaded files for: {DownloadAttrs.save_name}\\nTotal downloaded: {data_str(attrs.total_downloaded)}\")\n",
        "    for i in range(len(attrs.verify_download)):\n",
        "        item = attrs.verify_download[i]\n",
        "        s1 = has_size(item[0], False)\n",
        "        s2 = has_size(item[1], False)\n",
        "        info(f\"Verifying: ({'Does not exist.' if s1 == -1 else s1}) {item[0]}\\n       To: ({'Does not exist.' if s2 == -1 else s2}) {item[1]}\")\n",
        "        if s2 != -1 and abs(s2-s1) <= size_limit:\n",
        "            info('Successfully transfered.')\n",
        "        else:\n",
        "            info('Not transfered.')\n",
        "            fails.append(item[1])\n",
        "    if len(fails) == 0:\n",
        "        info(f\"Successful transfer verification.\")\n",
        "        return True\n",
        "    else:\n",
        "        error(f\"Verification failed.\\nFailed items: {len(fails)}\\n{list_lines(fails, str = True)}\")\n",
        "    return False\n",
        "\n",
        "def revert_download_file_transfer(attrs: DownloadAttrs):\n",
        "    info('Reverting transfered files.')\n",
        "    for replacedpath in attrs.old_files_dirs:\n",
        "        replacedpath = os.path.normpath(replacedpath)\n",
        "        cmd = f'mv \"{replacedpath}/\"* \"{os.path.dirname(replacedpath)}\"'\n",
        "        !$cmd\n",
        "        cmd = f'rm -r \"{replacedpath}\"'\n",
        "        !$cmd \n",
        "    return\n",
        "\n",
        "def prepare_download_file_transfer(attrs: DownloadAttrs, donesavingpath):    # Matches download files with the target pathes for verification \n",
        "    info(f\"Preparing transfer for: {donesavingpath}\\nSave dir: {attrs.target_save_dir}\\nFile transfer verification items:\")\n",
        "    attrs.verify_download = []\n",
        "    total_size = 0 \n",
        "    diritems_str = \"\"\n",
        "    for diritem in attrs.downloaded_diritems:\n",
        "        dirbase = f\"/{diritem[0]}\" if diritem[0] else ''\n",
        "        donedirpath = donesavingpath + dirbase\n",
        "        savingtargetdirpath = attrs.target_save_dir + dirbase\n",
        "        diritems_str += f\"In dir:  {donedirpath}/\\n\"\n",
        "        for filename in diritem[1]:\n",
        "            donefilepath = f\"{donedirpath}/{filename}\"\n",
        "            targetfilepath = f\"{savingtargetdirpath}/{filename}\"\n",
        "            attrs.verify_download.append((donefilepath, targetfilepath))\n",
        "            filesize = pathsize(donefilepath)\n",
        "            sizestr = data_str(filesize)\n",
        "            total_size += filesize\n",
        "            diritems_str += f'{sizestr} {donefilepath}\\n{(len(sizestr) + 1)*\" \"}{targetfilepath}\\n'\n",
        "    info(diritems_str)\n",
        "    attrs.total_downloaded = total_size \n",
        "\n",
        "def transfer_download_files(handle, copy= False):\n",
        "    handle.pause()\n",
        "    attrs: DownloadAttrs = handle.attrs\n",
        "    os.makedirs(attrs.save_path, exist_ok= True)\n",
        "    status = handle.status()\n",
        "    downloadname = status.name\n",
        "    localsavingpath = f'{status.save_path}/{downloadname}'\n",
        "    localsavedpath = status.save_path\n",
        "    donesavingpath = f\"{done_path}/{attrs.save_name}\"\n",
        "    info(f'Transfering files for: {downloadname}\\nNewname: {attrs.save_name}')\n",
        "    if os.path.exists(localsavingpath):\n",
        "        hasnodir = not os.path.isdir(localsavingpath)\n",
        "        if hasnodir: #move all dirless files here. Ensures that localsavingpath is a dir, not dirless file.\n",
        "            info(f'The download doesnt have a directory\\nMoving download files into a directory with the same name.')\n",
        "            localsavedpath = status.save_path + \"/\" + os.path.splitext(downloadname)[0]\n",
        "            os.makedirs(localsavedpath, exist_ok=True)\n",
        "            files = handle.torrent_file().files()\n",
        "            for i in range(files.num_files()):\n",
        "                file_path = status.save_path + \"/\" + files.file_path(i)\n",
        "                if not copy:\n",
        "                    info(f'Moving {file_path} to {localsavedpath}')\n",
        "                    cmd = f'mv \"{file_path}\" \"{localsavedpath}\"'\n",
        "                else:\n",
        "                    info(f'Copying {file_path} to {localsavedpath}')\n",
        "                    cmd = f'cp \"{file_path}\" \"{localsavedpath}\"'\n",
        "                !$cmd \n",
        "            localsavingpath = localsavedpath \n",
        "        shave_download(handle, localsavedpath, localsavingpath)\n",
        "        if not clean_download(attrs, localsavingpath= localsavingpath):\n",
        "            error(\"An error occured during cleaning the download.\")\n",
        "        if (not copy) or hasnodir:\n",
        "            info(f'Moving to done path with the new name\\n {localsavingpath} to {donesavingpath}')\n",
        "            cmd = f'mv \"{localsavingpath}\" \"{donesavingpath}\"'\n",
        "        else:\n",
        "            info(f'Copying to done path with the new name\\n {localsavingpath} to {donesavingpath}')  \n",
        "            cmd = f'cp -r \"{localsavingpath}\" \"{donesavingpath}\"'\n",
        "        !$cmd\n",
        "    else:\n",
        "        error(f\"Download dir or file is missing {localsavingpath} \")\n",
        "        release()\n",
        "    if not attrs.save_name:\n",
        "        attrs.save_name = downloadname\n",
        "        donesavingpath = donesavingpath + attrs.save_name \n",
        "    prepare_download_file_transfer(attrs, donesavingpath)  \n",
        "    if attrs.type_ == EPISODE and os.path.isdir(donesavingpath):\n",
        "        donesavingpath = f'{donesavingpath}/' \n",
        "    if os.path.exists(donesavingpath):\n",
        "        if attrs.existing_mode == REPLACE_DOWNLOAD:\n",
        "            move_download_old_files(attrs) \n",
        "        info(f'Saving {attrs.save_name} to: {attrs.save_path}')\n",
        "        merge_mode = \"--size-only \" if attrs.existing_mode == MERGE_DOWNLOAD else '' # -I for replacing files \n",
        "        cmd = f'rsync {merge_mode}-r \"{donesavingpath}\" \"{attrs.save_path}\"'\n",
        "        output = !$cmd\n",
        "        if output:\n",
        "            error(lines= output)\n",
        "            files_transfer_verification = False\n",
        "        else:\n",
        "            files_transfer_verification = verify_saving_download(attrs)   \n",
        "        if attrs.backup and attrs.baksv:\n",
        "            for bkpath in attrs.baksv:\n",
        "                info(f'Copying {attrs.save_name} to: {bkpath}')\n",
        "                cmd = f'rsync {merge_mode}-r \"{donesavingpath}\" \"{bkpath}\"'\n",
        "                output= !$cmd\n",
        "                if output:\n",
        "                    error(lines= output)\n",
        "        if files_transfer_verification:\n",
        "            info(f'Deleting {donesavingpath}')\n",
        "            cmd = f'rm -r \"{donesavingpath}\"' \n",
        "            !$cmd\n",
        "            if attrs.uncomplete_source and os.path.exists(attrs.uncomplete_source):\n",
        "                info(f'Deleting uncompleted source: {attrs.uncomplete_source}')\n",
        "                cmd = f'rm -r \"{attrs.uncomplete_source}\"'\n",
        "                !$cmd\n",
        "            if attrs.existing_mode == REPLACE_DOWNLOAD: # TODO\n",
        "                #info('Deleting replaced files.')\n",
        "                #for oldfilepath in attrs.old_files: rm(oldfilepath, process_backup= attrs.backup) \n",
        "                pass\n",
        "            info(f'Done saving {attrs.save_name}.')\n",
        "            return True   \n",
        "        else:\n",
        "            print(\"Transfer verification failed.\")\n",
        "            if attrs.existing_mode == REPLACE_DOWNLOAD:\n",
        "                revert_download_file_transfer(attrs)\n",
        "            return False\n",
        "    else:\n",
        "        error(f\"Files for: {attrs.save_name} were not transfered.\")\n",
        "        cmd = ''\n",
        "        if cmd: pass\n",
        "        return False\n",
        "\n",
        "def save_download_progress(handle, savepath):\n",
        "    status = handle.status()\n",
        "    name = status.name\n",
        "    info(f\"Saving download progress for {name}\")\n",
        "    os.makedirs(savepath, exist_ok=True)\n",
        "    p0 = temp_save +\"/\"+ name\n",
        "    p1 = f\"{savepath}/{name}\"\n",
        "    if os.path.exists(p1):\n",
        "        name2 = name + \"@SAVE2\"\n",
        "        p1 = f\"{savepath}/{name2}\"\n",
        "    print(\"\\nSaving {0} into    {1}\\n\".format(name, p1))\n",
        "    !cp -r \"$p0\" \"$p1\"\n",
        "    info(f\"Done saving download progress for {name}.\")\n",
        "\n",
        "def load_uncompleted(path, type_ = MOVIE, local = False):\n",
        "    (path, files, dirs) = next(os.walk(path))\n",
        "    content = filter_checks(dirs) + files\n",
        "    if content:\n",
        "        print(\" Choose a directory or a file to load:\")\n",
        "        for i in range(len(content)):\n",
        "            p00 = f\"{path}/{content[i]}\"\n",
        "            size = pathsize(p00, True)\n",
        "            print(\"   {}- {:<90}{}\".format(i+1, content[i], size))\n",
        "        print()\n",
        "        choice = input().lower()\n",
        "        if \"\" == choice or \" \" == choice or  \"q\" == choice or \"s\" == choice:\n",
        "            return\n",
        "        elif \",\" in choice:\n",
        "            choices = choice.split(\",\")\n",
        "        else:\n",
        "            choices = [choice]\n",
        "        for select in choices:\n",
        "            select = int(select) - 1\n",
        "            if select >= len(content) or select < 0 :\n",
        "                print(\"\\nThe choice is out of range.\\n\")\n",
        "            else:\n",
        "                name = content[select]\n",
        "                if not local:\n",
        "                    p0 = f\"{path}/{name}\"\n",
        "                    if content[select].endswith(\"@SAVE2\"):\n",
        "                        name = content[select].split(\"@SAVE2\")[0]\n",
        "                    p1 = f\"{temp_save}/{name}\"\n",
        "                    info(f\"Loading uncompleted download: {content[select]} to {p1}\")\n",
        "                    print(\"Loading into {}\\n\".format(p1))\n",
        "                    !cp -r \"$p0\" \"$p1\"\n",
        "                    print(\"{0} is Loaded\\n\".format(content[select]))\n",
        "                    info(f\"Uncompleted download: {content[select]} loaded to {p1}\")\n",
        "                attrs = DownloadAttrs(type_= type_, name = name)\n",
        "                r = resume_uncomplete_download(name) \n",
        "                if r == -2:\n",
        "                    break\n",
        "                print(\"\\n   ...................\\n          Done\\n\")\n",
        "    else:\n",
        "        error(\"Uncomplete directory is empty.\")\n",
        "\n",
        "def resume_uncomplete_download(attrs):\n",
        "    info(f\"Resuming download {attrs.name}\")\n",
        "    lookup = name_movie(attrs.name)\n",
        "    print(f\"Downloading: {lookup}\\nSelect a source:\\n 1 - 1337x\\n 2 - rarbg\\n\")\n",
        "    select = input().lower()\n",
        "    if select == \"s\" or select == \"\":\n",
        "        return -1\n",
        "    elif select == \"q\" or select == \" \":\n",
        "        return -2\n",
        "    elif select == \"1\":\n",
        "        attrs.site_source = X1337X\n",
        "        search_process(X1337X, search= lookup,  attrs= attrs)\n",
        "    return 0\n",
        "\n",
        "def pause_resume_session(b= None):\n",
        "    try:\n",
        "        paused = ses.is_paused()\n",
        "        if appstate.running or not paused:\n",
        "            ses.pause()\n",
        "            for i in range(len(active)):\n",
        "                #active[i].progress_bar.bar_style = 'warning'\n",
        "                active[i].control_btn.disabled = True\n",
        "            appstate.running = False\n",
        "            startpause_btn.description = \"Start\"\n",
        "            info(f\"Session has been paused.\")\n",
        "        elif active or paused:\n",
        "            ses.resume()\n",
        "            for i in range(len(active)):\n",
        "                #if not active[i].paused: active[i].progress_bar.bar_style = 'info'\n",
        "                active[i].control_btn.disabled = False\n",
        "            appstate.running = True\n",
        "            startpause_btn.description = \"Pause\"\n",
        "            startmonitor()\n",
        "            info(f\"Session has been resumed.\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while pausing session.', ERROR_EVENT)\n",
        "    release()\n",
        "\n",
        "def pause_start_download(handle, btn):\n",
        "    paused = handle.status().paused\n",
        "    if paused or handle.paused:\n",
        "        with hide:\n",
        "            handle.auto_managed(True)\n",
        "        handle.resume()\n",
        "        handle.paused = False\n",
        "        handle.progress_bar.bar_style = 'info'\n",
        "        btn.description = \"||\"\n",
        "        startmonitor()\n",
        "        info(f\"Download '{handle.name}' has been resumed.\")\n",
        "    else:\n",
        "        with hide:\n",
        "            handle.auto_managed(False)\n",
        "        handle.pause()\n",
        "        handle.paused = True\n",
        "        handle.progress_bar.bar_style = 'warning'\n",
        "        btn.description = \"▷\"\n",
        "        info(f\"Download '{handle.name}' has been paused.\")\n",
        "\n",
        "def remove_download(downloadview):\n",
        "    stopmonitor()\n",
        "    try:\n",
        "        handle = downloadview.handle\n",
        "        remove_active_view(downloadview)        \n",
        "        status = handle.status()\n",
        "        handle.pause()\n",
        "\n",
        "        if handle in active:\n",
        "            active.remove(handle)\n",
        "        elif handle in completed:\n",
        "            completed.remove(handle)\n",
        "        ses.remove_torrent(handle)\n",
        "        del downloads_dict[handle.attrs.hash]\n",
        "\n",
        "        appstate.total_downloads -= 1\n",
        "        appstate.total_wanted -= status.total_wanted\n",
        "        if handle.done:\n",
        "            appstate.completed -= 1\n",
        "            appstate.completed_down -= status.total_wanted_done\n",
        "            appstate.completed_up -= status.total_upload\n",
        "        elif handle.dead:\n",
        "            appstate.deads -= 1\n",
        "\n",
        "        if not active:\n",
        "            update_download_stats_labels()\n",
        "        startmonitor()\n",
        "        info(f'{handle.name} was removed succussfully.')\n",
        "    except Exception as e:\n",
        "        error(f\"An error happened while removing {handle.name}\")\n",
        "        error(ex())\n",
        "        updatestatushtml(\"An error happened while removing download.\", ERROR_EVENT)\n",
        "    release()\n",
        "\n",
        "### UI API\n",
        "\n",
        "class AlreadyDownloadedDecision:\n",
        "    def __init__(self, action, newname = ''):\n",
        "        self.action = action\n",
        "        self.newname = newname\n",
        "    action = None\n",
        "    newname = None\n",
        "\n",
        "gethtmltitle = lambda text, titlenumber, style=\"\": f'<h{titlenumber} style=\"{style}; font-family: {FONTFAMILY_GLOBAL}\">{text}</h{titlenumber}>'\n",
        "\n",
        "def hideview(obj):\n",
        "    obj.layout.display = 'none'\n",
        "    u(obj)\n",
        "\n",
        "def showview(obj):\n",
        "    obj.layout.display = 'flex'\n",
        "\n",
        "def setviewelements(tab, container, initialview, backbtn, navtab):\n",
        "    tab.maincontainer = container\n",
        "    container.tabname = tab.name\n",
        "    container.back_button = backbtn\n",
        "    container.viewstack = [initialview]\n",
        "    backbtn.on_click(lambda b: switchview(container))\n",
        "    nav[navtab] = container\n",
        "\n",
        "def switchview(container, nextview= None, temp= False, allowback= True, remove_on_tab_change= False, expires= 0):\n",
        "    try:\n",
        "        if container == None:\n",
        "            error(\"The sent container is None.\")\n",
        "            release()\n",
        "            return\n",
        "        \n",
        "        if hasattr(container, 'viewstack'):\n",
        "            if nextview: \n",
        "                info(f\"Switched view in container: {container.tabname.lower()}. Next view {nextview.name}.\")\n",
        "                if temp:\n",
        "                    nextview.temp = True\n",
        "                else:\n",
        "                    nextview.temp = False\n",
        "                    container.viewstack.append(nextview)\n",
        "                container.children = (nextview,)\n",
        "\n",
        "                if allowback:\n",
        "                    container.back_button.disabled = False\n",
        "                else:\n",
        "                    container.back_button.disabled = True\n",
        "                if remove_on_tab_change:\n",
        "                    appstate.navactions.append((switchview, (container,)))\n",
        "\n",
        "            elif len(container.viewstack) >= 1:\n",
        "                info(f\"Switched view in container: {container.tabname.lower()} to back.\")\n",
        "                if len(container.viewstack) > 1 and not container.children[0].temp:\n",
        "                    container.viewstack.pop(-1)\n",
        "                    \n",
        "                container.children = (container.viewstack[-1],)\n",
        "                if len(container.viewstack) == 1:\n",
        "                    container.back_button.disabled = True\n",
        "        else:\n",
        "            error(\"The container viewstack is undefined\")\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "\n",
        "def already_downloaded_handler(userdecision: AlreadyDownloadedDecision, attrs: DownloadAttrs):\n",
        "    try:\n",
        "        if userdecision.action == CANCEL_DOWNLOAD:\n",
        "            switchview(nav[ADD_TAB])\n",
        "            return False\n",
        "        if userdecision.action == RENAME_DOWNLOAD and userdecision.newname: \n",
        "            attrs.save_name = userdecision.newname\n",
        "        attrs.existing_mode = userdecision.action\n",
        "        switchview(nav[ADD_TAB], getloadingview(f'Adding download with {attrs.add_source}'), temp= True)\n",
        "        process_adddownload_result(add_download(attrs))\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "def validateconfig():\n",
        "    return True\n",
        "\n",
        "def saveuploadedfiles():\n",
        "    os.makedirs('uploadedfiles', exist_ok= True)\n",
        "    files= set()\n",
        "    try:\n",
        "        for filename in addsource_file.value:\n",
        "            content= addsource_file.value[filename]['content']\n",
        "            filepath= f'/content/uploadedfiles/{filename}'\n",
        "            with open(filepath, 'wb') as savefile:\n",
        "                savefile.write(content)\n",
        "                files.add(filepath)\n",
        "    except Exception as e:\n",
        "        error(e)\n",
        "        print(e)\n",
        "    return files\n",
        "\n",
        "def selectallfiles(files: list[DownloadFile]):\n",
        "    doselect = False\n",
        "    for file in files:\n",
        "        if not file.selected:\n",
        "            doselect = True\n",
        "            break\n",
        "    if doselect:\n",
        "        for file in files: file.selected = True\n",
        "    else:\n",
        "        for file in files: file.selected = False\n",
        "\n",
        "def getfileselectionwithstr(files: list[DownloadFile], selectionstr = \"\"):\n",
        "    if not selectionstr:    return False\n",
        "    includefiles = set()\n",
        "    excludefiles = set()\n",
        "    seasonintervals = set()\n",
        "    if ',' in selectionstr:\n",
        "        inputs = selectionstr.split(',')\n",
        "    else:\n",
        "        inputs = [selectionstr]   \n",
        "    try:\n",
        "        for inputitem in inputs:\n",
        "            inputitem = inputitem.strip()\n",
        "            if inputitem:\n",
        "                if inputitem[0].lower() == 's':\n",
        "                    lookup = season_pt0.search(inputitem)\n",
        "                    if lookup:\n",
        "                        if '-' in inputitem:\n",
        "                            inputrange = inputitem.split('-')\n",
        "                            lookup1 = season_number_pt.search(inputrange[0])\n",
        "                            start = lookup1.group() if lookup1 else ''\n",
        "                            lookup1 = season_number_pt.search(inputrange[1])\n",
        "                            end = lookup1.group() if lookup1 else ''\n",
        "                            if not (start or end): continue\n",
        "                            elif start and end:\n",
        "                                seasonintervals.update({f'({addseason:02})' for addseason in range(int(start), int(end)+1)})\n",
        "                            else:\n",
        "                                addseason = int(end) if end else int(start)\n",
        "                                seasonintervals.add(f\"({addseason:02})\")\n",
        "                        else:\n",
        "                            lookup1 = season_number_pt.search(inputitem)\n",
        "                            if lookup1: seasonintervals.add(f\"({int(lookup1.group()):02})\")                \n",
        "\n",
        "                elif inputitem.lower().startswith('n:'):\n",
        "                    inputitem = inputitem[2:]\n",
        "                    if '-' in inputitem:\n",
        "                        inputrange = inputitem.split('-')\n",
        "                        excludefiles.update(set(range(int(inputrange[0])-1, int(inputrange[1]))))\n",
        "                    else:   excludefiles.add(int(inputitem)-1)\n",
        "\n",
        "                else:\n",
        "                    if '-' in inputitem :\n",
        "                        inputrange = inputitem.split('-')\n",
        "                        includefiles.update(set(range(int(inputrange[0])-1, int(inputrange[1]))))          \n",
        "                    else:   includefiles.add(int(inputitem)-1)\n",
        "    except:     error(ex())\n",
        " \n",
        "    seasonselectionstr_pt =  re.compile(r\"\\b\" + f\"[Ss]({'|'.join(seasonintervals)})\" + r\"(?=[Ee]|\\s|\\.)\") if seasonintervals else None\n",
        "    includes = len(includefiles) >= 1 or bool(seasonselectionstr_pt)\n",
        "    excludes = len(excludefiles) >= 1 \n",
        "    info(f\"Selecting files: Seasons {seasonintervals}, Include {includefiles}, Exclude {excludefiles}\")\n",
        "    for file in files:\n",
        "        inputitem = file.index\n",
        "        if excludes and (inputitem in excludefiles):\n",
        "            file.selected = False\n",
        "        elif includes:\n",
        "            if (seasonselectionstr_pt and seasonselectionstr_pt.search(seasonselectionstr_pt, file.name)) or (inputitem in includefiles):\n",
        "                file.selected = True\n",
        "            else:   file.selected = False\n",
        "    release()\n",
        "\n",
        "def process_adddownload_result(result):\n",
        "    if result.status == ADDPENDING or result.awaiting_decision :\n",
        "        return\n",
        "    try:     \n",
        "        propertiesview =  VBox(layout= downloadproperties_layout)\n",
        "        propertiesview.add_class('curved-40')\n",
        "        propertiesview.name = \"Download Properties.\"\n",
        "        resultview = getaddinfosubview(result)\n",
        "        if result.status == ADDSUCCUSS: \n",
        "            info('Getting result view and files.')\n",
        "            propertiesview.titleview = resultview.titleview\n",
        "            result.handle.propertiesview = propertiesview\n",
        "            propertiesview.children = (resultview, getfileselectionsubview(result))\n",
        "            appstate.total_downloads += 1\n",
        "            status = result.handle.status()\n",
        "            if status.total_wanted_done < 50000:\n",
        "                info(f\"Dead download: {result.handle.name}\")\n",
        "                appstate.deads += 1\n",
        "                result.handle.dead = True\n",
        "            else:\n",
        "                info(f\"Live download: {result.handle.name}\")\n",
        "                result.handle.dead = False\n",
        "            if result.hasmetadata:\n",
        "                setfilesandsizeinfoview(result)\n",
        "                setwantedbytes(result.handle)\n",
        "            else:\n",
        "                appstate.metacheckerthread = Thread(target= metadata_watcher, args= (result,))\n",
        "                appstate.metacheckerthread.start()\n",
        "\n",
        "            info('Launching view')  \n",
        "            create_active_download_view(result.handle)\n",
        "            active.append(result.handle)\n",
        "            if not appstate.monitoralive or not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
        "                if ses.is_paused():\n",
        "                    info(\"Resuming session\") \n",
        "                    ses.resume()\n",
        "                info(\"Launching monitor\")\n",
        "                startmonitor()\n",
        "            updatestatushtml(result.succussmessage, SUCCUSS)\n",
        "        else:\n",
        "            propertiesview.children = (resultview,)\n",
        "        switchview(nav[ADD_TAB], propertiesview, remove_on_tab_change= True)\n",
        "        release()\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while adding Download.', ERROR_EVENT)\n",
        "        release()\n",
        "\n",
        "def saveconfighandler(button):\n",
        "    switchview(config_vbox.maincontainer, getloadingview(f'Setting up requirments'), temp= True, allowback= False)\n",
        "    config.activedownloads = configview1r1v1activedownload_numeric.value\n",
        "    config.ftpenabled = configview1r1v2ftptoggle_checkbox.value\n",
        "    if config.ftpenabled:\n",
        "        config.ftphost = configview1r1v3ftphost_text.value \n",
        "        config.ftpuser = configview1r1v3ftpuser_text.value \n",
        "        config.ftppassword = configview1r1v3ftppass_text.value \n",
        "    if config.gdriveenabled and IS_ENV_COLAB :\n",
        "        storageandpathes()\n",
        "    \n",
        "    config.localdownloadbase = configview1r2v1localbase_text.value.strip()\n",
        "    config.remotedownloadbase = configview1r2v1remotebase_text.value.strip()\n",
        "\n",
        "    config.general_path = configview1r2v2generallib_text.value.strip()\n",
        "    config.movies_path = configview1r2v3movielib_text.value.strip()\n",
        "    config.tv_path = configview1r2v3tvlib_text.value.strip()\n",
        "    config.music_path = configview1r2v2musiclib_text.value.strip()\n",
        "    \n",
        "    bkgeneral = configview1r3v2bkgenerallib_text.value.strip()\n",
        "    if bkgeneral: config.generalbackups.add(bkgeneral)\n",
        "\n",
        "    bkmovie = configview1r3v3bkmovielib_text.value.strip()\n",
        "    if bkmovie: config.moviesbackups.add(bkmovie)\n",
        "\n",
        "    bktv = configview1r3v3bktvlib_text.value.strip()\n",
        "    if bktv: config.tvbackups.add(bktv)\n",
        "\n",
        "    bkmusic = configview1r3v2bkmusiclib_text.value.strip()\n",
        "    if bkmusic: config.musicbackups.add(bkmusic)\n",
        "    \n",
        "    if validateconfig():\n",
        "        configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved.\", fontsize='14px', style= saveconfstyle) \n",
        "    switchview(config_vbox.maincontainer)\n",
        "\n",
        "def saveconffilehandler(button):\n",
        "    configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration saved to file.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "def loadconffilehandler(button):\n",
        "    configview1r5saveconfoutput_html.value = gethtmltext(\"Configuration loaded.\", fontsize='14px', style= saveconfstyle) \n",
        "\n",
        "def search_process(site, search, attrs, category= '', sort= SEEDERSSORT, order= DESCORDER, page= 1, source= SEARCH_TAB):\n",
        "    info(f\"Searching for {search} in sites {', '.join(site)}\")\n",
        "    category = getsitecategory(category, site)\n",
        "    if site == X1337X:\n",
        "        result = search1337x(search, sort= sort, order= order, category= category, page= page, attrs= attrs)\n",
        "    if result:\n",
        "        searchresultview = getsearchresultview(result)\n",
        "        viewstatus = False if source == SEARCH_TAB else True\n",
        "        switchview(nav[SEARCH_TAB], searchresultview, temp= viewstatus)\n",
        "\n",
        "# Add handlers\n",
        "\n",
        "def addsource_change(obj):\n",
        "    newval = addsourcetype_dropdown.value\n",
        "    if newval == UPLOADFILE_ADDSOURCE:\n",
        "        addsource_text.layout.display = \"none\"\n",
        "        addsource_file.layout.display = \"flex\"\n",
        "        addsourcefile_labelhbox.layout.display = \"flex\"\n",
        "        return\n",
        "    if addsource_text.layout.display == \"none\":\n",
        "        addsource_text.layout.display = \"flex\"\n",
        "        addsource_file.layout.display = \"none\"\n",
        "        addsourcefile_labelhbox.layout.display = \"none\"\n",
        "    if newval == MAGNET_ADDSOURCE:\n",
        "        addsource_text.description = \"Download magnet\"\n",
        "    elif newval == HASH_ADDSOURCE:\n",
        "        addsource_text.description = \"Download hash\"\n",
        "    elif newval == LOCALFILE_ADDSOURCE:\n",
        "        addsource_text.description = \"Local file path\"\n",
        "    elif newval == FILEURL_ADDSOURCE:\n",
        "        addsource_text.description = \"Download file URL\"\n",
        "\n",
        "def addinput_change(val):\n",
        "    if len(addsource_text.value.strip()) > 0:\n",
        "        if addadd_button.disabled:\n",
        "            addadd_button.disabled = False\n",
        "    else:\n",
        "        if not addadd_button.disabled:\n",
        "            addadd_button.disabled = True\n",
        "\n",
        "def addfile_change(val):\n",
        "    addadd_button.disabled = False\n",
        "\n",
        "def adddownload_handler(obj): \n",
        "    addsource = addsourcetype_dropdown.value\n",
        "    switchview(nav[ADD_TAB], getloadingview(f'Adding download with {addsource}'), temp= True)\n",
        "    input_ = addsource_text.value\n",
        "    type_ = addtype_dropdown.value\n",
        "    backup = addbackup_checkbox.value\n",
        "    \n",
        "    replace = addreplace_checkbox.value\n",
        "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
        "    customname = addcustomname_text.value\n",
        "    attrs = DownloadAttrs(type_= type_, existing_mode= existing_mode, backup= backup, save_name= customname)\n",
        "    try:    \n",
        "        if addsource == LOCALFILE_ADDSOURCE:\n",
        "            result: AddResult = add_local_files(path= input_, attrs=  attrs)\n",
        "        elif addsource == UPLOADFILE_ADDSOURCE:\n",
        "            if addsource_file.value:\n",
        "                files= saveuploadedfiles()\n",
        "                if files:\n",
        "                    result: AddResult = add_local_files(files= files, attrs= attrs)\n",
        "                else:\n",
        "                    return 0\n",
        "            else:\n",
        "                return\n",
        "        elif addsource == HASH_ADDSOURCE and input_:\n",
        "            result: AddResult = add_hash_download(hash= input_, attrs= attrs)\n",
        "        elif addsource == MAGNET_ADDSOURCE and input_:\n",
        "            attrs.magnet = input_\n",
        "            attrs.add_source = addsource\n",
        "            result: AddResult = add_download(attrs)  \n",
        "    except Exception as e:\n",
        "        error(ex())     \n",
        "    if not result.awaiting_decision:\n",
        "            process_adddownload_result(result)\n",
        "\n",
        "def search_handler(obj):\n",
        "    type_ = searchtype_dropdown.value \n",
        "    site = searchsite_dropdown.value \n",
        "    search = searchsearch_text.value.strip()\n",
        "    switchview(nav[SEARCH_TAB], getloadingview(f'Search for {types[type_]} \"{search}\" site: {site} page: 1.'), temp= True)\n",
        "    category = searchcategory_dropdown.value \n",
        "    sort = searchsort_dropdown.value  \n",
        "    order = searchorder_dropdown.value\n",
        "    saveas = searchsaveas_text.value\n",
        "    replace = searchreplace_checkbox.value \n",
        "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
        "    attrs = DownloadAttrs(type_= type_, save_name= saveas, existing_mode= existing_mode)\n",
        "    if search:\n",
        "        search_process(site= site, search= search, attrs= attrs, category= category, sort= sort, order= order)\n",
        "\n",
        "def imdb_handler(btn):   \n",
        "    switchview(nav[IMDB_TAB], getloadingview(f'Processing IMDB advanced search page: 1.'), temp= True)\n",
        "    type_ = imdbtype_dropdown.value \n",
        "    keyword = imdbkeyword_text.value \n",
        "    maxrating = imdbmaxrating_float.value \n",
        "    minrating = imdbminrating_float.value \n",
        "    minvotes = imdbminvotes_int.value\n",
        "    maxvotes = imdbmaxvotes_int.value\n",
        "    minruntime = imdbminruntime_int.value\n",
        "    maxruntime = imdbmaxruntime_int.value\n",
        "\n",
        "    if imdbstartdate_date.value: startdate = str(imdbstartdate_date.value.strftime(\"%Y-%m-%d\"))  \n",
        "    else: startdate =''\n",
        "    if imdbenddate_date.value: enddate = str(imdbenddate_date.value.strftime(\"%Y-%m-%d\")) \n",
        "    else: enddate =  ''\n",
        "    \n",
        "    inlists = imdbinlist_text.value\n",
        "    notinlists = imdbnotinlist_text.value\n",
        "    imdbsort = imdbsort_dropdown.value\n",
        "    imdborder = imdborder_dropdown.value\n",
        "    top250 = imdbtop250_checkbox.value \n",
        "    top1000 = imdbtop1000_checkbox.value  \n",
        "    oscarwinner = imdboscarwinner_checkbox.value \n",
        "    bestpicturewinner = imdbbestpicturewinner_checkbox.value \n",
        "    bestdirectorwinner = imdbbestdirectorwinner_checkbox.value\n",
        "    englishonly = imdbenglishonly_checkbox.value\n",
        "    animationtitles = imdbanimationtitles_checkbox.value\n",
        "    internationaltitles = imdbinternationaltitles_checkbox.value \n",
        "    indianmovies = imdbindiantitles_checkbox.value \n",
        "    filterdownloaded = imdbfilterdownloadded_checkbox.value\n",
        "    filterwatched = imdbfilterwatched_checkbox.value \n",
        "    \n",
        "    sites = [X1337X]\n",
        "    sitecategory = getsitecategory(type_category[type_], sites[0])\n",
        "    searchparameters = imdbsearchparams_text.value\n",
        "    replace = imdbreplaceoldfiles_checkbox.value \n",
        "\n",
        "    if type_ == MOVIE:\n",
        "        title_type = IMDB_MOVIE_TITLE\n",
        "    elif type_ == TV:\n",
        "        title_type = IMDB_TV_TITLE\n",
        "    else:\n",
        "        title_type = IMDB_ANY_TITLE\n",
        "    existing_mode = REPLACE_DOWNLOAD if replace else MERGE_DOWNLOAD\n",
        "\n",
        "    attrs = DownloadAttrs(type_= type_, existing_mode= existing_mode,)\n",
        "    params = IMDBParams(keyword = keyword, titletype= title_type, startdate= startdate, enddate= enddate, minrating= minrating,\n",
        "                    maxrating= maxrating, minvotes= minvotes, maxvotes= maxvotes, minruntime= minruntime, maxruntime= maxruntime,\n",
        "                    inlists= inlists, notinlists= notinlists, imdbsort=  imdbsort, imdborder= imdborder, filterwatched = filterwatched,\n",
        "                    filterdownloaded = filterdownloaded, top250= top250, top1000= top1000, oscarwinner= oscarwinner,\n",
        "                    bestpicturewinner= bestpicturewinner, bestdirectorwinner= bestdirectorwinner, englishonly= englishonly,\n",
        "                    animationtitles= animationtitles, internationaltitles= internationaltitles, indianmovies= indianmovies,\n",
        "                    sites= sites, sitecategory= sitecategory, siteparameters= searchparameters,\n",
        "                    attrs= attrs)\n",
        "    result: IMDBResult = searchIMDB(params)\n",
        "    imdbresultview = getsearchresultview(result)\n",
        "    switchview(nav[IMDB_TAB], imdbresultview)\n",
        "\n",
        "### Monitor\n",
        "\n",
        "monitoractivedownload_views = []\n",
        "monitorcompleted_views = []\n",
        "\n",
        "#stat = get_completed_stats() completed_down = stat[0] completed_up = stat[1] update_download_stats_labels(completed_down, completed_up)\n",
        "\n",
        "def get_eta(status):\n",
        "    remaining_bytes = status.total_wanted - status.total_wanted_done\n",
        "    if remaining_bytes >= 0 and status.download_rate > 0:\n",
        "        eta_sec = remaining_bytes/status.download_rate \n",
        "        eta_sec = eta_sec + 1.5 if remaining_bytes else 0\n",
        "        return f\"Estimated: {time_str(eta_sec)}\"\n",
        "    return \"\"\n",
        "\n",
        "def update_download_view(status, handle):\n",
        "    downloadvbox = handle.view\n",
        "    totalupload = status.all_time_upload\n",
        "    if totalupload == 0:\n",
        "        totalupload = status.total_upload \n",
        "    if handle.done or handle.transfering:\n",
        "        downloadvbox.progress_bar.value = 100\n",
        "        downloadvbox.progress_label.value = \"100%\"\n",
        "        downloadvbox.control_btn.description = \"▷\"        \n",
        "        if handle.transfering:\n",
        "            downloadvbox.progress_bar.bar_style = 'warning'\n",
        "            downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(0)}{whitespace3}↑ {speed_str(0)}\"\n",
        "            downloadvbox.transfer_label = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted)}{whitespace3}↑ {data_str(totalupload)}\" \n",
        "            downloadvbox.status_label.value = \"Transfering files\"\n",
        "            downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(0)} / {data_str(status.total_wanted)}\"\n",
        "            downloadvbox.eta_label.value = f\"Estimated {time_str(0)}\"\n",
        "            downloadvbox.remove_btn.disabled = True\n",
        "        elif handle.done:\n",
        "            downloadvbox.progress_bar.bar_style = 'success'\n",
        "            downloadvbox.speed_label.value = f\"Completed at {whitespace3}{time.strftime('%I:%M:%S %p', time.localtime(status.completed_time))}\"\n",
        "            downloadvbox.transfer_label = \"Total time:{}{:.2f} m\".format(whitespace3, status.active_time/60)\n",
        "            downloadvbox.status_label.value = \"Completed\"\n",
        "            downloadvbox.remaining_label.value = f\"Downloaded {whitespace3}{data_str(status.total_wanted)} / {data_str(status.total_wanted)}\"\n",
        "            downloadvbox.eta_label.value = f\"Uploaded {whitespace3}{data_str(totalupload)}\"\n",
        "            downloadvbox.remove_btn.disabled = False\n",
        "    else:\n",
        "        if handle.paused:\n",
        "            downloadvbox.status_label.value = 'Paused'\n",
        "            downloadvbox.control_btn.description = \"▷\"\n",
        "            downloadvbox.progress_bar.bar_style = 'warning'\n",
        "        else:\n",
        "            downloadvbox.status_label.value = downloadmonitorstatestrings[status.state]\n",
        "            downloadvbox.control_btn.description = \"||\"\n",
        "            downloadvbox.progress_bar.bar_style = 'info'\n",
        "        downloadvbox.progress_bar.value = status.progress*100\n",
        "        downloadvbox.progress_label.value = \"{:.2f}%\".format(status.progress*100)\n",
        "        downloadvbox.speed_label.value = f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\"\n",
        "        downloadvbox.transfer_label.value = f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(totalupload)}\"\n",
        "        downloadvbox.remaining_label.value = f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\"\n",
        "        downloadvbox.eta_label.value = get_eta(status)\n",
        "\n",
        "def u(widget):\n",
        "    widget.notify_change({'name': 'value', 'type':'update'}) \n",
        "\n",
        "def update_download_stats_labels(active_downloaded= 0, active_uploaded= 0):\n",
        "    active_downloaded += appstate.completed_down\n",
        "    active_uploaded += appstate.completed_up\n",
        "    if appstate.total_wanted == 0:\n",
        "        appstate.total_progress = 0\n",
        "    else:\n",
        "        appstate.total_progress = (100*active_downloaded) / appstate.total_wanted \n",
        "    mointorview1completed_label.value = f\"Completed: {appstate.completed}\"\n",
        "    mointorview1active_label.value = f\"Active: {len(active) - appstate.deads - appstate.transferings}\"\n",
        "    mointorview1dead_label.value = f\"Dead: {appstate.deads}\"\n",
        "    mointorview1totaldownload_label.value = f\"Session download:  {data_str(active_downloaded)} / {data_str(appstate.total_wanted)}\"\n",
        "    mointorview1totalprogress_label.value = f\"{whitespace4}{round(appstate.total_progress,2)}%\"\n",
        "    mointorview1totalupload_label.value = f\"Session upload:  {data_str(active_uploaded)}\"\n",
        "\n",
        "def remove_active_view(view):\n",
        "    hideview(view)\n",
        "    if view in monitoractivedownload_views:\n",
        "        monitoractivedownload_views.remove(view)\n",
        "    elif view in monitorcompleted_views:\n",
        "        monitorcompleted_views.remove(view)\n",
        "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "\n",
        "def complete_active_view(view):\n",
        "    monitorcompleted_views.append(view)\n",
        "    monitoractivedownload_views.remove(view)\n",
        "    monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "\n",
        "def setwantedbytes(handle):\n",
        "    status = handle.status() \n",
        "    appstate.total_wanted += status.total_wanted\n",
        "    handle.progress = status.progress\n",
        "\n",
        "def create_active_download_view(handle):\n",
        "    info(f\"Creating active download view for {handle.name}\")\n",
        "    if startpause_btn.disabled:\n",
        "        startpause_btn.disabled = False  \n",
        "        startpause_btn.description = \"Pause\"\n",
        "    appstate.running = True\n",
        "    handle.transfering = False\n",
        "    handle.paused = False\n",
        "    handle.done = False\n",
        "    get_download_view(handle)\n",
        "    monitordownloadscontainer_vbox.children = monitoractivedownload_views\n",
        "    info(f\"Active download view created for {handle.name}\")\n",
        "\n",
        "def process_completed_download(handle, status):\n",
        "    try:\n",
        "        info(f'{handle.name} finished downloading.')\n",
        "        clicktask(updatestatushtml, (f\"Saving {handle.attrs.save_name} to: {handle.attrs.save_path}\", INFO_EVENT, True, False))\n",
        "        appstate.transferings += 1\n",
        "        handle.transfering = True\n",
        "        transfer_download_files(handle, copy= False)\n",
        "        handle.done = True\n",
        "        handle.transfering = False\n",
        "        appstate.transferings -= 1\n",
        "        stopmonitor()\n",
        "        clicktask(update_download_view, (status, handle))  \n",
        "        clicktask(complete_active_view, (handle.view,))\n",
        "        clicktask(update_download_stats_labels)\n",
        "        clicktask(updatestatushtml)\n",
        "        active.remove(handle)\n",
        "        completed.append(handle)\n",
        "        startmonitor()\n",
        "        handle.done = True\n",
        "        handle.pause()\n",
        "        if len(active) == 0:\n",
        "            appstate.running = False\n",
        "    except Exception:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "def sort_download_views():\n",
        "    monitoractivedownload_views.sort(key = lambda obj: obj.handle.progress, reverse= True)\n",
        "    sortchanged = False\n",
        "    for i, view in enumerate(monitoractivedownload_views):\n",
        "        if view.index != i:\n",
        "            sortchanged = True\n",
        "            break\n",
        "    if sortchanged:\n",
        "        monitordownloadscontainer_vbox.children = tuple(monitorcompleted_views + monitoractivedownload_views)\n",
        "    \n",
        "def monitoractivedownloads():\n",
        "    appstate.monitoralive = True\n",
        "    info('Monitor thread has started.')\n",
        "    try:\n",
        "        sleeptime = 0.4\n",
        "        while appstate.monitoralive and active:\n",
        "            if ses.is_paused(): \n",
        "                info(\"session is paused.\")\n",
        "                appstate.monitoralive = False\n",
        "                release()\n",
        "                break            \n",
        "            clicktask(sort_download_views, wait= .2)\n",
        "            active_down = active_up = 0\n",
        "            for index in range(len(monitoractivedownload_views)):\n",
        "                handle = monitoractivedownload_views[index].handle\n",
        "                handle.view.index = index\n",
        "                if not handle.transfering:\n",
        "                    status = handle.status()\n",
        "                    downloadedbytes = status.total_wanted_done\n",
        "                    wantedbytes = status.total_wanted\n",
        "                    uploadedbytes = status.total_upload\n",
        "                    handle.progress = status.progress\n",
        "                    if handle.dead and downloadedbytes > 50000:\n",
        "                        appstate.deads -= 1\n",
        "                        handle.dead = False\n",
        "                        info(f\"Download is live: {handle.name}\")\n",
        "                    clicktask(update_download_view, (status, handle))\n",
        "                    if status.is_finished or (wantedbytes > 10000 and downloadedbytes == wantedbytes):\n",
        "                        info(f\"{handle.name} finished downloading\")\n",
        "                        appstate.completed += 1\n",
        "                        appstate.completed_down += downloadedbytes\n",
        "                        appstate.completed_up += uploadedbytes\n",
        "                        appstate.transferthread = Thread(target= process_completed_download, args= (handle, status))\n",
        "                        appstate.transferthread.start()\n",
        "                        if len(active) == 1:\n",
        "                            appstate.monitoralive = False\n",
        "                        break \n",
        "                    else:\n",
        "                        active_down += downloadedbytes\n",
        "                        active_up += uploadedbytes\n",
        "            clicktask(update_download_stats_labels, (active_down, active_up))\n",
        "            release()\n",
        "            if appstate.monitoralive:\n",
        "                time.sleep(sleeptime)\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend in download monitor.', ERROR_EVENT)\n",
        "    info('Monitor thread has ended.')\n",
        "    release()\n",
        "\n",
        "def startmonitor():\n",
        "    if not appstate.monitorthread or not appstate.monitorthread.is_alive():\n",
        "        appstate.monitorthread = Thread(target= monitoractivedownloads)\n",
        "        appstate.monitorthread.start()\n",
        "\n",
        "def stopmonitor():\n",
        "    appstate.monitoralive= False\n",
        "    while appstate.monitorthread.is_alive():\n",
        "        time.sleep(.01)\n",
        "\n",
        "### UI    \n",
        "### general style\n",
        "\n",
        "css_html = HTML(\"\"\"\n",
        "    <style>\n",
        "        input, .progress-bar {\n",
        "            border-radius: 5px;\n",
        "        }\n",
        "        .progress-bar-info {\n",
        "            background-color: #02afc5;\n",
        "            animation: info-progress 2s infinite;\n",
        "            box-shadow: 1px 1px 6px 3px rgb(3 182 204 / 30%);\n",
        "        }\n",
        "        .progress-bar-info::before{\n",
        "            content: '';\n",
        "            position: absolute;\n",
        "            border-radius: 8px;\n",
        "            background: radial-gradient(circle, rgba(6,215,241,0.45) 0%, rgba(6,215,241,0.25) 50%, rgba(6,215,241,0) 100%);\n",
        "            width:50%;\n",
        "            height: 80%;\n",
        "            left: -10%;\n",
        "            animation: info-overlay 4s infinite;\n",
        "        }\n",
        "        .progress-bar-warning {\n",
        "            background: #ff9800;\n",
        "                animation: warning-progress 2s infinite;\n",
        "            box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "        } \n",
        "        .progress-bar-success {\n",
        "            box-shadow: 1px 1px 8px 2px rgb(76 175 80 / 50%) ;\n",
        "        }   \n",
        "        .widget-box, .widget-hbox, .widget-vbox, .widget-tab-content {\n",
        "            transition: .3s;\n",
        "            overflow-x: hidden !important; \n",
        "        }\n",
        "        .curved-40, .widget-tab-content {\n",
        "            border-radius: 40px !important;\n",
        "        }\n",
        "        .curved-20 {\n",
        "            border-radius: 20px !important;\n",
        "        }\n",
        "        .jupyter-widgets.widget-tab > .widget-tab-contents  {\n",
        "            border: none !important;\n",
        "        }\n",
        "        .lm-Widget.p-Widget.lm-TabBar.p-TabBar.p-TabPanel-tabBar.widget-tab-bar {\n",
        "            padding-left: 150px !important;\n",
        "        }\n",
        "        .widget-label.label-flex {\n",
        "            display: flex;\n",
        "        }\n",
        "        label.widget-label-basic {\n",
        "            display: flex;\n",
        "            justify-content: center;\n",
        "        }\n",
        "        .jupyter-button{\n",
        "            border-radius: 6px !important;\n",
        "            transition: .4s;\n",
        "            background-color: #a9a9a93b;\n",
        "            border: 1px solid #c2c2c2a8;\n",
        "        }\n",
        "        .jupyter-button:hover:enabled, .jupyter-button:focus:enabled {\n",
        "            box-shadow: 0px 0px 5px 1px rgb(28 142 133 / 36%) !important;\n",
        "        }\n",
        "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab {\n",
        "            border-radius: 3px;\n",
        "            border: none;\n",
        "            color: black !important;\n",
        "            text-align: center;\n",
        "            font-size: 15px;\n",
        "            padding: 10px;\n",
        "            margin: 0 50px 0 0;\n",
        "        }  \n",
        "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab.p-mod-current {\n",
        "            margin-bottom: 3px !important;\n",
        "        }\n",
        "        .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab.p-mod-current:before {\n",
        "            top: unset;\n",
        "            bottom: 0;\n",
        "            height: 3px;\n",
        "        }           \n",
        "\n",
        "        input[type=\"checkbox\"] {\n",
        "            margin: 3px 5px !important;\n",
        "            border: none !important;\n",
        "            position: relative;\n",
        "            width: 40px;\n",
        "            height: 20px;\n",
        "            -webkit-appearance: none;\n",
        "            background: #c6c6c6;\n",
        "            outline: none;\n",
        "            border-radius: 20px;\n",
        "            box-shadow: inset 0 0 5px rgba(255, 0, 0, 0.2);\n",
        "            transition: 0.7s;\n",
        "        }\n",
        "        input:checked[type=\"checkbox\"] {\n",
        "        background: #03a9f4;\n",
        "        }\n",
        "        input[type=\"checkbox\"]:before {\n",
        "        content: '';\n",
        "        border: 1px solid #d0d0d0c4;\n",
        "        position: absolute;\n",
        "        width: 20px;\n",
        "        height: 20px;\n",
        "        border-radius: 20px;\n",
        "        top: -1px;\n",
        "        left:0;\n",
        "        background: #ffffff;\n",
        "        transform: scale(1.1);\n",
        "        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n",
        "        transition: .5s;\n",
        "        }\n",
        "        input:checked[type=\"checkbox\"]:before {\n",
        "        left: 20px;\n",
        "        }\n",
        "        @keyframes info-progress {\n",
        "            0% {\n",
        "                background-color: #03b6cc;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "            }\n",
        "            50% {\n",
        "                background-color:\n",
        "                    #00bcd4db;\n",
        "                box-shadow: 1px 1px 7px 3px rgb(5 153 204 / 35%);\n",
        "            }\n",
        "            100% {\n",
        "                background-color: #03b6cc;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(3 182 204 / 30%);\n",
        "            }\n",
        "        }\n",
        "        @keyframes warning-progress {\n",
        "            0% {\n",
        "                background-color: #ff9800;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
        "            }\n",
        "            50% {\n",
        "                background-color:\n",
        "                    #ff9800c9;\n",
        "                box-shadow: 1px 1px 7px 3px rgb(255 152 0 / 41%);\n",
        "            }\n",
        "            100% {\n",
        "                background-color: #ff9800;\n",
        "                box-shadow: 1px 1px 3px 1px rgb(255 152 0 / 30%);\n",
        "            }\n",
        "        }\n",
        "        @keyframes info-overlay {\n",
        "            0% {\n",
        "                left: -10%;\n",
        "                opacity: 0\n",
        "            }\n",
        "            10% {\n",
        "                left: 0%;\n",
        "                opacity: .8\n",
        "            }\n",
        "            30% {\n",
        "                opacity: 1\n",
        "            }\n",
        "            50%{\n",
        "                left: 58%;\n",
        "                opacity: 1\n",
        "            }\n",
        "            90%{\n",
        "                    left: 0%;\n",
        "                opacity: .8\n",
        "            }\n",
        "            100%{\n",
        "                left: -10%;\n",
        "                opacity: 0\n",
        "            }\n",
        "        }\n",
        "                \n",
        "    </style>\"\"\")\n",
        "\n",
        "layout_15 ={'width':'auto', 'flex':'15 1 0%', 'align_items':\"center\"}\n",
        "layout_10 ={'width':'auto', 'flex':'10 1 0%', 'align_items':\"center\"}\n",
        "layout_8 ={'width':'auto', 'flex':'8 1 0%', 'align_items':\"center\"}\n",
        "layout_7 ={'width':'auto', 'flex':'7 1 0%', 'align_items':\"center\"}\n",
        "layout_5 ={'width':'auto', 'flex':'5 1 0%', 'align_items':\"center\"}\n",
        "layout_4 ={'width':'auto', 'flex':'4 1 0%', 'align_items':\"center\"}\n",
        "layout_3 ={'width':'auto', 'flex':'3 1 0%', 'align_items':\"center\"}\n",
        "layout_2 ={'width':'auto', 'flex':'2 1 0%', 'align_items':\"center\"}\n",
        "layout_1 ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"center\"}\n",
        "layout_1E ={'width':'auto', 'flex':'1 1 0%', 'align_items':\"flex-start\"}\n",
        "\n",
        "col4layout = {'width':'%25','flex':'3 1 0%', 'align_items':\"center\"}\n",
        "col3layout = {'width':'%33','flex':'2 1 0%', 'align_items':\"center\"}\n",
        "col2layout = {'width':'%50','flex':'1 1 0%', 'align_items':\"center\"}\n",
        "\n",
        "empty_label_1 = Label(value = \"\", layout = layout_1)\n",
        "empty_label_2 = Label(value = \"\", layout = layout_2)\n",
        "empty_label_3 = Label(value = \"\", layout = layout_3)\n",
        "empty_label_4 = Label(value = \"\", layout = layout_4)\n",
        "empty_label_5 = Label(value = \"\", layout = layout_5)\n",
        "\n",
        "whitespace1 = ' '\n",
        "whitespace2 = '  '\n",
        "whitespace3 = '   '\n",
        "whitespace4 = '    '\n",
        "whitespace5 = '     '\n",
        "\n",
        "### UI Elements\n",
        "\n",
        "rowlayout = {'flex_flow':'row', 'align_items':'center', 'width':'90%', 'height':'160px', 'justify_content':'center'}\n",
        "saverowlayout = { 'flex_flow':'row', 'align_items':'center', 'width':'80%', 'justify_content':'center' }\n",
        "input_style = {\"description_width\":\"160px\"}\n",
        "samplestyle = {\"padding\":\"0 200px 0 200px\"}\n",
        "conflabelstyle = {\"padding\":\"0 0 0 150px\"}\n",
        "mainbox_layout = { 'height': MAINBOX_HEIGHT, 'width': '100%', 'margin':'0 0 20px 0' , 'border': f'1px solid {ACCENT_COLOR}', 'display': 'flex'}\n",
        "tabtitlerow_layout = Layout(height= '100px', width= '100%', padding= '10px 100px', align_items=  'center')\n",
        "formcontent_layout = {'height':'100%', 'width':'100%', 'padding':'40px 30% 0 0'}\n",
        "downloadproperties_layout = {'height':'100%', 'width':'100%', 'padding':'20px 50px'}\n",
        "viewcontainer_layout = Layout(height= '100%', width= '100%')\n",
        "t_formrow_layout = Layout(align_items= 'center', height= '50px', width= '100%', justify_content= 'center', padding= '0')\n",
        "tab_title_layout = Layout( width= \"200px\")\n",
        "t2labels_layout = {'width':'35%', 'justify_content': 'flex-end'}\n",
        "t2labels_style = {'font_size': '18px'}\n",
        "t2controls_layout = {'margin':'0 0 0 10px', 'width':'400px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
        "t2controls_style = {'font_size': '16px', 'description_width':'150px'}\n",
        "searchcheckboxs_layout = {'margin': '5px 0 0 10px', 'justify_items': 'flex-start', 'justify_content': 'flex-start', 'align_content': 'flex-start'}\n",
        "bigbtn_style = {'font_size':'16px', 'font_weight':'600'}\n",
        "bigbtn_layout = {'width':'120px', 'height':'50px', 'margin': '0 0 8px 0'}\n",
        "top_btn_layout = {\"width\": '100px', 'height': '30px', 'margin': '0 0 0 60px'}\n",
        "checkboxstyle = {'description_width':'0'}\n",
        "checkboxlabellayout = {\"width\": \"220px\", \"justify_content\": \"flex-end\"}\n",
        "\n",
        "startpause_btn = Button(disabled= True, description=\"Start\", style= bigbtn_style, layout= top_btn_layout)\n",
        "startpause_btn.layout.display =  'none'\n",
        "startpause_btn.on_click(pause_resume_session)\n",
        "\n",
        "status_html = HTML(layout= {'with': '50%', 'margin': '0 0 0 20px'})\n",
        "status_html.temp = True\n",
        "\n",
        "### Tab Search\n",
        "## Row 1: Title\n",
        "\n",
        "searchtitle_html = HTML(gethtmltitle('Search', 1), layout= tab_title_layout)\n",
        "searchback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "searchr1_hbox = HBox((searchtitle_html, searchback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## R2:  Content\n",
        "# View 1: Search\n",
        "\n",
        "searchsearch_text = Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "searchsearch_hbox = HBox((searchsearch_text,),layout= t_formrow_layout)\n",
        "\n",
        "searchtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK)], layout= t2controls_layout, style= t2controls_style)\n",
        "searchtype_hbox = HBox((searchtype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "searchsite_dropdown = Dropdown(description= \"Site\", value= X1337X, options = [('1337x', X1337X)], layout= t2controls_layout, style= t2controls_style)\n",
        "searchsite_hbox = HBox((searchsite_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "searchcategory_dropdown = Dropdown(description= \"Search Category\", value= ALLCATEGORIES_TD, options = [('All', ALLCATEGORIES_TD), ('Movies', MOVIESCATEGORY_TD), ('TV', TVCATEGORY_TD), ('Apps', APPSCATEGORY_TD), ('Games', GAMESCATEGORY_TD)], layout= t2controls_layout, style= t2controls_style)\n",
        "searchcategory_hbox = HBox((searchcategory_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "searchsort_dropdown = Dropdown(description= \"Results Sorting\", value= SEEDERSSORT, options = [('By Seeders', SEEDERSSORT), ('By Time', TIMESORT), ('By Size', SIZESORT)], layout= t2controls_layout, style= t2controls_style)\n",
        "searchsort_hbox = HBox((searchsort_dropdown,),layout= t_formrow_layout)\n",
        "\n",
        "searchorder_dropdown = Dropdown(description= \"Results Order\", value= DESCORDER, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= t2controls_layout, style= t2controls_style)\n",
        "searchorder_hbox = HBox((searchorder_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "searchreplace_label = Label(\"Replace Existing\", layout= checkboxlabellayout)\n",
        "searchreplace_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "\n",
        "searchreplace_hbox = HBox((searchreplace_label, searchreplace_checkbox), layout= t_formrow_layout)\n",
        "searchbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
        "\n",
        "searchbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "searchbackup_hbox = HBox((searchbackup_label, searchbackup_checkbox), layout= t_formrow_layout)\n",
        "searchbackup_hbox.layout.display = None\n",
        "\n",
        "searchsaveas_text = Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "searchsaveas_hbox = HBox((searchsaveas_text,),layout= t_formrow_layout)\n",
        "\n",
        "searchsearch_button = Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
        "searchsearch_button.layout.align_self = \"center\"\n",
        "searchreplace_label.add_class(\"label-flex\")\n",
        "searchbackup_label.add_class(\"label-flex\")\n",
        "\n",
        "searchview1_vbox= VBox((searchsearch_hbox, searchtype_hbox, searchsite_hbox, searchcategory_hbox,\n",
        "                                   searchsort_hbox, searchorder_hbox, searchreplace_hbox,\n",
        "                                   searchbackup_hbox, searchsaveas_hbox, searchsearch_button), \n",
        "                                   layout= formcontent_layout)\n",
        "\n",
        "searchr2viewcontainer_vbox = VBox((searchview1_vbox, ), layout= viewcontainer_layout)\n",
        "search_vbox = VBox((searchr1_hbox, searchr2viewcontainer_vbox), layout= mainbox_layout)\n",
        "search_vbox.name = \"Search Tab\"\n",
        "search_vbox.add_class('curved-40')\n",
        "setviewelements(search_vbox, searchr2viewcontainer_vbox, searchview1_vbox, searchback_btn, SEARCH_TAB)\n",
        "\n",
        "### Tab IMDB \n",
        "## R1: Title\n",
        "\n",
        "imdbtitle_html = HTML(gethtmltitle('IMDB Search', 1), layout= tab_title_layout)\n",
        "imdbback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "\n",
        "imdbr1_hbox = HBox((imdbtitle_html, imdbback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## R2\n",
        "\n",
        "imdbkeyword_text = Text(description= \"Search\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbkeyword_hbox = HBox((imdbkeyword_text,),layout= t_formrow_layout)\n",
        "\n",
        "imdbtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('Movie', MOVIE), ('TV Show', SHOW), ('Episode', EPISODE)], layout= t2controls_layout, style= t2controls_style)\n",
        "imdbtype_hbox = HBox((imdbtype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "imdbsort_dropdown = Dropdown(description= \"Results Sort\", value= IMDB_DATE_SORT ,options= [(\"By User Rating\", IMDB_RATING_SORT), (\"By Date\", IMDB_DATE_SORT), (\"Alphabetically\", IMDB_ALPHABETICAL_SORT)], layout= t2controls_layout, style= t2controls_style)\n",
        "imdbsort_hbox = HBox((imdbsort_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "imdborder_dropdown = Dropdown(description= \"Results Order\", value= ASCORDER, options = [('Ascending', ASCORDER), ('Descending', DESCORDER)], layout= t2controls_layout, style= t2controls_style)\n",
        "imdborder_hbox = HBox((imdborder_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "imdbstartdate_date = DatePicker(description= \"Start Date\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbstartdate_hbox = HBox((imdbstartdate_date,), layout= t_formrow_layout)\n",
        "\n",
        "imdbenddate_date = DatePicker(description= \"End Date\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbenddate_hbox = HBox((imdbenddate_date,), layout= t_formrow_layout)\n",
        "\n",
        "numeric_layout = {\"width\": \"120px\"}\n",
        "numeric_style = {\"description_width\": \"30px\"}\n",
        "numericlabel_layout = {\"margin\": \"0 3px 0 32px\", \"width\": \"129px\", 'justify_content': 'flex-end'}\n",
        "\n",
        "imdbrating_label = Label(value= \"Rating \", layout= numericlabel_layout)\n",
        "imdbminrating_float = widgets.BoundedFloatText(description= \"Min\", value=7, min=1, max=10, step= 0.1, layout= numeric_layout, style= numeric_style)\n",
        "imdbmaxrating_float = widgets.BoundedFloatText(description= \"Max\", value=10, min=1, max=10, step= 0.1, layout= numeric_layout, style= numeric_style)\n",
        "imdbratings_hbox = HBox((imdbrating_label, imdbminrating_float, imdbmaxrating_float), layout= t_formrow_layout)\n",
        "imdbrating_label.add_class('label-flex')\n",
        "\n",
        "imdbvotes_label = Label(value= \"Votes \", layout= numericlabel_layout)\n",
        "imdbminvotes_int = widgets.BoundedIntText(description= \"Min\", value=0, min= 0, max= 10000000, step= 1, layout= numeric_layout, style= numeric_style)\n",
        "imdbmaxvotes_int = widgets.BoundedIntText(description= \"Max\", value=0, min= 0, max= 10000000, step= 1, layout= numeric_layout, style= numeric_style)\n",
        "imdbvotes_hbox = HBox((imdbvotes_label, imdbminvotes_int, imdbmaxvotes_int), layout= t_formrow_layout)\n",
        "imdbvotes_label.add_class('label-flex')\n",
        "\n",
        "imdbruntime_label = Label(value= \"Run Time \", layout= numericlabel_layout)\n",
        "imdbminruntime_int = widgets.BoundedIntText(description= \"Min\", value= 0, min= 0, max= 10000, step= 1, layout= numeric_layout, style= numeric_style)\n",
        "imdbmaxruntime_int = widgets.BoundedIntText(description= \"Max\", value= 0, min= 0, max= 10000, step= 1, layout= numeric_layout, style= numeric_style)\n",
        "imdbruntime_hbox = HBox((imdbruntime_label, imdbminruntime_int, imdbmaxruntime_int), layout= t_formrow_layout)\n",
        "imdbruntime_label.add_class('label-flex')\n",
        "\n",
        "imdbinlist_text = Text(description= \"In Lists\", value= config.watch_list, placeholder= \"Comma separated list.\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbinlist_hbox = HBox((imdbinlist_text,),layout= t_formrow_layout)\n",
        "\n",
        "imdbnotinlist_text = Text(description= \"Not In List\", value= \"\", placeholder= \"Comma separated list.\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbnotinlist_hbox = HBox((imdbnotinlist_text,),layout= t_formrow_layout)\n",
        "\n",
        "imdbtop250_label = Label(\"In Top 250\", layout= checkboxlabellayout)\n",
        "imdbtop250_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbtop250_hbox = HBox((imdbtop250_label, imdbtop250_checkbox), layout= t_formrow_layout)\n",
        "imdbtop250_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbtop1000_label = Label(\"In Top 1000\", layout= checkboxlabellayout)\n",
        "imdbtop1000_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbtop1000_hbox = HBox((imdbtop1000_label, imdbtop1000_checkbox), layout= t_formrow_layout)\n",
        "imdbtop1000_label.add_class(\"label-flex\")\n",
        "\n",
        "imdboscarwinner_label = Label(\"Oscar Winner\", layout= checkboxlabellayout)\n",
        "imdboscarwinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdboscarwinner_hbox = HBox((imdboscarwinner_label, imdboscarwinner_checkbox), layout= t_formrow_layout)\n",
        "imdboscarwinner_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbbestpicturewinner_label = Label(\"Best Picture Winner\", layout= checkboxlabellayout)\n",
        "imdbbestpicturewinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbbestpicturewinner_hbox = HBox((imdbbestpicturewinner_label, imdbbestpicturewinner_checkbox), layout= t_formrow_layout)\n",
        "imdbbestpicturewinner_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbbestdirectorwinner_label = Label(\"Best Director Winner\", layout= checkboxlabellayout)\n",
        "imdbbestdirectorwinner_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbbestdirectorwinner_hbox = HBox((imdbbestdirectorwinner_label, imdbbestdirectorwinner_checkbox), layout= t_formrow_layout)\n",
        "imdbbestdirectorwinner_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbenglishonly_label = Label(\"Only English Titles\", layout= checkboxlabellayout)\n",
        "imdbenglishonly_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbenglishonly_hbox = HBox((imdbenglishonly_label, imdbenglishonly_checkbox), layout= t_formrow_layout)\n",
        "imdbenglishonly_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbanimationtitles_label = Label(\"Animation Titles\", layout= checkboxlabellayout)\n",
        "imdbanimationtitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbanimationtitles_hbox = HBox((imdbanimationtitles_label, imdbanimationtitles_checkbox), layout= t_formrow_layout)\n",
        "imdbanimationtitles_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbinternationaltitles_label = Label(\"International Titles\", layout= checkboxlabellayout)\n",
        "imdbinternationaltitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbinternationaltitles_hbox = HBox((imdbinternationaltitles_label, imdbinternationaltitles_checkbox), layout= t_formrow_layout)\n",
        "imdbinternationaltitles_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbindiantitles_label = Label(\"Indian Titles\", layout= checkboxlabellayout)\n",
        "imdbindiantitles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbindiantitles_hbox = HBox((imdbindiantitles_label, imdbindiantitles_checkbox), layout= t_formrow_layout)\n",
        "imdbindiantitles_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbfilterdownloadded_label = Label(\"Filter Downloaded\", layout= checkboxlabellayout)\n",
        "imdbfilterdownloadded_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbfilterdownloadded_hbox = HBox((imdbfilterdownloadded_label, imdbfilterdownloadded_checkbox), layout= t_formrow_layout)\n",
        "imdbfilterdownloadded_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbfilterwatched_label = Label(\"Filter Watched\", layout= checkboxlabellayout)\n",
        "imdbfilterwatched_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbfilterwatched_hbox = HBox((imdbfilterwatched_label, imdbfilterwatched_checkbox), layout= t_formrow_layout)\n",
        "imdbfilterwatched_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbreplaceoldfiles_label = Label(\"Replace and Merge Old Files\", layout= checkboxlabellayout)\n",
        "imdbreplaceoldfiles_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbreplaceoldfiles_hbox = HBox((imdbreplaceoldfiles_label, imdbreplaceoldfiles_checkbox), layout= t_formrow_layout)\n",
        "imdbreplaceoldfiles_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
        "imdbbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "imdbbackup_hbox = HBox((imdbbackup_checkbox, imdbbackup_label), layout= t_formrow_layout)\n",
        "imdbbackup_hbox.layout.display = None\n",
        "imdbbackup_label.add_class(\"label-flex\")\n",
        "\n",
        "imdbsearchparams_text = Text(description= \"Search Parameters\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "imdbsearchparams_hbox = HBox((imdbsearchparams_text,),layout= t_formrow_layout)\n",
        "\n",
        "searchimdb_button = Button(description= \"Search\", layout= bigbtn_layout, style= bigbtn_style)\n",
        "searchimdb_button.layout.align_self = \"center\"\n",
        "\n",
        "imdbview1collayout = {\"width\": \"33.3%\", \"height\": \"100%\"}\n",
        "\n",
        "imdbrsearchviewcol1_vbox = VBox((imdbkeyword_hbox, imdbtype_hbox, imdbsort_hbox, imdborder_hbox, imdbstartdate_hbox, imdbenddate_hbox,\n",
        "                            imdbratings_hbox, imdbvotes_hbox, imdbruntime_hbox), layout= imdbview1collayout)\n",
        "\n",
        "imdbrsearchviewcol2_vbox = VBox((imdbinlist_hbox, imdbnotinlist_hbox, imdbsearchparams_hbox, imdbfilterdownloadded_hbox, imdbfilterwatched_hbox,\n",
        "                            imdbreplaceoldfiles_hbox, imdbenglishonly_hbox,\n",
        "                            ), layout= imdbview1collayout)\n",
        "\n",
        "imdbrsearchviewcol3_vbox = VBox((imdbinternationaltitles_hbox, imdbindiantitles_hbox, imdbanimationtitles_hbox, imdbtop250_hbox,\n",
        "                                 imdbtop1000_hbox, imdboscarwinner_hbox, imdbbestpicturewinner_hbox,\n",
        "                            imdbbestdirectorwinner_hbox), layout= imdbview1collayout)\n",
        "\n",
        "imdbsearchviewinnercontainer_hbox = HBox((imdbrsearchviewcol1_vbox, imdbrsearchviewcol2_vbox, imdbrsearchviewcol3_vbox),\n",
        "                                         layout= {\"width\": \"100%\", \"height\": \"500px\"})\n",
        "imdbrsearchview_vbox = VBox((imdbsearchviewinnercontainer_hbox, searchimdb_button), layout= viewcontainer_layout)\n",
        "\n",
        "imdbviewcontainer_vbox = VBox((imdbrsearchview_vbox,), layout= viewcontainer_layout)\n",
        "imdbsearch_vbox = VBox((imdbr1_hbox, imdbviewcontainer_vbox), layout= mainbox_layout)\n",
        "imdbsearch_vbox.name = \"IMDB Search Tab\"\n",
        "imdbsearch_vbox.add_class('curved-40')\n",
        "setviewelements(imdbsearch_vbox, imdbviewcontainer_vbox, imdbrsearchview_vbox, imdbback_btn, IMDB_TAB)\n",
        "\n",
        "### Tab Add Download\n",
        "## R1: Title\n",
        "\n",
        "addtitle_html = HTML(gethtmltitle('Add Downloads', 1), layout= tab_title_layout)\n",
        "addback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "\n",
        "addr1_hbox = HBox((addtitle_html, addback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## R2: Main Content\n",
        "\n",
        "addsourcetype_dropdown = Dropdown(description= \"Download Type\", value= MAGNET_ADDSOURCE, \n",
        "                                         options= [('Magnet', MAGNET_ADDSOURCE), ('Hash', HASH_ADDSOURCE),\n",
        "                                        ('Upload File', UPLOADFILE_ADDSOURCE), ('Local File', LOCALFILE_ADDSOURCE), ('File URL', FILEURL_ADDSOURCE)],\n",
        "                                         layout= t2controls_layout, style= t2controls_style)\n",
        "addsourcetype_hbox = HBox((addsourcetype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "addsource_text = Text(description= \"Magnet\", layout= t2controls_layout, style= t2controls_style)\n",
        "\n",
        "addsourcefile_labelhbox = HBox((Label(value= \"Torrent File\", layout= {\"width\":'auto'}),),\n",
        "                                      layout= {'height':'auto', 'display':'none', 'width':'170px', 'margin': '0 11px 0 0'})\n",
        "addsourcefile_labelhbox.layout.justify_content= 'flex-end'\n",
        "addsourcefile_labelhbox.layout.align_items = 'center'\n",
        "\n",
        "addsource_file = widgets.FileUpload(description= \"Upload File\", layout= {'width':'240px', 'align-items': 'center','justify-content':'flex-start'})\n",
        "addsource_file.layout.display = 'none'\n",
        "addsource_file.layout.align_items = 'center'\n",
        "\n",
        "addsource_hbox = HBox((addsource_text, addsourcefile_labelhbox, addsource_file), layout= t_formrow_layout)\n",
        "\n",
        "addtype_dropdown = Dropdown(description= \"Download Type\", value= MOVIE ,options= [('General', GENERAL), ('Movie', MOVIE), ('Episode', EPISODE), ('Season', SEASON), ('TV Show', SHOW), ('Music Album', ALBUM), ('Song', TRACK)], layout= t2controls_layout, style= t2controls_style)\n",
        "addtype_hbox = HBox((addtype_dropdown,), layout= t_formrow_layout)\n",
        "\n",
        "addreplacemerge_label = Label(\"Replace Existing\", layout= checkboxlabellayout)\n",
        "addreplace_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "addreplacemerge_hbox = HBox((addreplacemerge_label, addreplace_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "addbackup_label = Label(\"Save Backup\", layout= checkboxlabellayout)\n",
        "addbackup_checkbox = Checkbox(value= False, style= checkboxstyle)\n",
        "addbackup_hbox = HBox((addbackup_label, addbackup_checkbox,), layout= t_formrow_layout)\n",
        "\n",
        "addcustomname_text = Text(description= \"Custom Name\", value= \"\", layout= t2controls_layout, style= t2controls_style)\n",
        "addcustomname_hbox = HBox((addcustomname_text,),layout= t_formrow_layout)\n",
        "\n",
        "addadd_button = Button(description= \"Add\", disabled= True, layout= bigbtn_layout, style= bigbtn_style)\n",
        "addadd_button.layout.align_self = \"center\"\n",
        "\n",
        "addr2view1_adddownload_vbox= VBox((addsourcetype_hbox, addsource_hbox, addtype_hbox, addreplacemerge_hbox, addbackup_hbox, addcustomname_hbox, addadd_button), layout= formcontent_layout)\n",
        "addr2viewcontainer_vbox = VBox((addr2view1_adddownload_vbox,), layout= viewcontainer_layout)\n",
        "\n",
        "adddownloads_vbox = VBox((addr1_hbox, addr2viewcontainer_vbox), layout= mainbox_layout)\n",
        "adddownloads_vbox.name = \"Add Tab\"\n",
        "adddownloads_vbox.add_class('curved-40')\n",
        "addreplacemerge_label.add_class(\"label-flex\")\n",
        "addbackup_label.add_class(\"label-flex\")\n",
        "setviewelements(adddownloads_vbox, addr2viewcontainer_vbox, addr2view1_adddownload_vbox, addback_btn, ADD_TAB)\n",
        "\n",
        "### Tab Monitor\n",
        "## Row 1: Title\n",
        "\n",
        "mointortitle_html = HTML(gethtmltitle('Downloads', 1), layout= tab_title_layout)\n",
        "mointorback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "mointorr1_hbox = HBox((mointortitle_html, mointorback_btn, startpause_btn, status_html), layout = tabtitlerow_layout)\n",
        "\n",
        "## Row 2: Monitor view\n",
        "\n",
        "downloadtransferstate = 9\n",
        "downloadmonitorstatestrings = [\"Queued\",\"Checking\",\"Downloading metadata\",\"Downloading\",\"Finished\",\"Seeding\",\"Allocating\",\"Checking resume files\", \"Transfering files\"]\n",
        "\n",
        "mointorview1container_layout = {'width':'100%', 'height':'100%'}\n",
        "mointorview1r1_layout = {'flex_flow':'row','align_items':'center', 'height':'40px', 'width':'100%','justify_content':'space-around'}\n",
        "mointorview1r2manage_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','height':'50px','justify_content':'flex-start'}\n",
        "mointorview1r3_layout = {'padding-left':'100px','flex_flow':'row','align_items':'flex-start','width':'95%','justify_content':'space-around'}\n",
        "mointorview1download_layout = {'flex_flow':'row','align_items':'center','width':'95%','justify_content':'space-around'}\n",
        "\n",
        "mointorview1sessionstatus_label = Label(layout= layout_3)\n",
        "mointorview1active_label = Label(value= \"Active:  0\", layout= layout_3)\n",
        "mointorview1dead_label = Label(value= \"Dead:  0\", layout= layout_3)\n",
        "\n",
        "mointorview1completed_label = Label(value= \"Completed:  0\", layout= layout_3)\n",
        "mointorview1totaldownload_label = Label(value= \"Session download:  0 MB\", layout= layout_5)\n",
        "mointorview1totalprogress_label = Label(value= \"\", layout= layout_3)\n",
        "mointorview1totalupload_label = Label(value= \"Session upload:  0 MB\", layout= layout_5)   \n",
        "\n",
        "mointorview1r2stats_box = Box([mointorview1sessionstatus_label, mointorview1active_label, mointorview1completed_label, mointorview1dead_label, mointorview1totaldownload_label, mointorview1totalprogress_label, mointorview1totalupload_label, empty_label_3], layout= mointorview1r1_layout)\n",
        "monitordownloadscontainer_vbox = VBox(layout= {'align_items': \"center\", 'width':'99.8%', 'height':'100%', 'margin': '22px 0 0 0'})\n",
        "monitordownload_layout = {'width':'95%','align_items':'center','border':'solid #d9dbda 1px', 'margin': \"0 0 7px 0\"}\n",
        "mointorview1downloadmonitor_vbox = VBox((mointorview1r2stats_box, monitordownloadscontainer_vbox), layout= {'width':'100%', 'height':'100%'})\n",
        "mointorr2viewcontainer_vbox = VBox((mointorview1downloadmonitor_vbox,), layout= viewcontainer_layout)\n",
        "\n",
        "monitor_vbox = VBox((mointorr1_hbox, mointorr2viewcontainer_vbox), layout= mainbox_layout)\n",
        "monitor_vbox.name = \"Monitor Tab\"\n",
        "monitor_vbox.add_class('curved-40')\n",
        "setviewelements(monitor_vbox, mointorr2viewcontainer_vbox, mointorview1downloadmonitor_vbox, mointorback_btn, MONITOR_TAB)\n",
        "\n",
        "### Tab Config\n",
        "### view1 r1\n",
        "\n",
        "configtitle_html = HTML(gethtmltitle('Configurations', 1), layout= tab_title_layout)\n",
        "configback_btn = Button(disabled= True, description=\"Back\", style= bigbtn_style, layout= top_btn_layout)\n",
        "configr1_hbox = HBox((configtitle_html, configback_btn, startpause_btn, status_html), layout= tabtitlerow_layout)\n",
        "\n",
        "configview1r1v1activedownload_numeric = widgets.BoundedIntText(value=5, min=1, max=25, step=1, description='Active Downloads', disabled=False, style=input_style)\n",
        "configview1r1v1_vbox = VBox((configview1r1v1activedownload_numeric,), layout= col4layout)\n",
        "\n",
        "configview1r1v2ftptoggle_checkbox = Checkbox(description= \"Enable FTP\", value= False, disabled= False)\n",
        "configview1v2vbox = VBox((configview1r1v2ftptoggle_checkbox,), layout= col4layout)\n",
        "configview1v2vbox.layout.height = '45px'\n",
        "\n",
        "configview1r1v3ftphost_text = Text(placeholder= \"FTP host address\", description= \"FTP Host\", style= input_style)\n",
        "configview1r1v3ftpuser_text = Text(placeholder= \"FTP account username\", description= \"FTP Username\", style= input_style)\n",
        "configview1r1v3ftppass_text = widgets.Password(placeholder= \"FTP account Password\", description=\"FTP Password\", style= input_style)\n",
        "configview1r1v3_vbox = VBox((configview1r1v3ftphost_text, configview1r1v3ftpuser_text, configview1r1v3ftppass_text), layout= col4layout)\n",
        "\n",
        "configview1r1_hbox = HBox((configview1r1v1_vbox, configview1v2vbox, configview1r1v3_vbox), layout= rowlayout)\n",
        "\n",
        "### view1 r2\n",
        "\n",
        "configview1r2v1localbase_text = Text(placeholder= \"Local Base\", description= \"Local Base\", value= LOCALBASE_DEFAULT, style= input_style)\n",
        "configview1r2v1remotebase_text = Text(placeholder= \"Remote Base\", description=\"Remote Base\", value= FTPBASE_DEFAULT, style= input_style)\n",
        "configview1r2v1_vbox = VBox((configview1r2v1localbase_text, configview1r2v1remotebase_text), layout= col3layout)\n",
        "\n",
        "configview1r2v2generallib_text = Text(placeholder= \"Downloads Path\", description= \"Downloads Path\", value= GENERAL_PATH_DEFAULT, style= input_style)\n",
        "configview1r2v2musiclib_text = Text(placeholder= \"Music Library\", description= \"Music Library\", value= MUSIC_PATH_DEFAULT, style= input_style)\n",
        "configview1r2v2_vbox = VBox((configview1r2v2generallib_text, configview1r2v2musiclib_text), layout= col3layout)\n",
        "\n",
        "configview1r2v3movielib_text = Text(placeholder= \"Movies Library\", description= \"Movies Library\", value= MOVIES_PATH_DEFAULT, style= input_style)\n",
        "configview1r2v3tvlib_text = Text(placeholder= \"TV Library\", description= \"TV Library\", value= TV_PATH_DEFAULT, style= input_style)\n",
        "configview1r2v3_vbox = VBox((configview1r2v3movielib_text, configview1r2v3tvlib_text), layout= col3layout)\n",
        "configview1r2_hbox = HBox((configview1r2v1_vbox, configview1r2v2_vbox, configview1r2v3_vbox), layout= rowlayout)\n",
        "\n",
        "### view1 r3\n",
        "\n",
        "configview1r3v1_vbox = VBox(layout= col3layout)\n",
        "\n",
        "\n",
        "configview1r3v2bkgenerallib_text = Text(placeholder= \"Backup General Library\", description= \"Backup General Library\", value= '', style= input_style)\n",
        "configview1r3v2bkmusiclib_text = Text(placeholder= \"Backup Music Library\", description= \"Backup Music Library\", value= '', style= input_style)\n",
        "configview1r3v2_vbox = VBox((configview1r3v2bkgenerallib_text, configview1r3v2bkmusiclib_text), layout= col3layout)\n",
        "\n",
        "configview1r3v3bkmovielib_text = Text(placeholder= \"Backup Movie Library\", description= \"Backup Movie Library\", value= '', style= input_style)\n",
        "configview1r3v3bktvlib_text = Text(placeholder= \"Backup TV Library\", description= \"Backup TV Library\", value= '', style= input_style)\n",
        "configview1r3v3_vbox = VBox((configview1r3v3bkmovielib_text, configview1r3v3bktvlib_text), layout= col3layout)\n",
        "\n",
        "configview1r3_hbox = HBox((configview1r3v1_vbox, configview1r3v2_vbox, configview1r3v3_vbox), layout= rowlayout)\n",
        "\n",
        "### view1 r4\n",
        "\n",
        "configview1r4v1_vbox = VBox(layout= col2layout)\n",
        "\n",
        "configview1r4v2conffile_text = Text(placeholder= \"Configuration File\", description= \"Configuration File\", value= '', style= input_style)\n",
        "configview1r4v2saveconffile_button = Button(description= \"Export Configuration\",)\n",
        "configview1r4v2saveconffile_button.on_click(saveconffilehandler)\n",
        "\n",
        "configview1r4v2loadconffile_button = Button(description= \"Load Configuration\",)\n",
        "configview1r4v2loadconffile_button.on_click(loadconffilehandler)\n",
        "configview1r4v2conffile_hbox = HBox((configview1r4v2saveconffile_button, configview1r4v2loadconffile_button), layout= {\"width\":\"auto\",\"justify-content\":\"space-around\"})\n",
        "configview1r4v2_vbox = VBox((configview1r4v2conffile_text, configview1r4v2conffile_hbox), layout= col2layout)\n",
        "\n",
        "configview1r4_hbox = HBox((configview1r4v1_vbox, configview1r4v2_vbox), layout= rowlayout)\n",
        "\n",
        "### view1 r5\n",
        "\n",
        "saveconfstyle = f\"color:{SUCCESS_COLOR}\"\n",
        "configview1r5saveconf_button = Button(description= \"Save Configuration\",)\n",
        "configview1r5saveconf_button.on_click(saveconfighandler)\n",
        "configview1r5saveconfoutput_html = HTML(layout= layout_4)\n",
        "configview1r5saveconfig_Box = Box((empty_label_3 ,configview1r5saveconf_button, empty_label_1, configview1r5saveconfoutput_html), layout= saverowlayout)\n",
        "configview1r5_hbox = HBox((configview1r5saveconfig_Box,), layout= rowlayout)\n",
        "\n",
        "configview1_vbox = VBox((configview1r1_hbox, configview1r2_hbox, configview1r3_hbox, configview1r4_hbox, configview1r5_hbox), )\n",
        "configr2container_vbox = VBox((configview1_vbox,), layout= viewcontainer_layout)\n",
        "config_vbox = VBox((configr1_hbox, configr2container_vbox), layout= mainbox_layout)\n",
        "config_vbox.name = \"Config Tab\"\n",
        "config_vbox.add_class('curved-40')\n",
        "setviewelements(config_vbox, configr2container_vbox, configview1_vbox, configback_btn, CONFIG_TAB)\n",
        "\n",
        "###\n",
        "\n",
        "def tabchanged_handler(change):\n",
        "    appstate.currentviewcontainer = maintabs.children[change['new']].maincontainer\n",
        "    if status_html.temp:\n",
        "        status_html.value = ''\n",
        "    if appstate.navactions:\n",
        "        try:\n",
        "            actions = appstate.navactions.copy()\n",
        "            appstate.navactions.clear()\n",
        "            info(f\"Completing navigation actions. Action count: {len(actions)}.\")\n",
        "            for action in actions:\n",
        "                action[0](*action[1])\n",
        "        except Exception as e:\n",
        "            error(ex())\n",
        "        release()\n",
        "\n",
        "maintabs = widgets.Tab((search_vbox, adddownloads_vbox, monitor_vbox, imdbsearch_vbox, config_vbox), layout= {\"width\": \"100%\"})\n",
        "maintabs.observe(tabchanged_handler, 'selected_index')\n",
        "maintabs.set_title(0, 'Search')\n",
        "maintabs.set_title(1, 'Add Downloads')\n",
        "maintabs.set_title(2, 'Downloads')\n",
        "maintabs.set_title(3, 'IMDB Search')\n",
        "maintabs.set_title(4, 'Configuration')\n",
        "\n",
        "appstate.tab_indices[SEARCH_TAB] = 0\n",
        "appstate.tab_indices[ADD_TAB] = 1\n",
        "appstate.tab_indices[MONITOR_TAB] = 2\n",
        "appstate.tab_indices[IMDB_TAB] = 3\n",
        "appstate.tab_indices[CONFIG_TAB] = 4\n",
        "\n",
        "uiclicker_btn = Button(description= UICLICKER_RUN, layout= {'display':'none'})\n",
        "container = Box((maintabs, css_html, uiclicker_btn), layout= {\"width\": \"100%\"})\n",
        "\n",
        "### Dynamic views\n",
        "\n",
        "addresultlayout =  {'height': '330px', 'width': '100%'}\n",
        "addresultrowlayout = {}\n",
        "addrestitlefont = '22px'\n",
        "addrestitlestyle = ' display: inline-block; margin: 0 0 10px 40px'\n",
        "addresultlabelfontsize = '18px'\n",
        "addresultvaluefontsize = '16px'\n",
        "addreslabelstyle = 'width:180px; display: inline-block; text-align: end; margin: 0 40px 0 0'\n",
        "\n",
        "fileselectionlayout =  {'height': '470px', 'width': '100%'}\n",
        "fileselectiontitlestyle = ' display: inline-block; margin: 0 20px 10px 40px'\n",
        "fileselectionbuttonlayout = {'width': '100px', 'height': '30px'}\n",
        "filerowfontsize = '16px'\n",
        "filetableformatters = {'Download': {'type': 'tickCross'},}\n",
        "filetableeditors = {'No': None, 'Download': CheckboxEditor(), 'Size': None,'Name': None, }\n",
        "filetablecolumnwidths={'No': '8%', 'Download': '15%', 'Size': '12%', 'Name': '65%'}\n",
        "\n",
        "def getmessageview(text):\n",
        "    t1style = f\"color:{ACCENT_COLOR}; display: inline-block; vertical-align: top; padding: 33px;\"\n",
        "    message_container = f'<div style=\"height: {MESSAGE_CONTAINER_HEIGHT}; width:100%; text-align: center; padding: {MESSAGE_CONTAINER_PADDING}\">{gethtmltext(text , style= t1style, fontsize= \"32px\")} </div>'\n",
        "    return HTML(message_container)\n",
        "\n",
        "def iconcss(s):\n",
        "    global icon_css\n",
        "    return [icon_css for i in range(len(s))]        \n",
        "\n",
        "def updateoutput(out: Output, view):\n",
        "    out.clear_output()\n",
        "    with out:\n",
        "        display(view)\n",
        "\n",
        "def updatesearchresults(result: WebResult, page, sort= None, order= None): #\n",
        "    switchview(result.tab, getloadingview(f'Search for {types[result.attrs.type_]} {result.search} site: {result.site} page: {page}.'), temp= True)\n",
        "    result.updateresults(page, sort, order)\n",
        "    pagination = getpagination(result)\n",
        "    dataframe = result.getdataframe()\n",
        "    result.table.value = dataframe\n",
        "    result.pagination_container.children = pagination    \n",
        "    updateoutput(result.tableoutput, result.table)\n",
        "    switchview(result.tab)\n",
        "\n",
        "def getpagination(result: WebResult):\n",
        "    info(f\"Creating pagination for search {result.search}.\")\n",
        "    currentpage_btn = Button(description= str(result.page), disabled= True, layout= pagebtn_layout)\n",
        "    dots = HTML(gethtmltext('...', fontsize= '30px'), layout= {'height': '40px', 'padding':'0 6px 12px 0'})\n",
        "    pagination = [currentpage_btn]\n",
        "    if result.page > 1:\n",
        "        if result.page -1 != 0:\n",
        "            pagination.insert(0, Button(description= str(result.page - 1), layout= pagebtn_layout)) \n",
        "        if result.page - 1 > 1:\n",
        "            pagination = [Button(description= '1', layout= pagebtn_layout), dots] + pagination\n",
        "    if result.page < result.totalpages:\n",
        "        pagination.append(Button(description= str(result.page + 1), layout= pagebtn_layout))\n",
        "    if result.page + 1 < result.totalpages:\n",
        "        pagination += [dots, Button(description= str(result.totalpages), layout= pagebtn_layout)]\n",
        "    for obj in pagination:\n",
        "        if type(obj) == Button and not obj.disabled:\n",
        "            obj.on_click(result.pagination_handler)\n",
        "    return pagination\n",
        "\n",
        "def getsearchresultview(result: WebResult):\n",
        "    info(f\"Creating search result view for {result.search}.\")\n",
        "    if result.status == FAIL:\n",
        "        result_html = HTML(gethtmltext(result.result, fontsize= '24px'), layout= {'margin': '150px 0 0 50px'})\n",
        "        children = (result_html,)\n",
        "    else:\n",
        "        searchtitle_html = HTML(gethtmltext(f\"Search results {result.search}\", fontsize= '22px'), layout= {'width': '33%'})\n",
        "        controls_hbox = HBox(result.getresultcontrols(), layout= {\"width\": \"700px\"})\n",
        "        pagination = getpagination(result)\n",
        "        pagination_hbox = HBox(pagination, layout= {'align_items':'center'})\n",
        "        row1 = HBox((searchtitle_html, controls_hbox, pagination_hbox), layout= {\"height\": \"45px\", \"width\": \"100%\", \"align_items\": \"center\", 'padding': '0 0 0 40px'})\n",
        "\n",
        "        result.getresultstable()\n",
        "        resultsoutput = Output()\n",
        "        with resultsoutput:\n",
        "            display(result.table)\n",
        "        result.tableoutput = resultsoutput\n",
        "        result.pagination_container = pagination_hbox\n",
        "        row2 = VBox((resultsoutput,), layout= {\"height\": \"700px\", \"width\": \"100%\"})\n",
        "        children = (row1, row2)\n",
        "\n",
        "    searchresults_vbox = VBox(children, layout= {\"width\": \"100%\", \"height\": \"100%\"})\n",
        "    info(f\"Search result view created for {result.search}.\")\n",
        "    searchresults_vbox.name = \"Search results view.\"\n",
        "    return searchresults_vbox\n",
        "\n",
        "def setfilesandsizeinfoview(result: AddResult):\n",
        "    result.sizehtml.value = gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( data_str(result.size), fontsize= addresultvaluefontsize)\n",
        "    result.selectedfileshtml.value = gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.selectedfiles_count, fontsize= addresultvaluefontsize)\n",
        "\n",
        "def getaddinfosubview(result: AddResult):\n",
        "    if result.status == ADDSUCCUSS:\n",
        "        resulttitlehtml = HTML(gethtmltext(\"Download Properties\", fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        namehtml = HTML(gethtmltext(\"Download name:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext(result.name, fontsize= addresultvaluefontsize))\n",
        "        savenamehtml = HTML(gethtmltext(\"Save as:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savename,fontsize= addresultvaluefontsize))\n",
        "        sizehtml = HTML(gethtmltext(\"Total size:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
        "        fileshtml = HTML(gethtmltext(\"Total files:\", style= addreslabelstyle, fontsize= addresultlabelfontsize))\n",
        "        hashhtml = HTML(gethtmltext(\"Hash:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.hash, fontsize= addresultvaluefontsize))\n",
        "        savepathhtml = HTML(gethtmltext(\"Save path:\", style= addreslabelstyle, fontsize= addresultlabelfontsize) + gethtmltext( result.savepath, fontsize= addresultvaluefontsize))\n",
        "        children = (resulttitlehtml, namehtml, savenamehtml, sizehtml, fileshtml, hashhtml, savepathhtml)\n",
        "        result.sizehtml = sizehtml\n",
        "        result.selectedfileshtml = fileshtml\n",
        "    else:\n",
        "        resulttitlehtml = HTML(gethtmltext(result.errormessage, fontsize= addrestitlefont, style= addrestitlestyle))\n",
        "        children = (resulttitlehtml,)\n",
        "    downloadinfoview = VBox(children, layout= addresultlayout)\n",
        "    downloadinfoview.titleview = resulttitlehtml\n",
        "    return downloadinfoview\n",
        "\n",
        "def getdownloadsdataframe(files: list[DownloadFile]):\n",
        "    filetablesource = {\"No\": [], \"Download\":[], \"Size\": [], \"Name\": []}\n",
        "    for item in files:\n",
        "        filetablesource['No'].append(item.index + 1)\n",
        "        filetablesource['Download'].append(item.selected)\n",
        "        filetablesource['Size'].append(data_str(item.size))\n",
        "        filetablesource['Name'].append(item.name)\n",
        "    return pd.DataFrame(filetablesource)\n",
        "\n",
        "def makedownloadfiletable(files: list[DownloadFile]):\n",
        "    dataframe = getdownloadsdataframe(files)\n",
        "    filetable = pn.widgets.Tabulator(dataframe, \n",
        "                                        sizing_mode= 'stretch_width', \n",
        "                                        widths= filetablecolumnwidths, \n",
        "                                        disabled= False, \n",
        "                                        show_index= False, \n",
        "                                        pagination= None, \n",
        "                                        editors= filetableeditors,\n",
        "                                        formatters= filetableformatters) \n",
        "    def editfiles(e):\n",
        "        files[e.row].selected = e.value\n",
        "    filetable.on_edit(editfiles)\n",
        "    return filetable\n",
        "\n",
        "def getfileselectionsubview(result: AddResult, fileselectionview_vbox= None):\n",
        "    if not fileselectionview_vbox:\n",
        "        fileselectionview_vbox = VBox(layout= fileselectionlayout)\n",
        "    if result.status == ADDSUCCUSS:\n",
        "        handle = result.handle\n",
        "        files: list[DownloadFile] = result.files\n",
        "        fileselectiontitle = HTML(gethtmltext(\"Select files\", fontsize= addrestitlefont, style= fileselectiontitlestyle))\n",
        "        selectall_button = Button(description= \"All\", layout= fileselectionbuttonlayout)\n",
        "        selectall_button.layout.margin = f'2px 0 20px'\n",
        "        selectall_button.layout.width = '60px'\n",
        "        selectintervals_text = Text(description= 'Intervals', placeholder= 'Start-end, single, n:start-end, s01-s03..', layout= {'width':'400px', 'margin': \"3px 0 0 0\"})\n",
        "        selectintervals_button = Button(description= \"Select\", layout= fileselectionbuttonlayout)\n",
        "        selectintervals_button.layout.margin = '2px 0 0 16px'\n",
        "        savefiles_button = Button(description= \"Save\", layout= fileselectionbuttonlayout)\n",
        "        savefiles_button.layout.margin = '2px 0 0 12px'\n",
        "        selectstatus_html = HTML(layout= {\"margin\": \"0 0 0 20px\", 'padding': '4px 0 0 0'})\n",
        "        toprow_hbox = HBox((fileselectiontitle, selectall_button, selectintervals_text, selectintervals_button, savefiles_button, selectstatus_html), layout= {'width': '100%', 'height':'62px'})\n",
        "\n",
        "        filetable = makedownloadfiletable(files)\n",
        "        filetableoutput = Output()\n",
        "        result.filetable = filetable\n",
        "        result.filetableoutput = filetableoutput\n",
        "        result.selectall_button = selectall_button\n",
        "        result.selectintervals_button = selectintervals_button\n",
        "        with filetableoutput:\n",
        "            display(filetable)\n",
        "        filetable_vbox = VBox((filetableoutput,), layout= {'width': '100%', 'height': '400px'})\n",
        "        filetable_vbox.layout.border = '1px solid #ababab'\n",
        "        filetable_vbox.add_class('curved-20')\n",
        "        fileselectionview_vbox.children = (toprow_hbox, filetable_vbox)\n",
        "        fileselectionview_vbox.filetable = filetable\n",
        "        fileselectionview_vbox.filetableoutput = filetableoutput\n",
        "\n",
        "        def selectallandpatch(b):\n",
        "            if files:\n",
        "                selectallfiles(files)\n",
        "                patchfiletableandinfo(result)\n",
        "            \n",
        "        def selectseasonintervalandpatch(b):\n",
        "            selection = selectintervals_text.value.strip()\n",
        "            if selection and files:\n",
        "                getfileselectionwithstr(files, selection)\n",
        "                patchfiletableandinfo(result)\n",
        "\n",
        "        def handlefileselection(b):\n",
        "            status = selectdownloadfiles(handle, files)\n",
        "            if status:\n",
        "                color = SUCCESS_COLOR\n",
        "                statusstr = \"Files selected successfully.\"\n",
        "                appstate.total_wanted -= result.size\n",
        "                result.selectedfiles_count = handle.selected_files_count\n",
        "                result.size = handle.total_download\n",
        "                appstate.total_wanted += result.size\n",
        "                setfilesandsizeinfoview(result)\n",
        "                updateoutput(filetableoutput, filetable)\n",
        "            else:\n",
        "                color = FAIL_COLOR\n",
        "                statusstr = 'Files selection failed.'\n",
        "            selectstatus_html.value = gethtmltext(statusstr, fontsize= '16px', color= color)\n",
        "\n",
        "        selectall_button.on_click(selectallandpatch)\n",
        "        selectintervals_button.on_click(selectseasonintervalandpatch)\n",
        "        savefiles_button.on_click(handlefileselection)\n",
        "    return fileselectionview_vbox \n",
        "\n",
        "def metadata_watcher(result: AddResult):\n",
        "    try:\n",
        "        appstate.metacheckeralive = True\n",
        "        while appstate.metacheckeralive:\n",
        "            torrentfile = result.handle.torrent_file()\n",
        "            if torrentfile:\n",
        "                result.hasmetadata = True\n",
        "                setwantedbytes(result.handle)\n",
        "                set_download_filtered_files(result)\n",
        "                clicktask(updatedownloadproperties, (result,))\n",
        "                appstate.metacheckeralive = False\n",
        "                break\n",
        "            time.sleep(0.2)\n",
        "        appstate.metacheckeralive = False\n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "        updatestatushtml('An error happend while checking download metadata', ERROR_EVENT)\n",
        "    release()\n",
        "\n",
        "def updatedownloadproperties(result: AddResult):\n",
        "    dataframe = getdownloadsdataframe(result.files)\n",
        "    result.filetable.value = dataframe\n",
        "    setfilesandsizeinfoview(result)\n",
        "    result.selectall_button.disabled = False\n",
        "    result.selectintervals_button.disabled = False\n",
        "    updateoutput(result.filetableoutput, result.filetable)\n",
        "\n",
        "def patchfiletableandinfo(result: AddResult): \n",
        "    patch = {\"Download\": []}\n",
        "    for i in range(len(result.files)):\n",
        "        patch[\"Download\"].append((i, result.files[i].selected))\n",
        "    result.filetable.patch(patch)\n",
        "    updateoutput(result.filetableoutput, result.filetable)\n",
        "\n",
        "## User Input\n",
        "\n",
        "userinput_layout = {'width':'800px', 'height':'350px', 'align_items': 'center', 'justify_content': 'flex-start', 'padding': '50px 20px 0 20px', 'border': f'2px solid {LIGHTGREY_COLOR}'}\n",
        "userinputbtn_layout = {'min_width': '100px', 'height':'50px'}\n",
        "userinputrow1_layout = {'width':'99%', 'height':'auto', 'padding':'0 30px', 'margin':'0 0 20px 0'}\n",
        "userinputrow2_layout = {'justify_content':'space-around','padding':'0 50px', 'margin':'0 0 15px 0', 'width':'100%', 'align_items': 'center'}\n",
        "userinputrow3_layout = {'display':'none','justify_content':'space-around','padding':'0 60px','width':'100%', 'align_items': 'center'}\n",
        "userinputtext_layout = {'width':'350px '}\n",
        "userinputtextbtn_layout = {'height':'30px', 'width':'60px'}\n",
        "userinputview_layout = {'width':'100%', 'height':'100%','align_items': 'center', 'padding':'120px 0 0 0'}\n",
        "\n",
        "def userdecisionview(inputviewchildren):\n",
        "    userinputview_vbox = VBox(inputviewchildren, layout= userinputview_layout)\n",
        "    userinputview_vbox.name = \"User Decision\"\n",
        "    return userinputview_vbox\n",
        "\n",
        "def userinputbox(inputrows):\n",
        "    userinput_vbox = VBox(inputrows, layout= userinput_layout)\n",
        "    userinput_vbox.add_class('curved-20')\n",
        "    return userinput_vbox\n",
        "\n",
        "def replace_download_decision(prep_res: Prepare_Result):\n",
        "    message_html = HTML(gethtmltext(f'The {prep_res.typestr} \"{prep_res.attrs.name}\" is already downloaded and saved as: {prep_res.foundpath}<br>Do you want to replace old file or rename new download?', fontsize= '16px', color= DARKGERYCOLOR))\n",
        "    row1userinput_box = Box((message_html,), layout= userinputrow1_layout)\n",
        "    replaceoption_btn = Button(description= \"Replace\", layout= userinputbtn_layout)\n",
        "    mergeoption_btn = Button(description= \"Merge\", layout= userinputbtn_layout)\n",
        "    canceloption_btn = Button(description= \"Cancel Download\", layout= userinputbtn_layout)\n",
        "    rename_btn = Button(description= \"Rename New File\", layout= userinputbtn_layout)\n",
        "    row2userinput_hbox = HBox((mergeoption_btn, replaceoption_btn, canceloption_btn, rename_btn), layout= userinputrow2_layout)\n",
        "    newname_text = Text(description= \"New file name: \",style={'description_width': '100px'}, layout= userinputtext_layout)\n",
        "    savename_btn = Button(description= \"OK\", disabled= True, layout= userinputtextbtn_layout)\n",
        "    row3userinput_hbox = HBox((newname_text, savename_btn), layout= userinputrow3_layout)\n",
        "    rename_btn.on_click(lambda b: showview(row3userinput_hbox))\n",
        "\n",
        "    def handletextinputchange(change):\n",
        "        newval = newname_text.value.strip()\n",
        "        if newval:\n",
        "            savename_btn.disabled = False\n",
        "        else: savename_btn.disabled = True\n",
        "    \n",
        "    def renamedownloadaction(b):\n",
        "        newname = newname_text.value.strip()\n",
        "        return already_downloaded_handler(AlreadyDownloadedDecision(RENAME_DOWNLOAD, newname), prep_res.attrs)\n",
        "          \n",
        "    newname_text.observe(handletextinputchange, 'value')\n",
        "    replaceoption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(REPLACE_DOWNLOAD), prep_res.attrs))\n",
        "    mergeoption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(MERGE_DOWNLOAD), prep_res.attrs))\n",
        "    canceloption_btn.on_click(lambda b: already_downloaded_handler(AlreadyDownloadedDecision(CANCEL_DOWNLOAD), prep_res.attrs))\n",
        "    savename_btn.on_click(renamedownloadaction)\n",
        "    userinput_vbox = userinputbox((row1userinput_box, row2userinput_hbox, row3userinput_hbox))\n",
        "    switchview(nav[ADD_TAB], nextview= userdecisionview((userinput_vbox,)), temp= True)\n",
        "\n",
        "def searchsitedecisionview():\n",
        "    \n",
        "    return\n",
        "\n",
        "##\n",
        "\n",
        "def updatestatushtml(message: str= '' , event= INFO_EVENT, animated= False, temp= True):\n",
        "    if not message:\n",
        "        status_html.value = ''\n",
        "    else:   \n",
        "        status_html.temp = temp\n",
        "        if event == ERROR_EVENT:\n",
        "            color = LOADING_COLOR\n",
        "        elif event == SUCCUSS:\n",
        "            color = SUCCESS_COLOR\n",
        "        else: color = ACCENT_COLOR\n",
        "        status_html.value = gethtmltext(message, fontsize= '16px', color= color, animated= animated)\n",
        "\n",
        "### Monitor\n",
        "\n",
        "def setpatheshtml():\n",
        "    t5view1r1pathes_html = HTML(layout= {'height':'35px', 'width':'99.8%'})\n",
        "    pathstr = \"<style>.path-str{margin: 0 0 0 80px; font-size: 14px}</style>\"\n",
        "    if config.general_path:\n",
        "        pathstr += f'<span class=\"path-str\">Downloads: {config.general_path}</span>'     \n",
        "    if config.movies_path:\n",
        "        pathstr += f'<span class=\"path-str\">Movies: {config.movies_path}</span>'\n",
        "    if config.tv_path:\n",
        "        pathstr += f'<span class=\"path-str\">TV: {config.tv_path}</span>'\n",
        "    if config.music_path:\n",
        "        pathstr += f'<span class=\"path-str\">Music: {config.music_path}</span>'        \n",
        "    t5view1r1pathes_html.value = pathstr\n",
        "    info(\"Pathes html status is set.\")\n",
        "\n",
        "def get_download_view(handle):\n",
        "    status = handle.status()\n",
        "    title_label = Label(value= handle.attrs.name, layout= layout_10)\n",
        "    progress_label = Label(value= \"{:.2f}%\".format(status.progress*100), layout= layout_1)\n",
        "    progress_bar = FloatProgress(value= status.progress*100, min= 0, max= 100, step= 0.2, bar_style= 'info', orientation= 'horizontal', layout= layout_15)\n",
        "    control_btn = Button(description= \"∣∣\", layout= {'width':'28px', 'height':'29px', 'padding': '0px 1px 2px 2px', 'margin': '0 6px 6px 18px'})\n",
        "    info_btn = Button(description= \"i\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 5px 0 0'})\n",
        "    remove_btn = Button(description= \"✕\", layout= {'width':'28px', 'height':'29px', 'padding': '1px', 'margin': '0 20px 0 0'})\n",
        "    status_label = Label(value= \"Downloading\", layout= layout_2)\n",
        "    type_label = Label(value= types[handle.attrs.type_], layout= layout_2)\n",
        "    speed_label = Label(value= f\"Rate {whitespace3}↓ {speed_str(status.download_rate)}{whitespace3}↑ {speed_str(status.upload_rate)}\", layout= layout_4)\n",
        "    transfered_label = Label(value= f\"Transfered {whitespace3}↓ {data_str(status.total_wanted_done)}{whitespace3}↑ {data_str(status.total_upload)}\", layout= layout_4)\n",
        "    remaining_label = Label(value= f\"Remaining {whitespace3}{data_str(status.total_wanted - status.total_wanted_done)} / {data_str(status.total_wanted)}\" , layout= layout_4)\n",
        "    eta_label = Label(value= get_eta(status), layout= layout_2)\n",
        "    downloadrow1box = Box((title_label, progress_label, progress_bar, empty_label_1), layout = mointorview1r3_layout)\n",
        "    downloadrow2box = Box((control_btn, info_btn, remove_btn, status_label, type_label, speed_label, transfered_label, remaining_label, eta_label), layout= mointorview1r3_layout)\n",
        "    downloadvbox = VBox((downloadrow1box,downloadrow2box), layout= monitordownload_layout)\n",
        "    downloadvbox.add_class('curved-20')\n",
        "    downloadvbox.title_label = title_label\n",
        "    downloadvbox.progress_label = progress_label\n",
        "    downloadvbox.progress_bar = progress_bar\n",
        "    downloadvbox.control_btn = control_btn\n",
        "    downloadvbox.info_btn = info_btn\n",
        "    downloadvbox.remove_btn = remove_btn\n",
        "    downloadvbox.status_label = status_label\n",
        "    downloadvbox.type_label = type_label\n",
        "    downloadvbox.speed_label = speed_label\n",
        "    downloadvbox.transfer_label = transfered_label\n",
        "    downloadvbox.remaining_label =  remaining_label\n",
        "    downloadvbox.eta_label = eta_label\n",
        "    downloadvbox.handle = handle\n",
        "    handle.view = downloadvbox\n",
        "    handle.view.index = len(active)\n",
        "    handle.progress_bar = progress_bar \n",
        "    handle.control_btn = control_btn \n",
        "    control_btn.on_click(lambda btn: pause_start_download(downloadvbox.handle, btn))\n",
        "    info_btn.on_click(lambda btn: switchview(nav[MONITOR_TAB], downloadvbox.handle.propertiesview))\n",
        "    remove_btn.on_click(lambda btn: remove_download(downloadvbox))\n",
        "    monitoractivedownload_views.append(downloadvbox)\n",
        "    info(f'Download view created for: {handle.name}')\n",
        "    return downloadvbox\n",
        "\n",
        "### Handling\n",
        "\n",
        "addsourcetype_dropdown.observe(addsource_change, names= \"value\")\n",
        "addsource_text.observe(addinput_change, 'value')\n",
        "addsource_file.observe(addfile_change, names= 'value')\n",
        "addadd_button.on_click(adddownload_handler)\n",
        "searchsearch_button.on_click(search_handler)\n",
        "searchimdb_button.on_click(imdb_handler)\n",
        "\n",
        "def makeclickjs(btn_desc, interval= 0, use_evaljs= False, enable_console= False, getstr= False):\n",
        "    info(f\"Creating click js for bottun discription: {btn_desc}\")\n",
        "    if IS_ENV_COLAB:\n",
        "        if interval > 0:\n",
        "            funcname= f\"pyfunc{nowstr()}\"\n",
        "            funcstart =  f\"function {funcname}() {{\"\n",
        "            funcendrepeat = f\"}} setInterval({funcname}, {interval});\"\n",
        "        else:\n",
        "            funcname = funcstart = funcendrepeat = \"\"\n",
        "        if enable_console:\n",
        "            contrue = f\"console.info('Click made to {btn_desc} button.');\"\n",
        "            confalse = f'console.info(\"{btn_desc} wasn\\'t found\");'\n",
        "        else:\n",
        "            contrue = confalse = \"\"\n",
        "        clickjs = f\"\"\"{funcstart}\n",
        "        els = Array.prototype.slice.call(document.getElementsByTagName('button')).filter(el => el.textContent.startsWith('{btn_desc}'));\n",
        "        if (els.length > 0) {{els[0].click(); {contrue}}} else {{{confalse}}} {funcendrepeat} \"\"\"\n",
        "        if getstr:\n",
        "            return clickjs\n",
        "        if use_evaljs:\n",
        "            eval_js(clickjs, ignore_result= True)\n",
        "            info(f\"Click js for bottun {btn_desc} was sent with eval_js.\")\n",
        "        else:\n",
        "            display(Javascript(clickjs))\n",
        "            info(f\"Click js for bottun {btn_desc} was sent with display javascript.\")\n",
        "\n",
        "def clicktask(task, args= (), wait= 0):\n",
        "    appstate.clicktasks.append((task, args))\n",
        "    if wait:\n",
        "        time.sleep(wait)\n",
        "    \n",
        "def clicktaskshandler(btn= None):\n",
        "    # mointorr2viewcontainer_vbox.notify_change({'name': 'value', 'type':'update'}) \n",
        "    if appstate.clicktasks:\n",
        "        worktasks = appstate.clicktasks.copy()\n",
        "        appstate.clicktasks.clear()\n",
        "        for task in worktasks:\n",
        "            try:\n",
        "                task[0](*task[1])\n",
        "            except Exception as e:\n",
        "                error(ex())\n",
        "                release()\n",
        "\n",
        "def run_uiclicker():\n",
        "    uiclicker_btn.description = UICLICKER_RUN\n",
        "\n",
        "def stop_uiclicker():\n",
        "    uiclicker_btn.description = UICLICKER_STOP\n",
        "\n",
        "uiclicker_btn.on_click(clicktaskshandler)\n",
        "\n",
        "## Utils\n",
        "\n",
        "if IS_ENV_COLAB:\n",
        "    unmount = drive.flush_and_unmount\n",
        "\n",
        "def resetapp(delinit= False, delfiles= False):\n",
        "    if active:\n",
        "        for i in range(len(active)): \n",
        "            ses.remove_torrent(active[i])\n",
        "        active.clear()\n",
        "    if downloads_dict:\n",
        "        downloads_dict.clear()\n",
        "    if completed:\n",
        "        completed.clear()\n",
        "    monitoractivedownload_views.clear()\n",
        "    monitordownloadscontainer_vbox.children = ()\n",
        "    appstate.total_downloads = 0\n",
        "    appstate.completed = 0\n",
        "    appstate.deads = 0\n",
        "    appstate.total_progress = 0\n",
        "    appstate.total_wanted = 0\n",
        "    appstate.running = False\n",
        "    update_download_stats_labels()\n",
        "    if delfiles:\n",
        "        !rm -r '/content/d-0/'*\n",
        "    if delinit and 'init' in globals():\n",
        "        global init\n",
        "        del init\n",
        "\n",
        "def restart():\n",
        "    if IS_ENV_COLAB:\n",
        "        unmount()\n",
        "        get_ipython: None\n",
        "        get_ipython().kernel.do_shutdown(True)\n",
        "\n",
        "def list_trackers():\n",
        "    handle = active[-1]\n",
        "    trackers = handle.trackers()\n",
        "    print(\"Trackers count \", len(trackers))\n",
        "    for x in trackers:\n",
        "        #print(x)\n",
        "        print(x['url'], x['tier'])\n",
        "\n",
        "def load_download(Load_From):\n",
        "    Local = False   \n",
        "    Type = MOVIE  \n",
        "    Category = MOVIESCATEGORY_TD  \n",
        "    Sort = \"By Seeders\"   \n",
        "    Order = \"Descending\"  \n",
        "    Backup = True  \n",
        "    sort = TIMESORT\n",
        "    if Sort == TIMESORT:\n",
        "        if Order == \"Descending\":\n",
        "            sort = X1337X_TIME_DESC\n",
        "        else:\n",
        "            sort = X1337X_TIME_ASC\n",
        "    elif Sort == \"By Size\":\n",
        "        if Order == \"Descending\":\n",
        "            sort = X1337X_SIZE_DESC\n",
        "        else:\n",
        "            sort = X1337X_SIZE_ASC\n",
        "    try:\n",
        "        if Load_From:\n",
        "            load_uncompleted(Load_From, type_ = MOVIE)\n",
        "        elif Local:\n",
        "            load_uncompleted(temp_save, type_ = MOVIE, local = True) \n",
        "        release()\n",
        "    except KeyboardInterrupt as k:\n",
        "        k\n",
        "\n",
        "def edit_torrent_settings():\n",
        "    Announce_To_All_Tiers = True \n",
        "    Announce_To_All_Trackers = True \n",
        "    Active_Limit = 5  \n",
        "    config.activedownloads = 3  \n",
        "    Active_Seeds = 1 \n",
        "    Active_Checking = 3  \n",
        "    Connections_Limit = 2330 \n",
        "    Connection_Speed = 80 \n",
        "    Connections_Slack = 50 \n",
        "    File_Pool_Size = 20 \n",
        "    Half_Open_Limit = 100 \n",
        "    Max_Rejects = 8 \n",
        "    Max_Peerlist_Size = 5000 \n",
        "    Max_Paused_Peerlist_Size = 2000 \n",
        "    Max_Failcount = 3 \n",
        "    Min_Announce_Interval = 30 \n",
        "    Min_Reconnect_Time = 20 \n",
        "    Request_Timeout = 10 \n",
        "    Smooth_Connects = False \n",
        "    Send_Buffer_Watermark_MB = 5  \n",
        "    Seed_Time_Limit = 60 \n",
        "    Tracker_Completion_Timeout = 30 \n",
        "    Upload_Rate_Limit_KB = 0  \n",
        "    User_Agent = '\"Utorrent\"/3.5.5' \n",
        "\n",
        "    sett = {\n",
        "        'allow_multiple_connections_per_ip': True,\n",
        "        'active_downloads': config.activedownloads,\n",
        "        'active_seeds':Active_Seeds,\n",
        "        'active_checking': Active_Checking,\n",
        "        'active_limit':Active_Limit,\n",
        "        'active_seeds':Active_Seeds,    \n",
        "        'announce_to_all_tiers': Announce_To_All_Tiers,\n",
        "        'announce_to_all_trackers':Announce_To_All_Trackers,\n",
        "        'allow_multiple_connections_per_ip':True,\n",
        "        'auto_sequential':True,\n",
        "        'auto_manage_interval': 30,\n",
        "        'connections_limit':Connections_Limit,\n",
        "        'connection_speed': Connection_Speed,\n",
        "        'connections_slack':Connections_Slack,\n",
        "        'close_redundant_connections':True,\n",
        "        'file_pool_size':File_Pool_Size,\n",
        "        'local_service_announce_interval':200,\n",
        "        'max_rejects':Max_Rejects,\n",
        "        'max_peerlist_size': Max_Peerlist_Size,\n",
        "        'max_paused_peerlist_size': Max_Paused_Peerlist_Size,\n",
        "        'max_failcount':Max_Failcount,\n",
        "        'min_announce_interval':Min_Announce_Interval,\n",
        "        'min_reconnect_time': Min_Reconnect_Time,\n",
        "        'peer_timeout':20,\n",
        "        'request_timeout':Request_Timeout,\n",
        "        'half_open_limit': Half_Open_Limit,\n",
        "        'send_buffer_watermark':Send_Buffer_Watermark_MB*1024*1024,\n",
        "        'smooth_connects':Smooth_Connects,\n",
        "        'strict_end_game_mode':True,\n",
        "        'seed_time_limit': Seed_Time_Limit,\n",
        "        'tracker_completion_timeout':Tracker_Completion_Timeout,\n",
        "        'upload_rate_limit':Upload_Rate_Limit_KB*1024,\n",
        "        'user_agent': User_Agent,\n",
        "        #'inactivity_timeout':20,  \n",
        "        #'ban_web_seeds':False   \n",
        "        }\n",
        "    ses.apply_settings(sett)    \n",
        "    settings = ses.get_settings()\n",
        "    setn =[]\n",
        "    for x in settings:\n",
        "        setn.append(str(x))\n",
        "    setn.sort() \n",
        "\n",
        "def clear_temp_pathes():\n",
        "    Delete_torrent_files = True \n",
        "    Clear_done_folder = True  \n",
        "    Clear_temp_folder = False  \n",
        "    if Delete_torrent_files:\n",
        "        !find . -maxdepth 1 -name \"*.torrent\" -type f -delete \n",
        "    if Clear_done_folder:  \n",
        "        !rm -r \"$done_path/\"* \n",
        "    if Clear_temp_folder:\n",
        "        !rm -r \"$temp_save/\"* \n",
        "    release()    \n",
        "\n",
        "def backthreadchecker(threadset):\n",
        "    try:\n",
        "        at = arethreadsworking(threadset)\n",
        "        while at: \n",
        "            info(f\"Active tasks: {', '.join(at)}\")\n",
        "            time.sleep(0.5)\n",
        "            at = arethreadsworking(threadset)\n",
        "            if not at:\n",
        "                info(\"Threads have finished working.\") \n",
        "                switchview(config_vbox.maincontainer) \n",
        "    except Exception as e:\n",
        "        error(ex())\n",
        "    release()\n",
        "\n",
        "if arethreadsworking(config.setupthreads):\n",
        "    for thread in config.setupthreads:\n",
        "        thread.join()\n",
        "\n",
        "init = True\n",
        "info(\"Cell execution done.\")\n",
        "release()\n",
        "\n",
        "js = makeclickjs(UICLICKER_RUN, 200, use_evaljs= False, enable_console= False, getstr= True)\n",
        "if not dev:\n",
        "    #if IS_ENV_COLAB:  output.clear() \n",
        "    display(container, Javascript(js))\n",
        "\n",
        "# using Javascript is persisted in the output\n",
        "# when cell done executing with setup thread running in the background, output is cleared.\n",
        "# to debug and see exceptions turn off all back threads.\n",
        "# format table:: table.style.format({\"ww1\": lambda value: {\"white-space\": \"pre-wrap\", \"word-break\": \"break-word\"}})\n",
        "# t1 = t.style.format({\"aa\": lambda value: html.unescape(value)})\n",
        "# an issue happens after inhereting bokeh.models.cell_formatter class, then creating a tabulator and display it"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "cellView": "form",
        "id": "ZxUTGFyDuBUz"
      },
      "outputs": [],
      "source": [
        "#@title { form-width: \"2%\" }\n",
        "#@markdown\n",
        " \n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "include_colab_link": true,
      "name": "Hydraulic",
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3.9.7 64-bit",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.11"
    },
    "vscode": {
      "interpreter": {
        "hash": "c347c8f9a7ef94e4c9e03b4513be7835ed18f45b99a2a817fb579f408b867b16"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
